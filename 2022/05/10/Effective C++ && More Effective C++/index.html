<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Effective C++ &amp;&amp; More Effective C++ | 一知半解</title><meta name="author" content="一个廖少少"><meta name="copyright" content="一个廖少少"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Effective C++1. Accustoming Yourself to C++Item 1: View C++ as a federation of languagesC++应该被视为四个部分组成的联邦  C：基础C的语法，因为C++兼容C 面向对象的C++：C with Class（ctor&amp;dtor）、封装、继承、多态、虚函数（动态绑定） 模板C++：模板元编程 STL  It">
<meta property="og:type" content="article">
<meta property="og:title" content="Effective C++ &amp;&amp; More Effective C++">
<meta property="og:url" content="https://edisonleolhl.github.io/2022/05/10/Effective%20C++%20&&%20More%20Effective%20C++/index.html">
<meta property="og:site_name" content="一知半解">
<meta property="og:description" content="Effective C++1. Accustoming Yourself to C++Item 1: View C++ as a federation of languagesC++应该被视为四个部分组成的联邦  C：基础C的语法，因为C++兼容C 面向对象的C++：C with Class（ctor&amp;dtor）、封装、继承、多态、虚函数（动态绑定） 模板C++：模板元编程 STL  It">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://edisonleolhl.github.io/images/avatar.jpeg">
<meta property="article:published_time" content="2022-05-10T04:51:41.000Z">
<meta property="article:modified_time" content="2023-05-11T16:03:02.275Z">
<meta property="article:author" content="一个廖少少">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://edisonleolhl.github.io/images/avatar.jpeg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://edisonleolhl.github.io/2022/05/10/Effective%20C++%20&amp;&amp;%20More%20Effective%20C++/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Effective C++ && More Effective C++',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-05-12 00:03:02'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/avatar.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">47</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">49</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/cover.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="一知半解"><span class="site-name">一知半解</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Effective C++ &amp;&amp; More Effective C++</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-05-10T04:51:41.000Z" title="发表于 2022-05-10 12:51:41">2022-05-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-11T16:03:02.275Z" title="更新于 2023-05-12 00:03:02">2023-05-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C-C/">C/C++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Effective C++ &amp;&amp; More Effective C++"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Effective-C"><a href="#Effective-C" class="headerlink" title="Effective C++"></a>Effective C++</h1><h2 id="1-Accustoming-Yourself-to-C"><a href="#1-Accustoming-Yourself-to-C" class="headerlink" title="1. Accustoming Yourself to C++"></a>1. Accustoming Yourself to C++</h2><h3 id="Item-1-View-C-as-a-federation-of-languages"><a href="#Item-1-View-C-as-a-federation-of-languages" class="headerlink" title="Item 1: View C++ as a federation of languages"></a>Item 1: View C++ as a federation of languages</h3><p>C++应该被视为四个部分组成的联邦</p>
<ul>
<li>C：基础C的语法，因为C++兼容C</li>
<li>面向对象的C++：C with Class（ctor&amp;dtor）、封装、继承、多态、虚函数（动态绑定）</li>
<li>模板C++：模板元编程</li>
<li>STL</li>
</ul>
<h3 id="Item-2-Prefer-consts-enums-and-inlines-to-defines"><a href="#Item-2-Prefer-consts-enums-and-inlines-to-defines" class="headerlink" title="Item 2: Prefer consts, enums, and inlines to #defines"></a>Item 2: Prefer consts, enums, and inlines to #defines</h3><ul>
<li><p>#defins对编译报错排查非常不友好</p>
</li>
<li><p>const在C++中有很多用武之地，比#defines适用广泛</p>
</li>
<li><p>enum 比const更像#defines，但没有#defines的副作用</p>
</li>
<li><p>模板+inlines可以节省函数调用的开销，比#defines好用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #defines函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CALL_WITH_MAX(a, b) f((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"><span class="built_in">CALL_WITH_MAX</span>(++a, b);          <span class="comment">// a is incremented twice</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板+inlines</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;                               <span class="comment">// because we don&#x27;t</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">callWithMax</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span>    <span class="comment">// know what T is, we</span></span></span><br><span class="line"><span class="function"></span>&#123;                                                  <span class="comment">// pass by reference-to-</span></span><br><span class="line">  <span class="built_in">f</span>(a &gt; b ? a : b);                                <span class="comment">// const — see Item 20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Item-3-Use-const-whenever-possible"><a href="#Item-3-Use-const-whenever-possible" class="headerlink" title="Item 3: Use const whenever possible"></a>Item 3: Use <code>const</code> whenever possible</h3><ul>
<li><p>constant可以帮助编译器检查使用错误</p>
</li>
<li><p>constant多才多艺：you can use it for constants at global or namespace scope (see <a href="javascript:void(0)">Item 2</a>), as well as for objects declared <code>static</code> at file, function, or block scope. Inside classes, you can use it for both static and non-static data members. For pointers, you can specify whether the pointer itself is <code>const</code>, the data it points to is <code>const</code>, both, or neither</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> greeting[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *p = greeting;                    <span class="comment">// non-const pointer,</span></span><br><span class="line">                                       <span class="comment">// non-const data</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *p = greeting;              <span class="comment">// non-const pointer,</span></span><br><span class="line">                                       <span class="comment">// const data</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> * <span class="type">const</span> p = greeting;             <span class="comment">// const pointer,</span></span><br><span class="line">                                       <span class="comment">// non-const data</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> p = greeting;       <span class="comment">// const pointer,</span></span><br><span class="line">                                       <span class="comment">// const data</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>注意const_iterator，它表现的像const T*（即指向常量的指针）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;::iterator iter =     <span class="comment">// iter acts like a T* const</span></span><br><span class="line">  vec.<span class="built_in">begin</span>();</span><br><span class="line">*iter = <span class="number">10</span>;                                 <span class="comment">// OK, changes what iter points to</span></span><br><span class="line">++iter;                                    <span class="comment">// error! iter is const</span></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt;::const_iterator cIter =   <span class="comment">//cIter acts like a const T*</span></span><br><span class="line">  vec.<span class="built_in">begin</span>();</span><br><span class="line">*cIter = <span class="number">10</span>;                               <span class="comment">// error! *cIter is const</span></span><br><span class="line">++cIter;                                  <span class="comment">// fine, changes cIter</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>const成员函数很好用，仅仅是函数的常量性也可以重载成员函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>&amp;                                       <span class="comment">// operator[] for</span></span><br><span class="line"> <span class="keyword">operator</span>[](<span class="type">const</span> std::<span class="type">size_t</span> position) <span class="type">const</span>      <span class="comment">// const objects</span></span><br><span class="line"> &#123; <span class="keyword">return</span> text[position]; &#125;</span><br><span class="line"> <span class="type">char</span>&amp;                                             <span class="comment">// operator[] for</span></span><br><span class="line"> <span class="keyword">operator</span>[](<span class="type">const</span> std::<span class="type">size_t</span> position) <span class="type">const</span>      <span class="comment">// non-const objects</span></span><br><span class="line"> &#123; <span class="keyword">return</span> text[position]; &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译器只能bitwise-constness，即const成员函数不允许修改任何非static的成员变量，但是这样就无法检查那些指针成员变量，这样很可能会与预期不符；但有些时候需要使得成员变量可修改（如在length()成员函数中获取长度），则可以用mutable关键解决。编译器只能这样，但我们编写代码的时候一定要按照logical-constness去编写</p>
</li>
<li><p>当const成员函数与非const成员函数有重复代码时，可以用non-const版本去调用const版本，从而节省代码，非const版本对const并没有做出任何承诺，所以自由度更大</p>
</li>
</ul>
<h3 id="Item-4-Make-sure-that-objects-are-initialized-before-they’re-used"><a href="#Item-4-Make-sure-that-objects-are-initialized-before-they’re-used" class="headerlink" title="Item 4: Make sure that objects are initialized before they’re used"></a>Item 4: Make sure that objects are initialized before they’re used</h3><ul>
<li><p>分清楚构造函数的初始化与赋值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是先给所有成员变量调用默认构造函数进行初始化，然后再给他们赋值</span></span><br><span class="line">ABEntry::<span class="built_in">ABEntry</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> std::string&amp; address,</span><br><span class="line">                 <span class="type">const</span> std::list&lt;PhoneNumber&gt;&amp; phones)</span><br><span class="line">&#123;</span><br><span class="line">  theName = name;                       <span class="comment">// these are all assignments,</span></span><br><span class="line">  theAddress = address;                 <span class="comment">// not initializations</span></span><br><span class="line">  thePhones = phones</span><br><span class="line">  numTimesConsulted = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接进行成员变量初始化，而不是赋值，可以节约</span></span><br><span class="line">ABEntry::<span class="built_in">ABEntry</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> std::string&amp; address,</span><br><span class="line">                 <span class="type">const</span> std::list&lt;PhoneNumber&gt;&amp; phones)</span><br><span class="line">: <span class="built_in">theName</span>(name),</span><br><span class="line">  <span class="built_in">theAddress</span>(address),                  <span class="comment">// these are now all initializations</span></span><br><span class="line">  <span class="built_in">thePhones</span>(phones),</span><br><span class="line">  <span class="built_in">numTimesConsulted</span>(<span class="number">0</span>)</span><br><span class="line">&#123;&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>注意成员变量初始化的顺序并不是构造函数中写的那样，而是他们在类中的声明顺序！</p>
</li>
</ul>
<h2 id="2-Constructors-Destructors-and-Assignment-Operators"><a href="#2-Constructors-Destructors-and-Assignment-Operators" class="headerlink" title="2. Constructors, Destructors, and Assignment Operators"></a>2. Constructors, Destructors, and Assignment Operators</h2><h3 id="Item-5-Know-what-functions-C-silently-writes-and-calls"><a href="#Item-5-Know-what-functions-C-silently-writes-and-calls" class="headerlink" title="Item 5: Know what functions C++ silently writes and calls"></a>Item 5: Know what functions C++ silently writes and calls</h3><ul>
<li><p>如果你像下面这样简单声明一个类，编译器会给你自动生成默认构造函数、默认析构函数、默认赋值函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Empty</span>() &#123; ... &#125;                            <span class="comment">// default constructor</span></span><br><span class="line">  <span class="built_in">Empty</span>(<span class="type">const</span> Empty&amp; rhs) &#123; ... &#125;            <span class="comment">// copy constructor</span></span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">Empty</span>() &#123; ... &#125;                           <span class="comment">// destructor — </span></span><br><span class="line">  Empty&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Empty&amp; rhs) &#123; ... &#125; <span class="comment">// copy assignment operator</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果你写了构造函数，编译器就不会生成默认构造函数</p>
</li>
<li><p>默认拷贝构造函数与默认拷贝赋值函数仅仅把非static的成员变量拷贝过去（这又会调用成员变量的拷贝构造函数）</p>
</li>
<li><p>如果类的成员变量中有引用类型或者const类型，则<strong>必须</strong>由程序员手动编写拷贝赋值函数，否则编译器不知如何去生成默认的</p>
</li>
</ul>
<h3 id="Item-6-Explicitly-disallow-the-use-of-compiler-generated-functions-you-do-not-want"><a href="#Item-6-Explicitly-disallow-the-use-of-compiler-generated-functions-you-do-not-want" class="headerlink" title="Item 6: Explicitly disallow the use of compiler-generated functions you do not want"></a>Item 6: Explicitly disallow the use of compiler-generated functions you do not want</h3><ul>
<li><p>编译器自动生成的四个默认函数都是public的，如果你不想类的使用者调用这些自动生成的默认函数，你可以将它们声明为private</p>
</li>
<li><p>进一步地，private函数仍可以被成员函数和友元函数调用，你可以仅声明它们为private，而不实现它，这样，类的使用者在链接阶段就会报错，这在C++的iostreams库中经常使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Uncopyable</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:                                   <span class="comment">// allow construction</span></span><br><span class="line">  <span class="built_in">Uncopyable</span>() &#123;&#125;                            <span class="comment">// and destruction of</span></span><br><span class="line">  ~<span class="built_in">Uncopyable</span>() &#123;&#125;                           <span class="comment">// derived objects...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">Uncopyable</span>(<span class="type">const</span> Uncopyable&amp;);             <span class="comment">// ...but prevent copying</span></span><br><span class="line">  Uncopyable&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Uncopyable&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>C++11支持delete关键字，直接在被禁用的函数后面加上delete即可，如果有人使用，编译器会直接报错的</p>
</li>
</ul>
<h3 id="Item-7-Declare-destructors-virtual-in-polymorphic-base-classes"><a href="#Item-7-Declare-destructors-virtual-in-polymorphic-base-classes" class="headerlink" title="Item 7: Declare destructors virtual in polymorphic base classes"></a>Item 7: Declare destructors virtual in polymorphic base classes</h3><ul>
<li>when a derived class object is deleted through a pointer to a base class with a non-virtual destructor, results are undefined.</li>
<li>有可能发生的是：派生类的基类部分被析构了，但是派生类所特有的那部分成员变量没有被析构，这就是『部分析构』的问题，造成内存泄露</li>
<li>所以一定要在基类的析构函数前加上virtual关键字，保证这是个虚函数</li>
<li>但如果确定某个类不会被继承，那就不要加virtual关键字，因为虚函数会带来额外的内存开销（虚表指针）</li>
<li>知识点：纯虚函数会让类变成抽象类，抽象类无法实例化，只能作为基类。那如果我想让一个类变成抽象类，但是没有哪个虚函数可以被用作纯虚函数（纯虚函数意味着派生类一定要重写它），这时可以把析构函数声明成纯虚函数</li>
</ul>
<h3 id="Item-8-Prevent-exceptions-from-leaving-destructors"><a href="#Item-8-Prevent-exceptions-from-leaving-destructors" class="headerlink" title="Item 8: Prevent exceptions from leaving destructors"></a>Item 8: Prevent exceptions from leaving destructors</h3><ul>
<li><p>Destructors should never emit exceptions. If functions called in a destructor may throw, the destructor should catch any exceptions, then swallow them or terminate the program.</p>
</li>
<li><p>If class clients need to be able to react to exceptions thrown during an operation, the class should provide a regular (i.e., non-destructor) function that performs the operation.</p>
</li>
</ul>
<h3 id="Item-9-Never-call-virtual-functions-during-construction-or-destruction"><a href="#Item-9-Never-call-virtual-functions-during-construction-or-destruction" class="headerlink" title="Item 9: Never call virtual functions during construction or destruction"></a>Item 9: Never call virtual functions during construction or destruction</h3><ul>
<li>知识点：构造函数的构造顺序是先执行基类的构造函数，再执行派生类的构造函数；析构函数的析构顺序是先执行派生类的析构函数，再执行基类的析构函数；</li>
<li>在构造函数中调用虚函数，可能会读取派生类特有的成员变量，而这些成员变量还未初始化，读取还未初始化的变量是非常危险的，在还未调用派生类构造函数之前，该对象还是基类类型</li>
<li>在析构函数中调用虚函数，可能读取派生类特有的成员变量时，这些成员变量已经析构了，</li>
</ul>
<h3 id="Item-10-Have-assignment-operators-return-a-reference-to-this"><a href="#Item-10-Have-assignment-operators-return-a-reference-to-this" class="headerlink" title="Item 10: Have assignment operators return a reference to *this"></a>Item 10: Have assignment operators return a reference to <code>*this</code></h3><ul>
<li><p>建议赋值运算符返回<code>*this</code>，这样就可以连续赋值了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x, y, z;</span><br><span class="line"></span><br><span class="line">x = y = z = <span class="number">15</span>;                        <span class="comment">// chain of assignments</span></span><br><span class="line">x = (y = (z = <span class="number">15</span>));  									 <span class="comment">// 解析顺序</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>不仅<code>operator=</code>，<code>operator+=</code>等赋值运算符建议都这样</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  Widget&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> Widget&amp; rhs   <span class="comment">// the convention applies to</span></span><br><span class="line">  &#123;                                      <span class="comment">// +=, -=, *=, etc.</span></span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">   Widget&amp; <span class="keyword">operator</span>=(<span class="type">int</span> rhs)            <span class="comment">// it applies even if the</span></span><br><span class="line">   &#123;                                     <span class="comment">// operator&#x27;s parameter type</span></span><br><span class="line">      ...                                <span class="comment">// is unconventional</span></span><br><span class="line">      <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>所有的内置类型以及标准库几乎都这样操作了，你最好也这样，除非你有充足的理由</p>
</li>
</ul>
<h3 id="Item-11-Handle-assignment-to-self-in-operator"><a href="#Item-11-Handle-assignment-to-self-in-operator" class="headerlink" title="Item 11: Handle assignment to self in operator="></a>Item 11: Handle assignment to self in <code>operator=</code></h3><ul>
<li><p>赋值函数的编写要考虑<strong>自赋值</strong>的情况，很多时候使用者会不经意使用了自赋值，如a[i]&#x3D;a[j] or *p &#x3D; *q，考虑以下场景：Widget持有一个指向Bitmap的裸指针，这时需要小心处理赋值函数的自赋值情况</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bitmap</span> &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Bitmap *pb;                                     <span class="comment">// ptr to a heap-allocated object</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


</li>
<li><p>方法一（不推荐）：仅使用地址判断，这是一种异常不安全的方法，，假设在new的时候发生异常（比如内存不够），那么pb就指向一个已删除的bitmap，既不能安全的读，也不能安全的删除</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;rhs) <span class="keyword">return</span> *<span class="keyword">this</span>;   <span class="comment">// identity test: if a self-assignment,</span></span><br><span class="line">                                    <span class="comment">// do nothing</span></span><br><span class="line">  <span class="keyword">delete</span> pb;</span><br><span class="line">  pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法二（还可以）：先复制指针，这是一种异常安全的方法，即使在new的时候发生异常，pb也不会便</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">  Bitmap *pOrig = pb;               <span class="comment">// remember original pb</span></span><br><span class="line">  pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);         <span class="comment">// point pb to a copy of rhs&#x27;s bitmap</span></span><br><span class="line">  <span class="keyword">delete</span> pOrig;                     <span class="comment">// delete the original pb</span></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法三（推荐）：copy-and-swap技巧，非常有用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&amp; rhs)</span></span>;   <span class="comment">// exchange *this&#x27;s and rhs&#x27;s data;</span></span><br><span class="line">  ...                       <span class="comment">// see Item 29 for details</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">  Widget <span class="built_in">temp</span>(rhs);             <span class="comment">// make a copy of rhs&#x27;s data</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">swap</span>(temp);                   <span class="comment">// swap *this&#x27;s data with the copy&#x27;s</span></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Item-12-Copy-all-parts-of-an-object"><a href="#Item-12-Copy-all-parts-of-an-object" class="headerlink" title="Item 12: Copy all parts of an object"></a>Item 12: Copy all parts of an object</h3><ul>
<li><p>知识点：编译器默认生成的拷贝函数（拷贝构造&amp;&amp;拷贝赋值）会把每个成员变量拷贝过去</p>
</li>
<li><p>当你自己编写了拷贝函数，你肯定不喜欢默认的拷贝函数，当你编写了拷贝函数后，又往里面添加了成员变量，如果不修改原来的拷贝函数，那么会造成<strong>部分拷贝</strong>的问题（同时你也要修改构造函数与operator&#x3D;）</p>
</li>
<li><p>当有继承关系时，派生类的拷贝函数别忘记拷贝基类的成员变量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PriorityCustomer</span>: <span class="keyword">public</span> Customer&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PriorityCustomer&amp;</span><br><span class="line">PriorityCustomer::<span class="keyword">operator</span>=(<span class="type">const</span> PriorityCustomer&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">logCall</span>(<span class="string">&quot;PriorityCustomer copy assignment operator&quot;</span>);</span><br><span class="line"></span><br><span class="line">  Customer::<span class="keyword">operator</span>=(rhs);           <span class="comment">// assign base class parts</span></span><br><span class="line">  priority = rhs.priority;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不应在拷贝赋值函数中调用拷贝构造函数，因为拷贝赋值函数是在对象已存在的时候才调用的</p>
</li>
<li><p>同理，不应在拷贝构造函数中调用拷贝赋值函数，因为拷贝构造函数是在对象还不存在的时候才调用的</p>
</li>
<li><p>如果你发现，拷贝构造函数与拷贝赋值函数有许多重复代码段，那么可以抽出一个private成员函数（一般叫init函数）来节省代码</p>
</li>
</ul>
<h2 id="Resource-Management"><a href="#Resource-Management" class="headerlink" title="Resource Management"></a>Resource Management</h2><h3 id="Item-13-Use-objects-to-manage-resources-（RAII：Resource-Acquisition-Is-Initialization）"><a href="#Item-13-Use-objects-to-manage-resources-（RAII：Resource-Acquisition-Is-Initialization）" class="headerlink" title="Item 13: Use objects to manage resources.（RAII：Resource Acquisition Is Initialization）"></a>Item 13: Use objects to manage resources.（RAII：Resource Acquisition Is Initialization）</h3><ul>
<li>把对象的指针直接给使用者，很容易造成内存泄露，因为我们没法保证使用者的操作会不会遗漏delete</li>
<li>最好的方法是用工厂方法把对象包裹在指针（特别是引用计数的智能指针，reference-counting smart pointer，RCSP）中，返回给使用者，这样在类的析构函数中就会自动释放内存，不用操心使用者的使用方式了</li>
<li>因为拷贝auto_ptr会置空，所以用tr1::shared_ptr通常是个更好的选择</li>
</ul>
<h3 id="Item-14-Think-carefully-about-copying-behavior-in-resource-managing-classes"><a href="#Item-14-Think-carefully-about-copying-behavior-in-resource-managing-classes" class="headerlink" title="Item 14: Think carefully about copying behavior in resource-managing classes."></a>Item 14: Think carefully about copying behavior in resource-managing classes.</h3><ul>
<li>不是所有的资源都是在堆中的， 所以智能指针不合适来管理这些资源</li>
<li>比如，一个叫lock_guard的类来管理lock，这样lock的使用者就不用担心忘记调用unlock了，但是这时lock_guard被拷贝了怎么办？可以为lock_guard禁止拷贝（参考item6，将拷贝函数设为privite，或者用C++11中的delete关键字）</li>
</ul>
<h3 id="Item-15-Provide-access-to-raw-resources-in-resource-managing-classes"><a href="#Item-15-Provide-access-to-raw-resources-in-resource-managing-classes" class="headerlink" title="Item 15: Provide access to raw resources in resource-managing classes."></a>Item 15: Provide access to raw resources in resource-managing classes.</h3><ul>
<li>智能指针如shared_ptr提供了get()函数获得原来的裸指针，已获得向C API的兼容</li>
</ul>
<h3 id="Item-16-Use-the-same-form-in-corresponding-uses-of-new-and-delete"><a href="#Item-16-Use-the-same-form-in-corresponding-uses-of-new-and-delete" class="headerlink" title="Item 16: Use the same form in corresponding uses of new and delete."></a>Item 16: Use the same form in corresponding uses of <code>new</code> and <code>delete</code>.</h3><ul>
<li>知识点：new关键字干两件事，通过operator new分配内存，一个或多个构造函数在那片内存上被调用；delete关键字也干两件事，一个或多个析构函数在那片内存上被调用，然后通过operator delete释放内存</li>
<li>If you use <code>[]</code> in a <code>new</code> expression, you must use <code>[]</code> in the corresponding <code>delete</code> expression. If you don’t use <code>[]</code> in a <code>new</code> expression, you mustn’t use <code>[]</code> in the corresponding <code>delete</code> expression.</li>
</ul>
<h3 id="Item-17-Store-newed-objects-in-smart-pointers-in-standalone-statements"><a href="#Item-17-Store-newed-objects-in-smart-pointers-in-standalone-statements" class="headerlink" title="Item 17: Store newed objects in smart pointers in standalone statements."></a>Item 17: Store <code>newed</code> objects in smart pointers in standalone statements.</h3><ul>
<li><p>使用智能指针管理对象时要在单独声明的语句中执行，否则在异常情况会有内存泄露</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">processWidget</span>(std::tr1::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget), <span class="built_in">priority</span>());</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译器可能出于效率考虑编排顺序，假设顺序如下，而在priority发生异常时，new出来的内存就会被泄露</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 执行<span class="keyword">new</span> Widget</span><br><span class="line"><span class="number">2.</span> 调用<span class="built_in">priority</span>()函数</span><br><span class="line"><span class="number">3.</span> 调用std::tr1::shared_ptr的构造函数</span><br></pre></td></tr></table></figure>
</li>
<li><p>感觉这种情况挺极端的，一般大家都会这样写吧</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="function">tr1::shared_ptr&lt;Widget&gt; <span class="title">pw</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;  <span class="comment">// store newed object</span></span><br><span class="line">                                              <span class="comment">// in a smart pointer in a</span></span><br><span class="line">                                              <span class="comment">// standalone statement</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">processWidget</span>(pw, <span class="built_in">priority</span>());                <span class="comment">// this call won&#x27;t leak</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Designs-and-Declarations"><a href="#Designs-and-Declarations" class="headerlink" title="Designs and Declarations"></a>Designs and Declarations</h2><h3 id="Item-18-Make-interfaces-easy-to-use-correctly-and-hard-to-use-incorrectly"><a href="#Item-18-Make-interfaces-easy-to-use-correctly-and-hard-to-use-incorrectly" class="headerlink" title="Item 18: Make interfaces easy to use correctly and hard to use incorrectly"></a>Item 18: Make interfaces easy to use correctly and hard to use incorrectly</h3><ul>
<li>Ways to prevent errors include creating new types, restricting operations on types, constraining object values, and eliminating client resource management responsibilities.i</li>
</ul>
<h3 id="Item-19-Treat-class-design-as-type-design"><a href="#Item-19-Treat-class-design-as-type-design" class="headerlink" title="Item 19: Treat class design as type design"></a>Item 19: Treat class design as type design</h3><ul>
<li>How should objects of your new type be created and destroyed?–<code>operator new</code>, <code>operator new[]</code>, <code>operator delete</code>, and <code>operator delete[]</code></li>
<li>How should object initialization differ from object assignment?</li>
<li>What does it mean for objects of your new type to be passed by value?–defined by copy constructor</li>
<li>What are the restrictions on legal values for your new type?–parameters of ctors must be valid</li>
<li><strong>Does your new type fit into an inheritance graph?</strong>–如果新类继承自某个基类，那就要遵守已存在的继承体系，如果新类要作为其他类的基类，就要注意virtual的声明</li>
<li>What kind of type conversions are allowed for your new type?</li>
<li>What standard functions should be disallowed?–用private或delete关键字声明成员函数</li>
<li><strong>Who should have access to the members of your new type?</strong>–public ? private ?</li>
<li>What is the “undeclared interface” of your new type?</li>
<li>How general is your new type?</li>
<li><strong>Is a new type really what you need?</strong></li>
</ul>
<h3 id="Item-20-Prefer-pass-by-reference-to-const-to-pass-by-value"><a href="#Item-20-Prefer-pass-by-reference-to-const-to-pass-by-value" class="headerlink" title="Item 20: Prefer pass-by-reference-to-const to pass-by-value"></a>Item 20: Prefer pass-by-reference-to-<code>const</code> to pass-by-value</h3><ul>
<li>pass-by-value需要多次调用构造函数和析构函数，传const引用可以节省</li>
<li>传const引用可以避免slicing problem，即当一个派生类对象被按值传递为基类对象，这样就只调用了基类对象的构造函数，派生类对象特有的部分就被sliced off了</li>
<li>对于C++的内置类型，如int，还是pass-by-values效率更高，因为引用在编译器的角度看来就是指针，解引用是需要性能的，主要有些大的内置类型，如STL的容器，里面不止有一个指针，所以还是pass-by-reference-to-const最好</li>
<li>总之，对于内置类型、STL迭代器以及函数对象类型，可以考虑pass-by-value，其他的都可以用paas-by-reference-to-const</li>
</ul>
<h3 id="Item-21-Don’t-try-to-return-a-reference-when-you-must-return-an-object"><a href="#Item-21-Don’t-try-to-return-a-reference-when-you-must-return-an-object" class="headerlink" title="Item 21: Don’t try to return a reference when you must return an object"></a>Item 21: Don’t try to return a reference when you must return an object</h3><ul>
<li><p>Never return a pointer or reference to a local stack object, a reference to a heap-allocated object, or a pointer or reference to a local static object if there is a chance that more than one such object will be needed.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Rational</span>(lhs.n * rhs.n, lhs.d * rhs.d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Item-22-Declare-data-members-private"><a href="#Item-22-Declare-data-members-private" class="headerlink" title="Item 22: Declare data members private"></a>Item 22: Declare data members <code>private</code></h3><ul>
<li>保持一致性，用户只能使用成员函数来获取成员</li>
<li>这样就可以提供只读、只写、可读写的成员变量</li>
<li>对成员封装，用户看不到实际值，对用户暴露的接口只需要提供不变的语义即可，类的作者可以在后面改变行为，如果一开始就给用户暴露了成员变量，那么推动用户去修改他们的代码是很困难的</li>
</ul>
<h3 id="Item-23-Prefer-non-member-non-friend-functions-to-member-functions"><a href="#Item-23-Prefer-non-member-non-friend-functions-to-member-functions" class="headerlink" title="Item 23: Prefer non-member non-friend functions to member functions"></a>Item 23: Prefer non-member non-friend functions to member functions</h3><ul>
<li>封装性：我们对一个东西封装得越多，它暴露的东西就越少，那么我们对它的修改灵活性就大大提高了</li>
<li>知识点：only members and friends have access to private members.</li>
<li>因为成员函数还可以看见private成员变量与private函数，所以封装性不如非友元成员函数好，所以我们更希望用non-member non-friend function</li>
<li>Putting all convenience functions in multiple header files — but one namespace — also means that clients can easily extend the set of convenience functions. All they have to do is add more non-member non-friend functions to the namespace.</li>
</ul>
<h3 id="Item-24-Declare-non-member-functions-when-type-conversions-should-apply-to-all-parameters"><a href="#Item-24-Declare-non-member-functions-when-type-conversions-should-apply-to-all-parameters" class="headerlink" title="Item 24: Declare non-member functions when type conversions should apply to all parameters"></a>Item 24: Declare non-member functions when type conversions should apply to all parameters</h3><ul>
<li><p>If you need type conversions on all parameters to a function (including the one pointed to by the <code>this</code> pointer), the function must be a non-member.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"></span><br><span class="line">  ...                                             <span class="comment">// contains no operator*</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs,     <span class="comment">// now a non-member</span></span><br><span class="line">                         <span class="type">const</span> Rational&amp; rhs)     <span class="comment">// function</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Rational</span>(lhs.<span class="built_in">numerator</span>() * rhs.<span class="built_in">numerator</span>(),</span><br><span class="line">                  lhs.<span class="built_in">denominator</span>() * rhs.<span class="built_in">denominator</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Rational <span class="title">oneFourth</span><span class="params">(<span class="number">1</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">Rational result;</span><br><span class="line"></span><br><span class="line">result = oneFourth * <span class="number">2</span>;                           <span class="comment">// fine</span></span><br><span class="line">result = <span class="number">2</span> * oneFourth;                           <span class="comment">// hooray, it works!</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Item-25-Consider-support-for-a-non-throwing-swap"><a href="#Item-25-Consider-support-for-a-non-throwing-swap" class="headerlink" title="Item 25: Consider support for a non-throwing swap"></a>Item 25: Consider support for a non-throwing <code>swap</code></h3><ul>
<li><p>swap函数默认调用std::swap，只需要类型T支持拷贝（构造or赋值）即可</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;          <span class="comment">// typical implementation of std::swap;</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span>         <span class="comment">// swaps a&#x27;s and b&#x27;s values</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">temp</span><span class="params">(a)</span></span>;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>但如果你编写的类有pimpl（point to implementation）技法，swap仅需交换两个指针，如果使用std::swap会交换造成三次Widget的拷贝，还会造成三次WidgetImpl的拷贝，非常影响效率</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WidgetImpl</span> &#123;                          <span class="comment">// class for Widget data;</span></span><br><span class="line"><span class="keyword">public</span>:                                     <span class="comment">// details are unimportant</span></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> a, b, c;                              <span class="comment">// possibly lots of data —</span></span><br><span class="line">  std::vector&lt;<span class="type">double</span>&gt; v;                    <span class="comment">// expensive to copy!</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;                              <span class="comment">// class using the pimpl idiom</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Widget</span>(<span class="type">const</span> Widget&amp; rhs);</span><br><span class="line">  Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)      <span class="comment">// to copy a Widget, copy its</span></span><br><span class="line">  &#123;                                         <span class="comment">// WidgetImpl object. For</span></span><br><span class="line">   ...                                      <span class="comment">// details on implementing</span></span><br><span class="line">   *pImpl = *(rhs.pImpl);                    <span class="comment">// operator= in general,</span></span><br><span class="line">   ...                                       <span class="comment">// see Items 10, 11, and 12.</span></span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  WidgetImpl *pImpl;                         <span class="comment">// ptr to object with this</span></span><br><span class="line">&#125;;   </span><br></pre></td></tr></table></figure>

<p>这时可以这样编写swap，先写一个swap成员函数，在其中调用swap函数，然后在std命名空间全特化swap函数，这样swap成员函数就会调用这个全特化版本（注意我们一般不给std命名空间<strong>加</strong>模板，但是可以在std命名空间全特化模板）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;                     <span class="comment">// same as above, except for the</span></span><br><span class="line"><span class="keyword">public</span>:                            <span class="comment">// addition of the swap mem func</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&amp; other)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::swap;               <span class="comment">// the need for this declaration</span></span><br><span class="line">                                   <span class="comment">// is explained later in this Item</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap</span>(pImpl, other.pImpl);      <span class="comment">// to swap Widgets, swap their</span></span><br><span class="line">  &#125;                                <span class="comment">// pImpl pointers</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span>&lt;&gt;                       <span class="comment">// revised specialization of</span></span><br><span class="line">  <span class="type">void</span> <span class="built_in">swap</span>&lt;Widget&gt;(Widget&amp; a,     <span class="comment">// std::swap</span></span><br><span class="line">                    Widget&amp; b)</span><br><span class="line">  &#123;</span><br><span class="line">    a.<span class="built_in">swap</span>(b);                     <span class="comment">// to swap Widgets, call their</span></span><br><span class="line">  &#125;                                <span class="comment">// swap member function</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>但， 加入Widget与WidgetImpl不是类，而是类模板，上面的swap方法就行不通了，因为：类模板可以偏特化，但函数模板不能偏特化，所以以下函数模板行不通</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="type">void</span> swap&lt;Widget&lt;T&gt; &gt;(Widget&lt;T&gt;&amp; a,      <span class="comment">// error! illegal code!</span></span><br><span class="line">                        Widget&lt;T&gt;&amp; b)</span><br><span class="line">  &#123; a.<span class="built_in">swap</span>(b); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果使用了pimpl的类模板在命名空间下，可以这样编写swap，当swap两个Widget<T>对象时，C++的命名查找规则（即argument-dependent lookup）会找到Widget-specific version in WidgetStuff命名空间，这就是我们希望的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> WidgetStuff &#123;</span><br><span class="line">  ...                                     <span class="comment">// templatized WidgetImpl, etc.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;                    <span class="comment">// as before, including the swap</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Widget</span> &#123; ... &#125;;                   <span class="comment">// member function</span></span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;                    <span class="comment">// non-member swap function;</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; a,                 <span class="comment">// not part of the std namespace</span></span></span></span><br><span class="line"><span class="params"><span class="function">            Widget&lt;T&gt;&amp; b)</span>                                         </span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    a.<span class="built_in">swap</span>(b);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>客户端视角的最佳写法，命名查找规则在全局命名空间或一个命名空间中查找T-specific的swap函数，如果没有，则用std::swap（记得用using声明），如果类模板的创建者在std命名空间中还编写了Widget-specific的std::swap特化版本，则会用它</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">(T&amp; obj1, T&amp; obj2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">using</span> std::swap;           <span class="comment">// make std::swap available in this function</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">swap</span>(obj1, obj2);          <span class="comment">// call the best swap for objects of type T</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>建议：swap成员函数永远不要抛异常，因为swap函数就是帮助类（类模板）提供强有力的异常安全保证。但非成员函数的swap没有这个保证，因为默认的swap是基于拷贝构造与拷贝赋值的，它俩允许抛异常</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Things to Remember</span><br><span class="line">• Provide a swap member function when std::swap would be inefficient for your type. Make sure your swap doesn&#x27;t throw exceptions.</span><br><span class="line">• If you offer a member swap, also offer a non-member swap that calls the member. For classes (not templates), specialize std::swap, too.</span><br><span class="line">• When calling swap, employ a using declaration for std::swap, then call swap without namespace qualification.</span><br><span class="line">• It&#x27;s fine to totally specialize std templates for user-defined types, but never try to add something completely new to std.</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Item-26-Postpone-variable-definitions-as-long-as-possible"><a href="#Item-26-Postpone-variable-definitions-as-long-as-possible" class="headerlink" title="Item 26: Postpone variable definitions as long as possible."></a>Item 26: Postpone variable definitions as long as possible.</h3><ul>
<li><p>变量的定义要越晚越好，否则有可能白白执行默认构造函数与默认析构函数</p>
</li>
<li><p>变量的定义与初始化最好放一起，以提供性能</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">  std::string encrypted;                <span class="comment">// default-construct encrypted</span></span><br><span class="line">  encrypted = password;                 <span class="comment">// assign to encrypted</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="function">std::string <span class="title">encrypted</span><span class="params">(password)</span></span>;        <span class="comment">// define and initialize</span></span><br><span class="line">                                          <span class="comment">// via copy constructor</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>注意循环内外的变量定义区别，如果你知道赋值函数开销更小，可以使用方法A，特别是当n变大时，如果赋值函数开销很大，可以使用方法B</p>
<blockquote>
<p>• Approach A: 1 constructor + 1 destructor + <code>n</code> assignments.</p>
</blockquote>
<blockquote>
<p>• Approach B: <code>n</code> constructors + <code>n</code> destructors.</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Approach A: define outside loop   // Approach B: define inside loop</span></span><br><span class="line"></span><br><span class="line">Widget w;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;         <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">  w = some value dependent on i;       <span class="function">Widget <span class="title">w</span><span class="params">(some value dependent on i)</span></span>;</span><br><span class="line">  ...                                  ...</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Item-27-Minimize-casting"><a href="#Item-27-Minimize-casting" class="headerlink" title="Item 27: Minimize casting."></a>Item 27: Minimize casting.</h3><ul>
<li><p>C风格的老式转换</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// C-style casts look like this</span></span><br><span class="line">(T) expression                      <span class="comment">// cast expression to be of type T</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Function-style casts use this syntax:</span></span><br><span class="line"><span class="built_in">T</span>(expression)                       <span class="comment">// cast expression to be of type T</span></span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p> <code>const_cast</code> is typically used to cast away the constness of objects. It is the only C++-style cast that can do this.</p>
</blockquote>
<blockquote>
<p>• <code>dynamic_cast</code> is primarily used to perform “safe downcasting,” i.e., to determine whether an object is of a particular type in an inheritance hierarchy. It is the only cast that cannot be performed using the old-style syntax. It is also the only cast that may have a significant runtime cost. (I’ll provide details on this a bit later.)</p>
</blockquote>
<blockquote>
<p>• <code>reinterpret_cast</code> is intended for low-level casts that yield implementation-dependent (i.e., unportable) results, e.g., casting a pointer to an <code>int</code>. Such casts should be rare outside low-level code. I use it only once in this book, and that’s only when discussing how you might write a debugging allocator for raw memory (see <a href="javascript:void(0)">Item 50</a>).</p>
</blockquote>
<blockquote>
<p>• <code>static_cast</code> can be used to force implicit conversions (e.g., non-<code>const</code> object to <code>const</code> object (as in <a href="javascript:void(0)">Item 3</a>), <code>int</code> to <code>double</code>, etc.). It can also be used to perform the reverse of many such conversions (e.g., <code>void*</code> pointers to typed pointers, pointer-to-base to pointer-to-derived), though it cannot cast from <code>const</code> to non-<code>const</code> objects. (Only <code>const_cast</code> can do that.)</p>
</blockquote>
<ul>
<li><p>在派生类中想调用有重写的基类函数，可以像下面这样解决</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialWindow</span>: <span class="keyword">public</span> Window &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onResize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Window::<span class="built_in">onResize</span>();                    <span class="comment">// call Window::onResize</span></span><br><span class="line">    ...                                    <span class="comment">// on *this</span></span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>建议</p>
</li>
<li><blockquote>
<p>• Avoid casts whenever practical, especially <code>dynamic_cast</code>s in performance-sensitive code. If a design requires casting, try to develop a cast-free alternative.</p>
</blockquote>
<blockquote>
<p>• When casting is necessary, try to hide it inside a function. Clients can then call the function instead of putting casts in their own code.</p>
</blockquote>
<blockquote>
<p>• Prefer C++-style casts to old-style casts. They are easier to see, and they are more specific about what they do.</p>
</blockquote>
</li>
</ul>
<h3 id="Item-28-Avoid-returning-“handles”-to-object-internals"><a href="#Item-28-Avoid-returning-“handles”-to-object-internals" class="headerlink" title="Item 28: Avoid returning “handles” to object internals."></a>Item 28: Avoid returning “handles” to object internals.</h3><ul>
<li><p>类的private成员变量，如果用public的getter方法把它们的引用暴露出去，则会造成修改</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">RectData</span> &#123;                    <span class="comment">// Point data for a Rectangle</span></span><br><span class="line">  Point ulhc;                        <span class="comment">// ulhc = &quot; upper left-hand corner&quot;</span></span><br><span class="line">  Point lrhc;                        <span class="comment">// lrhc = &quot; lower right-hand corner&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="function">Point&amp; <span class="title">upperLeft</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;ulhc; &#125; <span class="comment">// 仅仅声明成const成员函数是没法阻止客户端修改成员变量的</span></span><br><span class="line">  <span class="function">Point&amp; <span class="title">lowerRight</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;lrhc; &#125;</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::tr1::shared_ptr&lt;RectData&gt; pData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="function">Point <span class="title">coord1</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">Point <span class="title">coord2</span><span class="params">(<span class="number">100</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> Rectangle <span class="title">rec</span><span class="params">(coord1, coord2)</span></span>;     <span class="comment">// rec is a const rectangle from</span></span><br><span class="line">                                         <span class="comment">// (0, 0) to (100, 100)</span></span><br><span class="line"></span><br><span class="line">rec.<span class="built_in">upperLeft</span>().<span class="built_in">setX</span>(<span class="number">50</span>);                <span class="comment">// now rec goes from</span></span><br><span class="line">                                         <span class="comment">// (50, 0) to (100, 100)!</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>更好的做法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="type">const</span> Point&amp; <span class="title">upperLeft</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;ulhc; &#125;</span><br><span class="line">  <span class="function"><span class="type">const</span> Point&amp; <span class="title">lowerRight</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;lrhc; &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Item-29-Strive-for-exception-safe-code"><a href="#Item-29-Strive-for-exception-safe-code" class="headerlink" title="Item 29: Strive for exception-safe code."></a>Item 29: Strive for exception-safe code.</h3><ul>
<li><p>Exception-safe functions offer one of three guarantees:</p>
<blockquote>
<p>• Functions offering the basic guarantee promise that if an exception is thrown, everything in the program remains in a valid state. </p>
<p>• Functions offering the strong guarantee promise that if an exception is thrown, the state of the program is unchanged.</p>
<p>• Functions offering the nothrow guarantee promise never to throw exceptions, because they always do what they promise to do.</p>
</blockquote>
</li>
<li><p>锁资源的管理最好由智能指针维护的对象来管理，像下面的代码，如果在new抛出了异常，则lock永远不会被释放</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrettyMenu::changeBackground</span><span class="params">(std::istream&amp; imgSrc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">lock</span>(&amp;mutex);                      <span class="comment">// acquire mutex (as in Item 14)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> bgImage;                    <span class="comment">// get rid of old background</span></span><br><span class="line">  ++imageChanges;                    <span class="comment">// update image change count</span></span><br><span class="line">  bgImage = <span class="keyword">new</span> <span class="built_in">Image</span>(imgSrc);       <span class="comment">// install new background</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">unlock</span>(&amp;mutex);                    <span class="comment">// release mutex</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>除了lock的问题，如果new时抛异常，上面的代码会使bgImage指向空，所以最好的做法是用智能指针来管理，只有当new成功时，reset函数才会被调用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrettyMenu</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  std::tr1::shared_ptr&lt;Image&gt; bgImage;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrettyMenu::changeBackground</span><span class="params">(std::istream&amp; imgSrc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">Lock <span class="title">ml</span><span class="params">(&amp;mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">  bgImage.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Image</span>(imgSrc));  <span class="comment">// replace bgImage&#x27;s internal</span></span><br><span class="line">                                     <span class="comment">// pointer with the result of the</span></span><br><span class="line">                                     <span class="comment">// &quot;new Image&quot; expression</span></span><br><span class="line">  ++imageChanges;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Item-30-Understand-the-ins-and-outs-of-inlining"><a href="#Item-30-Understand-the-ins-and-outs-of-inlining" class="headerlink" title="Item 30: Understand the ins and outs of inlining."></a>Item 30: Understand the ins and outs of inlining.</h3><ul>
<li><p>内联函数不需要函数调用开销，非常棒</p>
</li>
<li><p>Bear in mind that <code>inline</code> is a request to compilers, not a command.</p>
</li>
<li><p>内联函数必须在头文件中！因为绝大多数构建环境都是在编译阶段做内联，为了用函数体替代函数调用，编译器必须知道函数是什么样子</p>
</li>
<li><p>模板也是经常放在头文件，理由同上</p>
</li>
<li><p>函数内联需要开销，会导致代码膨胀</p>
</li>
<li><p><code>virtual</code> means “wait until runtime to figure out which function to call,” and <code>inline</code> means “before execution, replace the call site with the called function.</p>
</li>
<li><blockquote>
<p>• Limit most inlining to small, frequently called functions. This facilitates debugging and binary upgradability, minimizes potential code bloat, and maximizes the chances of greater program speed.</p>
</blockquote>
<blockquote>
<p>• Don’t declare function templates <code>inline</code> just because they appear in header files.</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>• Limit most inlining to small, frequently called functions. This facilitates debugging and binary upgradability, minimizes potential code bloat, and maximizes the chances of greater program speed.</p>
</blockquote>
<blockquote>
<p>• Don’t declare function templates <code>inline</code> just because they appear in header files.</p>
</blockquote>
<h3 id="Item-31-Minimize-compilation-dependencies-between-files"><a href="#Item-31-Minimize-compilation-dependencies-between-files" class="headerlink" title="Item 31: Minimize compilation dependencies between files"></a>Item 31: Minimize compilation dependencies between files</h3><ul>
<li>Avoid using objects when object references and pointers will do</li>
<li>Depend on class declarations instead of class definitions whenever you can（只需要函数声明就可以</li>
<li>Provide separate header files for declarations and definitions</li>
</ul>
<h2 id="6-Inheritance-and-Object-Oriented-Design"><a href="#6-Inheritance-and-Object-Oriented-Design" class="headerlink" title="6. Inheritance and Object-Oriented Design"></a>6. Inheritance and Object-Oriented Design</h2><h3 id="Item-32-Make-sure-public-inheritance-models-“is-a-”"><a href="#Item-32-Make-sure-public-inheritance-models-“is-a-”" class="headerlink" title="Item 32: Make sure public inheritance models “is-a.”"></a>Item 32: Make sure public inheritance models “is-a.”</h3><ul>
<li>如果类D public继承自类B，这意味着D也是一个B（is-a），但反过来不成立，这意味着使用B的地方，也能使用D，因为D是一个B</li>
<li>这也很容易理解：一个指向基类的指针，同时也可以指向派生类</li>
</ul>
<h3 id="Item-33-Avoid-hiding-inherited-names"><a href="#Item-33-Avoid-hiding-inherited-names" class="headerlink" title="Item 33: Avoid hiding inherited names"></a>Item 33: Avoid hiding inherited names</h3><ul>
<li><p>C++的同名局部变量会覆盖同名全局变量，这就是hiding names</p>
</li>
<li><p>在继承体系中，基类部分的内容被嵌入（nested）在派生类的作用域中，所以可以在派生类的作用域中调用其基类的方法或者读取成员，或者是enums，内嵌类，typedefs</p>
</li>
<li><p>基类的重载函数，会被派生类的同名函数所隐藏，即<strong>重载无法被继承</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">mf4</span><span class="params">()</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">d.<span class="built_in">mf1</span>();                   <span class="comment">// fine, calls Derived::mf1</span></span><br><span class="line">d.<span class="built_in">mf1</span>(x);                  <span class="comment">// error! Derived::mf1 hides Base::mf1</span></span><br><span class="line"></span><br><span class="line">d.<span class="built_in">mf2</span>();                   <span class="comment">// fine, calls Base::mf2</span></span><br><span class="line"></span><br><span class="line">d.<span class="built_in">mf3</span>();                   <span class="comment">// fine, calls Derived::mf3</span></span><br><span class="line">d.<span class="built_in">mf3</span>(x);                  <span class="comment">// error! Derived::mf3 hides Base::mf3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>若想使重载也能被继承，需要使用<strong>using</strong>关键字（注意得在public域中）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> Base::mf1;       <span class="comment">// make all things in Base named mf1 and mf3</span></span><br><span class="line">  <span class="keyword">using</span> Base::mf3;       <span class="comment">// visible (and public) in Derived&#x27;s scope</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">mf4</span><span class="params">()</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Derived d;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">d.<span class="built_in">mf1</span>();                 <span class="comment">// still fine, still calls Derived::mf1</span></span><br><span class="line">d.<span class="built_in">mf1</span>(x);                <span class="comment">// now okay, calls Base::mf1</span></span><br><span class="line"></span><br><span class="line">d.<span class="built_in">mf2</span>();                 <span class="comment">// still fine, still calls Base::mf2</span></span><br><span class="line"></span><br><span class="line">d.<span class="built_in">mf3</span>();                 <span class="comment">// fine, calls Derived::mf3</span></span><br><span class="line">d.<span class="built_in">mf3</span>(x);                <span class="comment">// now okay, calls Base::mf3</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Item-34-Differentiate-between-inheritance-of-interface-and-inheritance-of-implementation"><a href="#Item-34-Differentiate-between-inheritance-of-interface-and-inheritance-of-implementation" class="headerlink" title="Item 34: Differentiate between inheritance of interface and inheritance of implementation"></a>Item 34: Differentiate between inheritance of interface and inheritance of implementation</h3><ul>
<li><p>区别接口继承与实现继承，它们正好对应函数声明与函数定义的区别</p>
</li>
<li><p>知识点：纯虚函数会使得类变成抽象类，即无法被实例化，只能用于被继承的基类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">error</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">objectID</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>声明纯虚函数的意义在于，派生类仅仅继承了函数接口（funciton interface），就像上面的Shape::draw，具体的实现还是要派生类自己去定义</strong></p>
</li>
<li><p>从语法的角度，纯虚函数也可以有定义，调用纯虚函数的唯一方式是通过类名：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>: <span class="keyword">public</span> Shape &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ellipse</span>: <span class="keyword">public</span> Shape &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Shape *ps = <span class="keyword">new</span> Shape;              <span class="comment">// error! Shape is abstract</span></span><br><span class="line"></span><br><span class="line">Shape *ps1 = <span class="keyword">new</span> Rectangle;         <span class="comment">// fine</span></span><br><span class="line">ps1-&gt;<span class="built_in">draw</span>();                     <span class="comment">// calls Rectangle::draw</span></span><br><span class="line"></span><br><span class="line">Shape *ps2 = <span class="keyword">new</span> Ellipse;           <span class="comment">// fine</span></span><br><span class="line">ps2-&gt;<span class="built_in">draw</span>();                     <span class="comment">// calls Ellipse::draw</span></span><br><span class="line"></span><br><span class="line">ps1-&gt;Shape::<span class="built_in">draw</span>();                 <span class="comment">// calls Shape::draw</span></span><br><span class="line"></span><br><span class="line">ps2-&gt;Shape::<span class="built_in">draw</span>();                 <span class="comment">// calls Shape::draw</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>声明虚函数的意义在于，派生类不仅可以继承函数接口，而且还可以继承默认实现，这意味着派生类如果不需要有特殊的实现，完全可以直接使用基类的默认实现</strong></p>
</li>
<li><p>派生类使用基类提供的虚函数默认实现，可能太过于隐式，如果基类作者想让继承者都显式声明一下，可以用下面这个技巧：因为纯虚函数，每个派生类都得重写fly方法，而基类又提供了defaultFly实现，所以派生类完全可以使用基类提供的这个默认实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Airplane</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">(<span class="type">const</span> Airport&amp; destination)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">defaultFly</span><span class="params">(<span class="type">const</span> Airport&amp; destination)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// default code for flying an airplane to the given destination</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ModelA</span>: <span class="keyword">public</span> Airplane &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">(<span class="type">const</span> Airport&amp; destination)</span></span></span><br><span class="line"><span class="function">  </span>&#123; <span class="built_in">defaultFly</span>(destination); &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ModelB</span>: <span class="keyword">public</span> Airplane &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">(<span class="type">const</span> Airport&amp; destination)</span></span></span><br><span class="line"><span class="function">  </span>&#123; <span class="built_in">defaultFly</span>(destination); &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>声明非虚函数的意义在于，派生类继承了函数接口以及强制实现，毕竟非虚函数意味着不变量，不管在继承体系中如何变动</strong></p>
</li>
<li><p>建议：</p>
<ul>
<li>The first mistake is to declare all functions non-virtual.</li>
<li>The other common problem is to declare all member functions virtual.</li>
</ul>
</li>
</ul>
<h3 id="Item-35-Consider-alternatives-to-virtual-functions"><a href="#Item-35-Consider-alternatives-to-virtual-functions" class="headerlink" title="Item 35: Consider alternatives to virtual functions"></a>Item 35: Consider alternatives to virtual functions</h3><h4 id="NVI-x2F-Tmpelate-Method"><a href="#NVI-x2F-Tmpelate-Method" class="headerlink" title="NVI &#x2F; Tmpelate Method"></a>NVI &#x2F; Tmpelate Method</h4><ul>
<li><p>This basic design — having clients call private virtual functions indirectly through public non-virtual member functions — is known as the non-virtual interface (NVI) idiom. It’s a particular manifestation of the more general design pattern called Template Method (模板方法)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="type">const</span></span>;        <span class="comment">// return character&#x27;s health rating;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// NVI/模板方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="type">const</span>               <span class="comment">// derived classes do not redefine</span></span></span><br><span class="line"><span class="function">  </span>&#123;                                     </span><br><span class="line"></span><br><span class="line">    ...                                 <span class="comment">// do &quot;before&quot; stuff — see below</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> retVal = <span class="built_in">doHealthValue</span>();       <span class="comment">// do the real work</span></span><br><span class="line"></span><br><span class="line">    ...                                 <span class="comment">// do &quot;after&quot; stuff — see below</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">doHealthValue</span><span class="params">()</span> <span class="type">const</span>     <span class="comment">// derived classes may redefine this</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    ...                                 <span class="comment">// default algorithm for calculating</span></span><br><span class="line">  &#125;                                     <span class="comment">// character&#x27;s health</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>NVI&#x2F;模板方法的好处是可以固化before&amp;after stuff，真正执行的代码交给派生类自己去实现，相当于把实现延后定义了</p>
</li>
<li><p>NVI&#x2F;模板方法还有一个好处是，固化了虚函数是何时被调用的（在before之后，在after之前），但虚函数是如何被实现的取决于派生类的实现</p>
</li>
</ul>
<h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><ul>
<li>Replace virtual functions with function pointer data members, a stripped-down manifestation of the Strategy design pattern.</li>
<li>Different instances of the same character type can have different health calculation functions.</li>
</ul>
<h4 id="通过tr1-function实现的策略模式"><a href="#通过tr1-function实现的策略模式" class="headerlink" title="通过tr1::function实现的策略模式"></a>通过tr1::function实现的策略模式</h4><ul>
<li>Replace virtual functions with tr1::function data members, thus allowing use of any callable entity with a signature compatible with what you need. This, too, is a form of the Strategy design pattern.</li>
<li>Replace virtual functions in one hierarchy with virtual functions in another hierarchy. This is the conventional implementation of the Strategy design pattern.</li>
</ul>
<h3 id="Item-36-Never-redefine-an-inherited-non-virtual-function"><a href="#Item-36-Never-redefine-an-inherited-non-virtual-function" class="headerlink" title="Item 36: Never redefine an inherited non-virtual function"></a>Item 36: Never redefine an inherited non-virtual function</h3><ul>
<li><p>继承体系中的非虚函数是静态绑定的，That means that because <code>pB</code> is declared to be of type pointer-to-<code>B</code>, non-virtual functions invoked through <code>pB</code> will always be those defined for class <code>B</code>, even if <code>pB</code> points to an object of a class derived from <code>B</code></p>
</li>
<li><p>而虚函数是动态绑定的，具体调用基类还是派生类的成员函数，取决于指针指向的对象是哪个</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>: <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">mf</span><span class="params">()</span></span>;                      <span class="comment">// hides B::mf; see Item 33</span></span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">D x;                              <span class="comment">// x is an object of type D</span></span><br><span class="line">B *pB = &amp;x;  </span><br><span class="line">D *pD = &amp;x;</span><br><span class="line"></span><br><span class="line">pB-&gt;<span class="built_in">mf</span>();                         <span class="comment">// calls B::mf</span></span><br><span class="line"></span><br><span class="line">pD-&gt;<span class="built_in">mf</span>();                         <span class="comment">// calls D::mf</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>为什么不要重定义非虚函数：公开继承意味着is-a关系，适用于基类的一切东西应该也适用于派生类，而派生类继承的基类非虚函数也应该能够适用，既然能够适用，就不应该重定义它。如果真的出现要重定义非虚函数的情况，你要看看你的类设计是否合理（比如该方法是否应该变成虚函数）</p>
</li>
</ul>
<h3 id="Item-37-Never-redefine-a-function’s-inherited-default-parameter-value"><a href="#Item-37-Never-redefine-a-function’s-inherited-default-parameter-value" class="headerlink" title="Item 37: Never redefine a function’s inherited default parameter value"></a>Item 37: Never redefine a function’s inherited default parameter value</h3><ul>
<li><p>静态类型在编译器就决定了，而动态类型在运行时才知道</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Shape *ps;                       <span class="comment">// static type = Shape*</span></span><br><span class="line">Shape *pc = <span class="keyword">new</span> Circle;          <span class="comment">// static type = Shape*</span></span><br><span class="line">Shape *pr = <span class="keyword">new</span> Rectangle;       <span class="comment">// static type = Shape*</span></span><br><span class="line"></span><br><span class="line">ps = pc;                       <span class="comment">// ps&#x27;s dynamic type is</span></span><br><span class="line">                               <span class="comment">// now Circle*</span></span><br><span class="line"></span><br><span class="line">ps = pr;                       <span class="comment">// ps&#x27;s dynamic type is</span></span><br><span class="line">                               <span class="comment">// now Rectangle*</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>virtual functions are dynamically bound(late bound), but default parameter values are statically bound(early bound).</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">enum</span> <span class="title class_">ShapeColor</span> &#123; Red, Green, Blue &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// all shapes must offer a function to draw themselves</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Red)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>: <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// notice the different default parameter value — bad!</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Green)</span> <span class="type">const</span></span>; <span class="comment">// 不会如你所愿的调用Green默认参数</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Shape *pr = <span class="keyword">new</span> Rectangle;       <span class="comment">// static type = Shape*</span></span><br><span class="line">pr-&gt;<span class="built_in">draw</span>();                       <span class="comment">// calls Rectangle::draw(Shape::Red)!</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在继承体系中，如果你想修改虚函数的默认参数，这根本不管用，C++是出于运行时效率考量的，因为如果默认参数还是动态绑定的话，那么在运行时还得去找合适的虚函数默认参数</p>
</li>
</ul>
<h3 id="Item-38-Model-“has-a”-or-“is-implemented-in-terms-of”-through-composition"><a href="#Item-38-Model-“has-a”-or-“is-implemented-in-terms-of”-through-composition" class="headerlink" title="Item 38: Model “has-a” or “is-implemented-in-terms-of” through composition"></a>Item 38: Model “has-a” or “is-implemented-in-terms-of” through composition</h3><ul>
<li>组合：Composition is the relationship between types that arises when objects of one type contain objects of another type.</li>
<li>组合意味着has-a的关系，或者是implemented in terms of的关系，has-a的关系很好理解，而implemented in terms of的关系可以这样理解：想象一下你正在设计一个set，但是STL默认的set模板是用二叉搜索树实现的，所以多包含了一些指针，你的程序对内存很吃紧，所以得自己实现一个，你决定用STL的list模板来实现，因为list允许重复，所以你的set肯定不能公开继承list（那意味着is-a）关系，你决定在你的set模板的成员函数中组合一个std::list，这个时候就说明了你的set is implemented in-terms-of std::set！</li>
<li>In the application domain, composition means has-a. In the implementation domain, it means is-implemented-in-terms-of.</li>
</ul>
<h3 id="Item-39-Use-private-inheritance-judiciously（审慎地）"><a href="#Item-39-Use-private-inheritance-judiciously（审慎地）" class="headerlink" title="Item 39: Use private inheritance judiciously（审慎地）"></a>Item 39: Use private inheritance judiciously（审慎地）</h3><ul>
<li><p>知识点：私有继承不能将派生类转换为基类（就像下面代码出错的那样），以及，私有继承自基类的成员函数，在派生类当中是private的  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>: <span class="keyword">private</span> Person &#123; ... &#125;;     <span class="comment">// inheritance is now private</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">(<span class="type">const</span> Person&amp; p)</span></span>;                 <span class="comment">// anyone can eat</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">study</span><span class="params">(<span class="type">const</span> Student&amp; s)</span></span>;              <span class="comment">// only students study</span></span><br><span class="line"></span><br><span class="line">Person p;                                  <span class="comment">// p is a Person</span></span><br><span class="line">Student s;                                 <span class="comment">// s is a Student</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">eat</span>(p);                                    <span class="comment">// fine, p is a Person</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">eat</span>(s);                                    <span class="comment">// error! a Student isn&#x27;t a Person</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>这也就意味着：私有继承是is-implemented-in-terms-of.，实现是被继承的，而接口是被忽略的</p>
</li>
<li><p>私有继承与组合一样，都是is-implemented-in-terms-of，use composition whenever you can, and use private inheritance whenever you must</p>
</li>
<li><p>一个用于私有继承的例子：empty base optimization (EBO)，仅能用于单层继承</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span> &#123;&#125;;                      <span class="comment">// has no data, so objects should</span></span><br><span class="line">                                     <span class="comment">// use no memory</span></span><br><span class="line"><span class="comment">// sizeof(Empty) is 1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HoldsAnInt</span>: <span class="keyword">private</span> Empty &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sizeof(HoldsAnInt) == sizeof(int) // 因为空基类优化，继承空基类不需要额外内存</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Item-40-Use-multiple-inheritance-judiciously"><a href="#Item-40-Use-multiple-inheritance-judiciously" class="headerlink" title="Item 40: Use multiple inheritance judiciously"></a>Item 40: Use multiple inheritance judiciously</h3><ul>
<li><p>多重继承可能会导致歧义，当两个基类有同名函数时，派生类不知道调用哪个</p>
</li>
<li><p>多重继承会带来菱形继承问题，基类的成员变量在最底下的派生类可能会被复制两次，为了解决这个问题，可以使用虚继承，但是虚继承比普通继承会带来额外开销（size、speed。。），当虚基类没有任何成员变量时，虚继承是很实用的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">File</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InputFile</span>: <span class="keyword">virtual</span> <span class="keyword">public</span> File &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OutputFile</span>: <span class="keyword">virtual</span> <span class="keyword">public</span> File &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IOFile</span>: <span class="keyword">public</span> InputFile,</span><br><span class="line">              <span class="keyword">public</span> OutputFile</span><br><span class="line">&#123; ... &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>多重继承很难理解，但还是很有用的，当某个设计必须要用到多重继承时，大胆使用吧，只是要小心上述两个问题</p>
</li>
</ul>
<h2 id="7-Templates-and-Generic-Programming"><a href="#7-Templates-and-Generic-Programming" class="headerlink" title="7. Templates and Generic Programming"></a>7. Templates and Generic Programming</h2><p>Templates are a wonderful way to save time and avoid code replication</p>
<h3 id="Item-41-Understand-implicit-interfaces-and-compile-time-polymorphism"><a href="#Item-41-Understand-implicit-interfaces-and-compile-time-polymorphism" class="headerlink" title="Item 41: Understand implicit interfaces and compile-time polymorphism"></a>Item 41: Understand implicit interfaces and compile-time polymorphism</h3><ul>
<li><p>模板元编程，类与模板都支持接口与多态</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doProcessing</span><span class="params">(T&amp; w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (w.<span class="built_in">size</span>() &gt; <span class="number">10</span> &amp;&amp; w != someNastyWidget) &#123;</span><br><span class="line">     <span class="function">T <span class="title">temp</span><span class="params">(w)</span></span>;</span><br><span class="line">     temp.<span class="built_in">normalize</span>();</span><br><span class="line">     temp.<span class="built_in">swap</span>(w);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">• What<span class="number">&#x27;</span>s important is that the set of expressions that must be valid in order <span class="keyword">for</span> the <span class="keyword">template</span> to compile is the implicit interface that T must support.</span><br><span class="line">• The calls to functions involving w such as <span class="keyword">operator</span>&gt; <span class="keyword">and</span> <span class="keyword">operator</span>!= may involve instantiating templates to make these calls succeed. Such instantiation occurs during compilation. Because instantiating function templates with different <span class="keyword">template</span> parameters leads to different functions being called, <span class="keyword">this</span> is known as compile-time polymorphism.</span><br></pre></td></tr></table></figure>
</li>
<li><p>An explicit interface typically consists of function signatures, i.e., function names, parameter types, return types, etc. An implicit interface is quite different.It consists of <strong>valid expressions</strong>.比如下面代码中，类型T的size()函数不需要返回整形，只需要operator&gt;能够在类型T与int之间使用即可，甚至可以是另一类型Y，只需要能够有隐式转换从Y到T</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doProcessing</span><span class="params">(T&amp; w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (w.<span class="built_in">size</span>() &gt; <span class="number">10</span> &amp;&amp; w != someNastyWidget) &#123;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
</li>
<li><p>类的接口在函数签名上是显式的；而模板的接口是隐式的，而且是基于valid expression的</p>
</li>
<li><p>类的多态是通过虚函数实现的，发生在运行时；而模板的多态发生在模板实例化与函数重载解析时</p>
</li>
</ul>
<h3 id="Item-42-Understand-the-two-meanings-of-typename"><a href="#Item-42-Understand-the-two-meanings-of-typename" class="headerlink" title="Item 42: Understand the two meanings of typename"></a>Item 42: Understand the two meanings of <code>typename</code></h3><ul>
<li><p>class关键字与typename关键字在声明模板类型参数时是一样的，但更推荐typename的写法，语义理解不容易出错，T不一定得是个class type，可以是int这种built-in type</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">class</span> <span class="title class_">Widget</span>;                 <span class="comment">// uses &quot;class&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Widget</span>;              <span class="comment">// uses &quot;typename&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>The general rule is simple: anytime you refer to a <strong>nested dependent type name</strong> in a template, you must immediately precede it by the word <code>typename</code>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;                           <span class="comment">// this is valid C++</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print2nd</span><span class="params">(<span class="type">const</span> C&amp; container)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (container.<span class="built_in">size</span>() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">typename</span> C::const_iterator <span class="title">iter</span><span class="params">(container.begin())</span></span>; <span class="comment">// 如果不用typename关键字告诉编译器这是内嵌类型，编译器根本不知道iter是什么，所以编译就会报错</span></span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>萃取：the type of thing pointed to by objects of type <code>IterT</code>，temp变量的类型就是由iter所指向的对象的类型，假设iter是<code>vector&lt;int&gt;::iterator</code>，那么temp就是type <code>int</code>，假设iter是<code>list&lt;string&gt;::iterator</code>，那么temp就是type <code>string</code>，<code>std::iterator_traits&lt;IterT&gt;::value_type</code>是内嵌类型，所以我们必须用typename关键字声明它</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">workWithIterator</span><span class="params">(IterT iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">typename</span> std::iterator_traits&lt;IterT&gt;::<span class="function">value_type <span class="title">temp</span><span class="params">(*iter)</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了简洁，可以用typedef</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> std::iterator_traits&lt;IterT&gt;::value_type value_type;</span><br><span class="line"></span><br><span class="line">  <span class="function">value_type <span class="title">temp</span><span class="params">(*iter)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Item-43-Know-how-to-access-names-in-templatized-base-classes"><a href="#Item-43-Know-how-to-access-names-in-templatized-base-classes" class="headerlink" title="Item 43: Know how to access names in templatized base classes"></a>Item 43: Know how to access names in templatized base classes</h3><ul>
<li><p>派生类调用基类的方法是可以的，但是模板派生类调用基类的方法不一定能成功</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CompanyA</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">sendCleartext</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">sendEncrypted</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CompanyB</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">sendCleartext</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">sendEncrypted</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MsgSender</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...                                   <span class="comment">// ctors, dtor, etc.</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">sendClear</span><span class="params">(<span class="type">const</span> MsgInfo&amp; info)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    std::string msg;</span><br><span class="line">    create msg from info;</span><br><span class="line"></span><br><span class="line">    Company c;</span><br><span class="line">    c.<span class="built_in">sendCleartext</span>(msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">sendSecret</span><span class="params">(<span class="type">const</span> MsgInfo&amp; info)</span>   <span class="comment">// similar to sendClear, except</span></span></span><br><span class="line"><span class="function">  </span>&#123; ... &#125;                                <span class="comment">// calls c.sendEncrypted</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设有需求需要在发送的时候添加日志，这很容易联想到创建一个派生类来完成这项工作，但是编译器会报错！</span></span><br><span class="line"><span class="comment">// 因为LoggingMsgSender继承自MsgSender&lt;Company&gt;，它并不知道这个类长什么样，所以就不知道有没有sendClear函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingMsgSender</span>: <span class="keyword">public</span> MsgSender&lt;Company&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...                                    <span class="comment">// ctors, dtor, etc.</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="type">const</span> MsgInfo&amp; info)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    write <span class="string">&quot;before sending&quot;</span> info to the log;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sendClear</span>(info);                     <span class="comment">// call base class function;</span></span><br><span class="line">                                         <span class="comment">// this code will not compile!</span></span><br><span class="line">    write <span class="string">&quot;after sending&quot;</span> info to the log;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 换个角度进一步说明问题，假设有companyZ，它压根没有sendCleartext函数，所以上面的LoggingMsgSender根本无法适配</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CompanyZ</span> &#123;                             <span class="comment">// this class offers no</span></span><br><span class="line"><span class="keyword">public</span>:                                      <span class="comment">// sendCleartext function</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">sendEncrypted</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 为了纠正这个问题，可以使用模板全特化total template specialization</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;                                 <span class="comment">// a total specialization of</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MsgSender</span>&lt;CompanyZ&gt; &#123;                <span class="comment">// MsgSender; the same as the</span></span><br><span class="line"><span class="keyword">public</span>:                                    <span class="comment">// general template, except</span></span><br><span class="line">  ...                                      <span class="comment">// sendCleartext is omitted</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">sendSecret</span><span class="params">(<span class="type">const</span> MsgInfo&amp; info)</span></span></span><br><span class="line"><span class="function">  </span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为了解决在模板派生类中无法调用基类函数的问题，有三种方式：</p>
<ul>
<li><p>this-&gt;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingMsgSender</span>: <span class="keyword">public</span> MsgSender&lt;Company&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="type">const</span> MsgInfo&amp; info)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    write <span class="string">&quot;before sending&quot;</span> info to the log;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">sendClear</span>(info);                <span class="comment">// okay, assumes that</span></span><br><span class="line">                                          <span class="comment">// sendClear will be inherited</span></span><br><span class="line">    write <span class="string">&quot;after sending&quot;</span> info to the log;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>using声明（注意这和item33的不同，item33阐述了基类函数被隐藏的问题，这里是编译器不去搜索基类空间除非我们显式告诉编译器</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingMsgSender</span>: <span class="keyword">public</span> MsgSender&lt;Company&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> MsgSender&lt;Company&gt;::sendClear;   <span class="comment">// tell compilers to assume</span></span><br><span class="line">  ...                                    <span class="comment">// that sendClear is in the</span></span><br><span class="line">                                         <span class="comment">// base class</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="type">const</span> MsgInfo&amp; info)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">sendClear</span>(info);                   <span class="comment">// okay, assumes that</span></span><br><span class="line">    ...                                <span class="comment">// sendClear will be inherited</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>baseClass&lt;T&gt;::foo()</code>显式调用基类命名空间，这是最后考虑的方法，以为如果这个函数是虚函数，显式指定会阻止虚函数动态绑定的行为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingMsgSender</span>: <span class="keyword">public</span> MsgSender&lt;Company&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="type">const</span> MsgInfo&amp; info)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    MsgSender&lt;Company&gt;::<span class="built_in">sendClear</span>(info);      <span class="comment">// okay, assumes that</span></span><br><span class="line">    ...                                       <span class="comment">// sendClear will be</span></span><br><span class="line">  &#125;        </span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="Item-44-Factor-parameter-independent-code-out-of-templates"><a href="#Item-44-Factor-parameter-independent-code-out-of-templates" class="headerlink" title="Item 44: Factor parameter-independent code out of templates"></a>Item 44: Factor parameter-independent code out of templates</h3><ul>
<li><p>模板可能会带来代码膨胀，源代码可能看起来很紧凑，但是目标代码会急剧膨胀</p>
</li>
<li><p>在没有模板的代码里，我们写代码也会遵从 commonality and variability analysis，在代码复用上不自觉地践行，在非模板代码里，代码重复是显性的，但是在模板代码里，代码重复是隐性的，因为它们来自于同一份源代码</p>
<blockquote>
<p>• Templates generate multiple classes and multiple functions, so any template code not dependent on a template parameter causes bloat.</p>
</blockquote>
<blockquote>
<p>• Bloat due to non-type template parameters can often be eliminated by replacing template parameters with function parameters or class data members.</p>
</blockquote>
<blockquote>
<p>• Bloat due to type parameters can be reduced by sharing implementations for instantiation types with identical binary representations.</p>
</blockquote>
</li>
</ul>
<h3 id="Item-45-Use-member-function-templates-to-accept-“all-compatible-types-”"><a href="#Item-45-Use-member-function-templates-to-accept-“all-compatible-types-”" class="headerlink" title="Item 45: Use member function templates to accept “all compatible types.”"></a>Item 45: Use member function templates to accept “all compatible types.”</h3><ul>
<li><p>generalized copy construction，我们可以从shared_ptr<Y>类型来构造shared_ptr<T>类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">class</span> <span class="title class_">shared_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">shared_ptr</span>(shared_ptr <span class="type">const</span>&amp; r);                 <span class="comment">// copy constructor</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Y</span>&gt;                                <span class="comment">// generalized</span></span><br><span class="line">    <span class="built_in">shared_ptr</span>(shared_ptr&lt;Y&gt; <span class="type">const</span>&amp; r);            <span class="comment">// copy constructor</span></span><br><span class="line"></span><br><span class="line">  shared_ptr&amp; <span class="keyword">operator</span>=(shared_ptr <span class="type">const</span>&amp; r);      <span class="comment">// copy assignment</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Y</span>&gt;                                <span class="comment">// generalized</span></span><br><span class="line">    shared_ptr&amp; <span class="keyword">operator</span>=(shared_ptr&lt;Y&gt; <span class="type">const</span>&amp; r); <span class="comment">// copy assignment</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果没有用这项技法，那么shared_ptr<Base> 与shared_ptr<Derived>完全是两个类，如果想通过一个构造另一个，得像下面这样</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPtr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:                             <span class="comment">// smart pointers are typically</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">SmartPtr</span><span class="params">(T *realPtr)</span></span>;    <span class="comment">// initialized by built-in pointers</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SmartPtr&lt;Top&gt; pt1 =                 <span class="comment">// convert SmartPtr&lt;Middle&gt; ⇒</span></span><br><span class="line">  <span class="built_in">SmartPtr</span>&lt;Middle&gt;(<span class="keyword">new</span> Middle);     <span class="comment">//   SmartPtr&lt;Top&gt;</span></span><br><span class="line"></span><br><span class="line">SmartPtr&lt;Top&gt; pt2 =                 <span class="comment">// convert SmartPtr&lt;Bottom&gt; ⇒</span></span><br><span class="line">  <span class="built_in">SmartPtr</span>&lt;Bottom&gt;(<span class="keyword">new</span> Bottom);     <span class="comment">//   SmartPtr&lt;Top&gt;</span></span><br><span class="line"></span><br><span class="line">SmartPtr&lt;<span class="type">const</span> Top&gt; pct2 = pt1;     <span class="comment">// convert SmartPtr&lt;Top&gt; ⇒</span></span><br><span class="line">                                    <span class="comment">//  SmartPtr&lt;const Top&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Item-46-Define-non-member-functions-inside-templates-when-type-conversions-are-desired"><a href="#Item-46-Define-non-member-functions-inside-templates-when-type-conversions-are-desired" class="headerlink" title="Item 46: Define non-member functions inside templates when type conversions are desired"></a>Item 46: Define non-member functions inside templates when type conversions are desired</h3><ul>
<li><p>与item24一致，只不过是在模板的基础上</p>
</li>
<li><p>When writing a class template that offers functions related to the template that support implicit type conversions on all parameters, define those functions as friends inside the class template.</p>
</li>
</ul>
<h3 id="Item-47-Use-traits-classes-for-information-about-types"><a href="#Item-47-Use-traits-classes-for-information-about-types" class="headerlink" title="Item 47: Use traits classes for information about types"></a>Item 47: Use traits classes for information about types</h3><ul>
<li><p>复习五种迭代器</p>
<ul>
<li><p>input iterator：只能向前移动，每次只能一步，只能向指向的地方读取，istream_iterator是个例子</p>
</li>
<li><p>ouptut iterator：只能向前移动，每次只能一步，只能向指向的地方写入，ostream_iterator是个例子</p>
</li>
<li><p>forward iterator：可以向指向的地方读取或者写入，是上两个的结合增强</p>
</li>
<li><p>bidrectional iterator：在forward iterator的基础上可以向后移动</p>
</li>
<li><p>random access iterator：可以向前向后跳跃移动，比如vector、deque、string的迭代器就属于这种</p>
</li>
<li><p>C++标准库中有tag struct来区分它们</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">input_iterator_tag</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">output_iterator_tag</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">forward_iterator_tag</span>: <span class="keyword">public</span> input_iterator_tag &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bidirectional_iterator_tag</span>: <span class="keyword">public</span> forward_iterator_tag &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">random_access_iterator_tag</span>: <span class="keyword">public</span> bidirectional_iterator_tag &#123;&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>advance是函数模板，用于把指定指针移动指定距离，签名如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;       <span class="comment">// move iter d units</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">(IterT&amp; iter, DistT d)</span></span>;            <span class="comment">// forward; if d &lt; 0,</span></span><br><span class="line">                                               <span class="comment">// move iter backward</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果要完全兼容五种迭代器，则advance的实现得逐步遍历（因为前四种不支持运算符operator+&#x3D;，这需要线性时间，一种优化方法是分辨当前的迭代器类型，再做判断，这正是萃取traits技术的用武之地</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">(IterT&amp; iter, DistT d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (iter is a random access iterator) &#123;</span><br><span class="line">     iter += d;                                      <span class="comment">// use iterator arithmetic</span></span><br><span class="line">  &#125;                                                  <span class="comment">// for random access iters</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (d &gt;= <span class="number">0</span>) &#123; <span class="keyword">while</span> (d--) ++iter; &#125;              <span class="comment">// use iterative calls to</span></span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="keyword">while</span> (d++) --iter; &#125;                     <span class="comment">// ++ or -- for other</span></span><br><span class="line">  &#125;                                                  <span class="comment">// iterator categories</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>萃取技术需要用到iterator_traits结构体</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT&gt;          <span class="comment">// template for information about</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>;           <span class="comment">// iterator types</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对于用户定义的迭代器，每个迭代器类型必须包含内嵌的typedef iterator_category，比如deque与list</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; ... &gt;                    <span class="comment">// template params elided</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">deque</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">iterator</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt; ... &gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">list</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">iterator</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</span><br><span class="line">    ...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>iterator_traits结构体中就包含了这个typedef</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the iterator_category for type IterT is whatever IterT says it is;</span></span><br><span class="line"><span class="comment">// see Item 42 for info on the use of &quot;typedef typename&quot;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span> &#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> IterT::iterator_category iterator_category;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于指针，iterator_traits使用了偏特化技术，指针行为类似random access iterator，所以</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT&gt;               <span class="comment">// partial template specialization</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;IterT*&gt;         <span class="comment">// for built-in pointer types</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>现在，我们可以总结traits类的设计实现：</p>
<ul>
<li>Identify some information about types you’d like to make available (e.g., for iterators, their iterator category).</li>
<li>Choose a name to identify that information (e.g., <code>iterator_category</code>).</li>
<li>Provide a template and set of specializations (e.g., <code>iterator_traits</code>) that contain the information for the types you want to support.</li>
</ul>
</li>
<li><p>现在，我们就可以重新定义advance模板函数了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">(IterT&amp; iter, DistT d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">typeid</span>(<span class="keyword">typename</span> std::iterator_traits&lt;IterT&gt;::iterator_category) ==</span><br><span class="line">     <span class="built_in">typeid</span>(std::random_access_iterator_tag))</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>但是，上面的代码还是有点问题，if语句在运行时才知道，我们真正需要的是在编译期有条件地构造类型，这正是函数重载的用武之地</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">(IterT&amp; iter, DistT d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">doAdvance</span>(                                              <span class="comment">// call the version</span></span><br><span class="line">    iter, d,                                              <span class="comment">// of doAdvance</span></span><br><span class="line">    <span class="keyword">typename</span>                                              <span class="comment">// that is</span></span><br><span class="line">      std::iterator_traits&lt;IterT&gt;::<span class="built_in">iterator_category</span>()    <span class="comment">// appropriate for</span></span><br><span class="line">  );                                                      <span class="comment">// iter&#x27;s iterator</span></span><br><span class="line">&#125;     </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;              <span class="comment">// use this impl for</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doAdvance</span><span class="params">(IterT&amp; iter, DistT d,                  <span class="comment">// random access</span></span></span></span><br><span class="line"><span class="params"><span class="function">               std::random_access_iterator_tag)</span>       <span class="comment">// iterators</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  iter += d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;              <span class="comment">// use this impl for</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doAdvance</span><span class="params">(IterT&amp; iter, DistT d,                  <span class="comment">// bidirectional</span></span></span></span><br><span class="line"><span class="params"><span class="function">               std::bidirectional_iterator_tag)</span>       <span class="comment">// iterators</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (d &gt;= <span class="number">0</span>) &#123; <span class="keyword">while</span> (d--) ++iter; &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123; <span class="keyword">while</span> (d++) --iter;         &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;              <span class="comment">// use this impl for</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doAdvance</span><span class="params">(IterT&amp; iter, DistT d,                  <span class="comment">// input iterators</span></span></span></span><br><span class="line"><span class="params"><span class="function">               std::input_iterator_tag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (d &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">     <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Negative distance&quot;</span>);    <span class="comment">// see below</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (d--) ++iter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Item-48-Be-aware-of-template-metaprogramming"><a href="#Item-48-Be-aware-of-template-metaprogramming" class="headerlink" title="Item 48: Be aware of template metaprogramming"></a>Item 48: Be aware of template metaprogramming</h3><ul>
<li>模板元编程是用C++写的程序，它的执行时机是<strong>C++的编译期</strong>，产出结果是模板实例化后的C++源代码</li>
<li>Template metaprogramming can shift work from runtime to compile-time, thus enabling earlier error detection and higher runtime performance.</li>
<li>TMP can be used to generate custom code based on combinations of policy choices, and it can also be used to avoid generating code inappropriate for particular types.</li>
</ul>
<h2 id="8-Customizing-new-and-delete"><a href="#8-Customizing-new-and-delete" class="headerlink" title="8. Customizing new and delete"></a>8. Customizing new and delete</h2><ul>
<li>C++不像Java有Garbage Collection（GC）机制，主要靠operator new 与opertor delete负责内存的申请与释放，还有个辅助角色：new-handler</li>
<li>多个对象用operator new[]与operator delete[]</li>
<li>STL容器的内存由allocator对象管理，而不是直接由new与delete管理</li>
</ul>
<h3 id="Item-49-Understand-the-behavior-of-the-new-handler"><a href="#Item-49-Understand-the-behavior-of-the-new-handler" class="headerlink" title="Item 49: Understand the behavior of the new-handler"></a>Item 49: Understand the behavior of the new-handler</h3><ul>
<li><p>当operator new无法满足内存申请，就会抛出异常，用户可以用std::set_new_handler来捕获</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*new_handler)</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">new_handler <span class="title">set_new_handler</span><span class="params">(new_handler p)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// function to call if operator new can&#x27;t allocate enough memory</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">outOfMem</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cerr &lt;&lt; <span class="string">&quot;Unable to satisfy request for memory\n&quot;</span>;</span><br><span class="line">  std::<span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::<span class="built_in">set_new_handler</span>(outOfMem);</span><br><span class="line">  <span class="type">int</span> *pBigDataArray = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">100000000L</span>];</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>new-handler的设计可以从以下建议中挑选一个：</p>
<ul>
<li>Make more memory available</li>
<li>Install a different new-handler</li>
<li>Deinstall the new-handler</li>
<li>Throw an exception</li>
<li>Not return, typically by calling <code>abort</code> or <code>exit</code>.</li>
</ul>
</li>
<li><p>可以为不同的类个性化定制new-handler</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> std::new_handler <span class="title">set_new_handler</span><span class="params">(std::new_handler p)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">static</span> std::new_handler currentHandler;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Static class members must be defined outside the class definition</span></span><br><span class="line">std::new_handler Widget::currentHandler = <span class="number">0</span>;    <span class="comment">// init to null in the class</span></span><br><span class="line">                                                <span class="comment">// impl. file</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意Widget类的set_new_handler函数，仅仅做传递，为啥要保存见下面第二点</span></span><br><span class="line"><span class="function">std::new_handler <span class="title">Widget::set_new_handler</span><span class="params">(std::new_handler p)</span> <span class="title">throw</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::new_handler oldHandler = currentHandler;</span><br><span class="line">  currentHandler = p;</span><br><span class="line">  <span class="keyword">return</span> oldHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>现在，<code>Widget</code>‘s <code>operator new</code>会做下面三件事<ol>
<li>Call the standard <code>set_new_handler</code> with <code>Widget</code>‘s error-handling function. This installs <code>Widget</code>‘s new-handler as the global new-handler.</li>
<li>Call the global <code>operator new</code> to perform the actual memory allocation. If allocation fails, the global <code>operator new</code> invokes <code>Widget</code>‘s new-handler. In that case, <code>Widget</code>‘s <code>operator new</code> must restore the original global new-handler, then propagate the exception.</li>
<li>If the global <code>operator new</code> was able to allocate enough memory for a <code>Widget</code> object, <code>Widget</code>‘s <code>operator new</code> returns a pointer to the allocated memory.</li>
</ol>
</li>
</ul>
</li>
<li><p>new-handler也是资源，根据RAII思想，应该用对象来管理它</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NewHandlerHolder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">NewHandlerHolder</span><span class="params">(std::new_handler nh)</span>    <span class="comment">// acquire current</span></span></span><br><span class="line"><span class="function">  :handler(nh) &#123;</span>&#125;                                   <span class="comment">// new-handler</span></span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">NewHandlerHolder</span>()                               <span class="comment">// release it</span></span><br><span class="line">  &#123; std::<span class="built_in">set_new_handler</span>(handler); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::new_handler handler;                         <span class="comment">// remember it</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">NewHandlerHolder</span>(<span class="type">const</span> NewHandlerHolder&amp;);        <span class="comment">// prevent copying</span></span><br><span class="line">  NewHandlerHolder&amp;                                 <span class="comment">// (see Item 14)</span></span><br><span class="line">   <span class="keyword">operator</span>=(<span class="type">const</span> NewHandlerHolder&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Widget类的operator new就很简单了</span></span><br><span class="line"><span class="function"><span class="type">void</span> * Widget::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  NewHandlerHolder                              <span class="comment">// install Widget&#x27;s</span></span><br><span class="line">   <span class="built_in">h</span>(std::<span class="built_in">set_new_handler</span>(currentHandler));     <span class="comment">// new-handler</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size);                  <span class="comment">// allocate memory</span></span><br><span class="line">                                                <span class="comment">// or throw</span></span><br><span class="line">  &#125;                                               <span class="comment">// restore global</span></span><br><span class="line">                                                <span class="comment">// new-handler</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>最后，用户使用的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">outOfMem</span><span class="params">()</span></span>;                   <span class="comment">// decl. of func. to call if mem. alloc.</span></span><br><span class="line">                                   <span class="comment">// for Widget objects fails</span></span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">set_new_handler</span>(outOfMem); <span class="comment">// set outOfMem as Widget&#x27;s</span></span><br><span class="line">                                   <span class="comment">// new-handling function</span></span><br><span class="line"></span><br><span class="line">Widget *pw1 = <span class="keyword">new</span> Widget;          <span class="comment">// if memory allocation</span></span><br><span class="line">                                   <span class="comment">// fails, call outOfMem</span></span><br><span class="line"></span><br><span class="line">std::string *ps = <span class="keyword">new</span> std::string; <span class="comment">// if memory allocation fails,</span></span><br><span class="line">                                   <span class="comment">// call the global new-handling</span></span><br><span class="line">                                   <span class="comment">// function (if there is one)</span></span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">set_new_handler</span>(<span class="number">0</span>);        <span class="comment">// set the Widget-specific</span></span><br><span class="line">                                   <span class="comment">// new-handling function to</span></span><br><span class="line">                                   <span class="comment">// nothing (i.e., null)</span></span><br><span class="line"></span><br><span class="line">Widget *pw2 = <span class="keyword">new</span> Widget;          <span class="comment">// if mem. alloc. fails, throw an</span></span><br><span class="line">                                   <span class="comment">// exception immediately. (There is</span></span><br><span class="line">                                   <span class="comment">// no new- handling function for</span></span><br><span class="line">                                   <span class="comment">// class Widget.)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Item-50-Understand-when-it-makes-sense-to-replace-new-and-delete"><a href="#Item-50-Understand-when-it-makes-sense-to-replace-new-and-delete" class="headerlink" title="Item 50: Understand when it makes sense to replace new and delete"></a>Item 50: Understand when it makes sense to replace <code>new</code> and <code>delete</code></h3><ul>
<li><p>有时程序员想自定义new与delete的逻辑，出于以下原因：</p>
<ul>
<li>检测用户错误：用户可能忘记调用delete，或者调用两次</li>
<li>改进效率：默认的new与delete是通用的，自定义的会更适合自己的程序，提升效率</li>
<li>收集用户数据</li>
<li>减少内存开销</li>
</ul>
</li>
<li><p>C++要求所有的opeartor new返回的指针对于任意类型是<strong>内存对齐</strong>的，下面代码中返回的是malloc offset by the size of an int，这很有可能会造成崩溃</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> signature = <span class="number">0xDEADBEEF</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> Byte;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this code has several flaws—see below</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> realSize = size + <span class="number">2</span> * <span class="built_in">sizeof</span>(<span class="type">int</span>);    <span class="comment">// increase size of request so2</span></span><br><span class="line">                                               <span class="comment">// signatures will also fit inside</span></span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *pMem = <span class="built_in">malloc</span>(realSize);               <span class="comment">// call malloc to get theactual</span></span><br><span class="line">  <span class="keyword">if</span> (!pMem) <span class="keyword">throw</span> <span class="built_in">bad_alloc</span>();                <span class="comment">// memory</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// write signature into first and last parts of the memory</span></span><br><span class="line">   *(<span class="built_in">static_cast</span>&lt;<span class="type">int</span>*&gt;(pMem)) = signature;</span><br><span class="line">  *(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>*&gt;(<span class="built_in">static_cast</span>&lt;Byte*&gt;(pMem)+realSize-<span class="built_in">sizeof</span>(<span class="type">int</span>))) =</span><br><span class="line">  signature;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// return a pointer to the memory just past the first signature</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Byte*&gt;(pMem) + <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Item-51-Adhere-to-convention-when-writing-new-and-delete"><a href="#Item-51-Adhere-to-convention-when-writing-new-and-delete" class="headerlink" title="Item 51: Adhere to convention when writing new and delete"></a>Item 51: Adhere to convention when writing <code>new</code> and <code>delete</code></h3><ul>
<li>Implementing a conformant <code>operator new</code> requires having the right return value, calling the new-handling function when insufficient memory is available (see <a href="javascript:void(0)">Item 49</a>), and being prepared to cope with requests for no memory</li>
<li>Return value of operator new:  If you can supply the requested memory, you return a pointer to it. If you can’t, you follow the rule described in <a href="javascript:void(0)">Item 49</a> and throw an exception of type <code>bad_alloc</code>.</li>
<li><code>operator new</code> should contain an infinite loop trying to allocate memory, should call the new-handler if it can’t satisfy a memory request, and should handle requests for zero bytes. Class-specific versions should handle requests for larger blocks than expected.</li>
<li><code>operator delete</code> should do nothing if passed a pointer that is null. Class-specific versions should handle blocks that are larger than expected.</li>
</ul>
<h3 id="Item-52-Write-placement-delete-if-you-write-placement-new"><a href="#Item-52-Write-placement-delete-if-you-write-placement-new" class="headerlink" title="Item 52: Write placement delete if you write placement new"></a>Item 52: Write placement <code>delete</code> if you write placement <code>new</code></h3><ul>
<li><p>new一个对象有两步，调用operator new函数申请内存，然后再调用类的构造函数构造对象，如果第二步失败，则第一步申请的内存必须释放，否则就会内存泄露，用户无法参与到这个内存泄露的处理中来，必须由C++运行时系统来管理，operator delete函数必须找到对应的operator new所申请的内存地址，它才能释放掉这块内存</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Widget *pw = <span class="keyword">new</span> Widget;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认的new与delete是配对的，C++运行时系统可以很轻松的找到对应的内存去释放</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span>)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *rawMemory)</span> <span class="title">throw</span><span class="params">()</span></span>;  <span class="comment">// normal signature</span></span><br><span class="line">                                                <span class="comment">// at global scope</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *rawMemory,           <span class="comment">// typical normal</span></span></span></span><br><span class="line"><span class="params"><span class="function">                     std::<span class="type">size_t</span> size)</span> <span class="title">throw</span><span class="params">()</span></span>; <span class="comment">// signature at class</span></span><br><span class="line">                                                <span class="comment">// scope</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>但假设用户自定义了operator new，在上述现象发生时，C++运行时系统找不到对应的内存去释放，会造成内存泄露，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span>, <span class="type">void</span> *pMemory)</span> <span class="title">throw</span><span class="params">()</span></span>;   <span class="comment">// &quot;placement</span></span><br><span class="line">                                                          <span class="comment">// new&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>C++标准库的placement new相比operator new有额外的入参，一个void *指针指向了对象在哪里被构建；但从广义上看，只要有额外的入参，都可以算作placement new的语义范畴</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span>, <span class="type">void</span> *pMemory)</span> <span class="title">throw</span><span class="params">()</span></span>;   <span class="comment">// &quot;placement</span></span><br><span class="line">                                                          <span class="comment">// new&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>只要用了placement new，就要用对应placement delete，否则就会有细微的、断断续续的内存泄露</p>
</li>
<li><p>使用placement new与placement delete时，要注意不要隐藏了普通版本的new与delete</p>
</li>
</ul>
<h2 id="9-Miscellany"><a href="#9-Miscellany" class="headerlink" title="9. Miscellany"></a>9. Miscellany</h2><h3 id="Item-53-Pay-attention-to-compiler-warnings"><a href="#Item-53-Pay-attention-to-compiler-warnings" class="headerlink" title="Item 53: Pay attention to compiler warnings"></a>Item 53: Pay attention to compiler warnings</h3><ul>
<li>Take compiler warnings seriously, and strive to compile warning-free at the maximum warning level supported by your compilers.</li>
<li>Don’t become dependent on compiler warnings, because different compilers warn about different things. Porting to a new compiler may eliminate warning messages you’ve come to rely on.</li>
</ul>
<h3 id="Item-54-Familiarize-yourself-with-the-standard-library-including-TR1"><a href="#Item-54-Familiarize-yourself-with-the-standard-library-including-TR1" class="headerlink" title="Item 54: Familiarize yourself with the standard library, including TR1"></a>Item 54: Familiarize yourself with the standard library, including TR1</h3><ul>
<li><p>C++98 includes:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">• The Standard Template Library (STL), including containers (vector, string, map, etc.); iterators; algorithms (find, sort, transform, etc.); function objects (less, greater, etc.); and various container and function object adapters (stack, priority_queue, mem_fun, not1, etc.).</span><br><span class="line">• Iostreams, including support for user-defined buffering, internationalized IO, and the predefined objects cin, cout, cerr, and clog.</span><br><span class="line">• Support for internationalization, including the ability to have multiple active locales. Types like wchar_t (usually 16 bits/char) and wstring (strings of wchar_ts) facilitate working with Unicode.</span><br><span class="line">• Support for numeric processing, including templates for complex numbers (complex) and arrays of pure values (valarray).</span><br><span class="line">• An exception hierarchy, including the base class exception, its derived classes logic_error and runtime_error, and various classes that inherit from those.</span><br><span class="line">• C89&#x27;s standard library. Everything in the 1989 C standard library is also in C++.</span><br></pre></td></tr></table></figure>
</li>
<li><p>TR1 (“Technical Report 1” from the C++ Library Working Group)</p>
<ul>
<li><p>shared_ptr与weak_ptr，shared_ptr有引用计数机制，当最后一个指向对象的指针销毁时，对象所占用的内存自动释放，shared_ptr可以处理无环的数据结构，但无法处理有环的数据结构，因为会出现循环引用的问题，这时weak_ptr就派上用场了，weak_ptr不参与引用计数</p>
</li>
<li><p>tr1::function：可以代表任何可调用的实体（如函数或函数对象），比如下面代码可接受任何可调用的实体，只要以std::string作为函数返回值，int作为参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">registerCallback</span><span class="params">(std::tr1::function&lt;std::string (<span class="type">int</span>)&gt; func)</span></span>;</span><br><span class="line">                                                 <span class="comment">// the param &quot;func&quot; will</span></span><br><span class="line">                                                 <span class="comment">// take any callable entity</span></span><br><span class="line">                                                 <span class="comment">// with a sig consistent</span></span><br><span class="line">                                                 <span class="comment">// with &quot;std::string (int)&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>tr1::bind：完全包含了STL的bind1st与bind2nd的功能</p>
</li>
<li><p>Hash Tables: <code>tr1::unordered_set</code>, <code>tr1::unordered_multiset</code>, <code>tr1::unordered_map</code>, and <code>tr1::unordered_multimap</code>.</p>
</li>
<li><p>Regular expressions</p>
</li>
<li><p>Tuples：比pair更强大，支持任意数量</p>
</li>
<li><p>tr1::array：STL版本的数组，支持begin、end成员函数，在编译期tr1::array的长度就固定了</p>
</li>
<li><p>Trype Trais</p>
</li>
<li><p>tr1::result_of</p>
</li>
<li><p>and so on</p>
</li>
</ul>
</li>
<li><p>TR1本身是个标准，需要一个具体的实现，Boost就是个很不错的库</p>
</li>
</ul>
<h3 id="Item-55-Familiarize-yourself-with-Boost"><a href="#Item-55-Familiarize-yourself-with-Boost" class="headerlink" title="Item 55: Familiarize yourself with Boost."></a>Item 55: Familiarize yourself with Boost.</h3><ul>
<li>Boost库非常好，与C++标准联系紧密</li>
</ul>
<h1 id="More-Effective-C"><a href="#More-Effective-C" class="headerlink" title="More Effective C++"></a>More Effective C++</h1><h2 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h2><p>This chapter describes the differences between pointers and references</p>
<h3 id="Item-1-Distinguish-between-pointers-and-references"><a href="#Item-1-Distinguish-between-pointers-and-references" class="headerlink" title="Item 1:  Distinguish between pointers and references."></a>Item 1:  Distinguish between pointers and references.</h3><ul>
<li>引用必须初始化，不能为空；而指针可以</li>
<li>当你需知道你所指向的东西肯定不为空时，可以用引用</li>
<li>operator[]返回的是引用，这样就可以直接写：v[5]&#x3D;10，如果operator[]返回的是指针，你需要这样写：*v[5]&#x3D;10</li>
</ul>
<h3 id="Item-2-Prefer-C-style-casts"><a href="#Item-2-Prefer-C-style-casts" class="headerlink" title="**Item 2:**Prefer C++-style casts."></a>**Item 2:**Prefer C++-style casts.</h3><ul>
<li>C的转换，C++的static_cast都能做</li>
<li>const_cast是用来把常量性转换丢弃的，即把常量转换为非常量</li>
<li>dynamic_cast是在继承体系中安全地向下转换，即把指向基类的指针或引用转换为指向派生类的，注意不能用于非虚函数，也不能去除常量性</li>
<li>reinterpret_cast</li>
</ul>
<h3 id="Item-3-Never-treat-arrays-polymorphically"><a href="#Item-3-Never-treat-arrays-polymorphically" class="headerlink" title="**Item 3:**Never treat arrays polymorphically."></a>**Item 3:**<strong>Never treat arrays polymorphically.</strong></h3><ul>
<li>C风格的数组，不支持C++的多态，因为array[i]其实是*(array+i)，而<code>i*sizeof(an object in the array)</code>是声明数组时的类型，无法保证多态性</li>
</ul>
<h3 id="Item-4-Avoid-gratuitous-default-constructors"><a href="#Item-4-Avoid-gratuitous-default-constructors" class="headerlink" title="Item 4: Avoid gratuitous default constructors."></a>Item 4: Avoid gratuitous default constructors.</h3><ul>
<li>很多时候，默认的构造函数无法满足的我们对构造函数的要求</li>
</ul>
<h2 id="Operators"><a href="#Operators" class="headerlink" title="Operators"></a>Operators</h2><p>重载运算符很酷，但是有些坑需要注意，这个部分就是讲解什么时候、怎么做运算符重载</p>
<h3 id="Item-5-Be-wary-of-user-defined-conversion-functions"><a href="#Item-5-Be-wary-of-user-defined-conversion-functions" class="headerlink" title="Item 5: Be wary of user-defined conversion functions."></a>Item 5: Be wary of user-defined conversion functions.</h3><ul>
<li>有经验的程序员会尽量避免隐式转换，比如STL的string就没有从string到char*的隐式转换，但是有显式的c_str成员函数</li>
<li>使用explicitly关键字修饰构造函数，这样就可以避免隐式转换</li>
</ul>
<h3 id="Item-6-Distinguish-between-prefix-and-postfix-forms-of-increment-and-decrement-operators"><a href="#Item-6-Distinguish-between-prefix-and-postfix-forms-of-increment-and-decrement-operators" class="headerlink" title="Item 6: Distinguish between prefix and postfix forms of increment and decrement operators."></a>Item 6: Distinguish between prefix and postfix forms of increment and decrement operators.</h3><ul>
<li><p>前缀++比后缀++性能更好，因为后缀++需要构造临时值再销毁它</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// prefix form: increment and fetch</span></span><br><span class="line">UPInt&amp; UPInt::<span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">  *<span class="keyword">this</span> += <span class="number">1</span>; <span class="comment">// increment</span></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// fetch</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// postfix form: fetch and increment</span></span><br><span class="line"><span class="type">const</span> UPInt UPInt::<span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> UPInt oldValue = *<span class="keyword">this</span>; <span class="comment">// fetch</span></span><br><span class="line">  ++(*<span class="keyword">this</span>); <span class="comment">// increment</span></span><br><span class="line">  <span class="keyword">return</span> oldValue; <span class="comment">// return what was fetched</span></span><br><span class="line">&#125; <span class="comment">// </span></span><br></pre></td></tr></table></figure>
</li>
<li><p>因为后缀++返回的是const，所以不能连续两次后缀++</p>
</li>
</ul>
<h3 id="Item-7-Never-overload-amp-amp-or"><a href="#Item-7-Never-overload-amp-amp-or" class="headerlink" title="Item 7: Never overload &amp;&amp;, ||, or ,."></a>Item 7: Never overload &amp;&amp;, ||, or ,.</h3><ul>
<li>c++表达式按照短路规则来计算，如果重载了&amp;&amp;或者||这些运算符，那就由短路语义变为函数语义，这就没有短路的用法了</li>
</ul>
<h3 id="Item-8-Understand-the-different-meanings-of-new-and-delete"><a href="#Item-8-Understand-the-different-meanings-of-new-and-delete" class="headerlink" title="Item 8: Understand the different meanings of new and delete."></a>Item 8: Understand the different meanings of new and delete.</h3><ul>
<li><p><code>string *ps = new string(&quot;Memory Management&quot;);</code>这里调用的是new operator，这是内置的，无法改变，就像sizeof一样，先分配内存，再在这块内存上调用构造函数</p>
</li>
<li><p>new operator无法重载，但是我们可以改变它分配内存的机制，即operator new，它一般声明：<code>void * operator new(size_t size);</code>，于是像下面这样用起来：<code>void *rawMemory = operator new(sizeof(string));</code>，operator new完全不知道构造函数，所以还需要：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string *ps = <span class="built_in">static_cast</span>&lt;string*&gt;(memory); <span class="comment">// make ps point to the new object</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>placement new 是operator new的特例，可以在指定内存位置上构造对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget * <span class="title">constructWidgetInBuffer</span><span class="params">(<span class="type">void</span> *buffer,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> widgetSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">new</span> (buffer) <span class="built_in">Widget</span>(widgetSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span>, <span class="type">void</span> *location)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> location;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>三者差别</p>
<ul>
<li><p>you want to create an object on the heap, use the new operator. It both allocates memory and calls a constructor for the object. </p>
</li>
<li><p>If you only want to allocate memory, call operator new; no constructor will be called. </p>
</li>
<li><p>If you want to customize the memory allocation that takes place when heap objects are created, write your own version of operator new and use the new operator; it will automatically invoke your custom version of operator new. </p>
</li>
<li><p>If you want to construct an object in memory you’ve already got a pointer to, use placement new.</p>
</li>
</ul>
</li>
<li><p>为了防止内存泄露，需要调用delete关键字，它先调用析构函数，然后调用operator delete函数回收内存</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">string *ps = <span class="keyword">new</span> string[<span class="number">10</span>];</span><br><span class="line"><span class="comment">// call operator new[] to allocate</span></span><br><span class="line"> <span class="comment">// memory for 10 string objects,</span></span><br><span class="line"><span class="comment">// then call the default string</span></span><br><span class="line"><span class="comment">// ctor for each array element</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> [] ps; <span class="comment">// call the string dtor for each</span></span><br><span class="line"><span class="comment">// array element, then call</span></span><br><span class="line"><span class="comment">// operator delete[] to</span></span><br><span class="line"><span class="comment">// deallocate the array’s memory</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Exceptions"><a href="#Exceptions" class="headerlink" title="Exceptions"></a>Exceptions</h2><p>C语言习惯了用状态码、返回值来返回异常信息，为什么还需要用异常？</p>
<p>因为异常可以强迫使用者检查异常，从而不会造成持久的错误</p>
<h3 id="Item-9-Use-destructors-to-prevent-resource-leaks"><a href="#Item-9-Use-destructors-to-prevent-resource-leaks" class="headerlink" title="Item 9: Use destructors to prevent resource leaks."></a>Item 9: Use destructors to prevent resource leaks.</h3><ul>
<li><p>用原生指针，可能会发生下面这种情况</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">processAdoptions</span><span class="params">(istream&amp; dataSource)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (dataSource) &#123; <span class="comment">// while there’s data</span></span><br><span class="line">    ALA *pa = <span class="built_in">readALA</span>(dataSource); <span class="comment">// get next animal</span></span><br><span class="line">    pa-&gt;<span class="built_in">processAdoption</span>(); <span class="comment">// process adoption</span></span><br><span class="line">    <span class="keyword">delete</span> pa; <span class="comment">// delete object that</span></span><br><span class="line">  &#125; <span class="comment">// readALA returned</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果pa-&gt;processAdoption抛异常，那么pa就永远无法delete，所以要try-catch</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processAdoptions</span><span class="params">(istream&amp; dataSource)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (dataSource) &#123;</span><br><span class="line">    ALA *pa = <span class="built_in">readALA</span>(dataSource);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">	    pa-&gt;<span class="built_in">processAdoption</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">      <span class="comment">// catch all exceptions</span></span><br><span class="line">      <span class="keyword">delete</span> pa; <span class="comment">// avoid resource leak when an</span></span><br><span class="line">      <span class="comment">// exception is thrown</span></span><br><span class="line">      <span class="keyword">throw</span>; <span class="comment">// propagate exception to caller</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">delete</span> pa; <span class="comment">// avoid resource leak when no</span></span><br><span class="line">  &#125; <span class="comment">// exception is thrown</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用智能指针可以避免每次都要把delete pa放入catch语句里（原文是auto_ptr，但现在使用shared_ptr更好</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">processAdoptions</span><span class="params">(istream&amp; dataSource)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (dataSource) &#123;</span><br><span class="line">    <span class="function">auto_ptr&lt;ALA&gt; <span class="title">pa</span><span class="params">(readALA(dataSource))</span></span>;</span><br><span class="line">    pa-&gt;<span class="built_in">processAdoption</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Item-10-Prevent-resource-leaks-in-constructors"><a href="#Item-10-Prevent-resource-leaks-in-constructors" class="headerlink" title="Item 10: Prevent resource leaks in constructors."></a>Item 10: Prevent resource leaks in constructors.</h3><ul>
<li><p>C++ destroys only <em>fully constructed</em> objects</p>
</li>
<li><p>只有当new operator成功时，返回的指针才不是空指针</p>
</li>
<li><p>为了防止在构造函数中出现异常而产生的内存泄露，构造函数需要用try-catch包围</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">BookEntry::<span class="built_in">BookEntry</span>(<span class="type">const</span> string&amp; name, <span class="type">const</span> string&amp; address, <span class="type">const</span> string&amp; imageFileName, <span class="type">const</span> string&amp; audioClipFileName) : <span class="built_in">theName</span>(name), <span class="built_in">theAddress</span>(address), <span class="built_in">theImage</span>(<span class="number">0</span>), <span class="built_in">theAudioClip</span>(<span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123; </span><br><span class="line">    <span class="keyword">if</span> (imageFileName != <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">    	theImage = <span class="keyword">new</span> <span class="built_in">Image</span>(imageFileName); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (audioClipFileName != <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">	    theAudioClip = <span class="keyword">new</span> <span class="built_in">AudioClip</span>(audioClipFileName);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">    <span class="keyword">delete</span> theImage; </span><br><span class="line">    <span class="keyword">delete</span> theAudioClip;</span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>最好的解决方法还是智能指针</p>
</li>
</ul>
<h3 id="Item-11-Prevent-exceptions-from-leaving-destructors"><a href="#Item-11-Prevent-exceptions-from-leaving-destructors" class="headerlink" title="Item 11: Prevent exceptions from leaving destructors."></a>Item 11: Prevent exceptions from leaving destructors.</h3><ul>
<li>析构函数的异常不应被传播出析构函数的范围，也就是说，得在析构函数内try-catch起来</li>
</ul>
<h3 id="Item-12-Understand-how-throwing-an-exception-differs-from-passing-a-parameter-or-calling-a-virtual-function"><a href="#Item-12-Understand-how-throwing-an-exception-differs-from-passing-a-parameter-or-calling-a-virtual-function" class="headerlink" title="Item 12: Understand how throwing an exception differs from passing a parameter or calling a virtual function."></a>Item 12: Understand how throwing an exception differs from passing a parameter or calling a virtual function.</h3><ul>
<li><p>你可以传递函数参数与异常by value、by reference、or by pointer，但是它们的区别很大</p>
</li>
<li><p>传递异常，比如<code>throw xxlocalsobject</code>语句，是通过拷贝来传递，为啥不是引用？因为xxlocalobject离开了作用域，localobject会被析构，这样传给外层的xxlocalsobject就是析构后的对象，所以throw抛出的肯定是拷贝过的对象</p>
</li>
<li><p>下面两种抛异常的方式还是有区别的，除了第二种需要拷贝的开销之外，第一种原封不动的抛出异常，即使w是Widget的派生类对象，第二种只会拷贝w的Widget类部分，如果w是Widget派生类对象，则拷贝只会拷贝基类的部分（这也是object slicing）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">catch</span> (Widget&amp; w) &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">throw</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (Widget&amp; w) &#123;</span><br><span class="line">	...</span><br><span class="line">  <span class="keyword">throw</span> w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>catch也有三种方法，catch by value（在catch时执行一次拷贝），catch by reference，catch by pointer，如果throw也是用的拷贝，则catch by value 会有两次额外的拷贝</p>
</li>
<li><p>A catch clause for <code>runtime_errors</code> can catch exceptions of type range_error, underflow_error, and overflow_error, too, and a catch clause accepting an object of the root class <code>exception</code> can catch any kind of exception derived from this hierarchy.</p>
</li>
<li><p>never put a catch clause for a base class before a catch clause for a derived class.否则派生类的catch永远也不会执行到</p>
</li>
</ul>
<h3 id="Item-13-Catch-exceptions-by-reference"><a href="#Item-13-Catch-exceptions-by-reference" class="headerlink" title="Item 13: Catch exceptions by reference."></a>Item 13: Catch exceptions by reference.</h3><ul>
<li><p>如果catch by pointer，</p>
<ul>
<li>如果exception是local variable，catch的就是null pointer</li>
<li>如果exception是通过new操作符建立在堆上，则必须delete，但是编写catch的人不知道是否建立在堆上，如果不是建立在堆上的pointer，delete 会有undefined behavior</li>
</ul>
</li>
<li><p>如果catch by value，</p>
<ul>
<li>会有拷贝的开销</li>
<li>会有派生类slicing的问题</li>
</ul>
</li>
<li><p>最好的做法：catch by reference！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunction</span><span class="params">()</span> <span class="comment">// nothing changes in this</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">  <span class="keyword">if</span> (a validation test fails) &#123; </span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">Validation_error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123; </span><br><span class="line">    <span class="built_in">someFunction</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span> (exception&amp; ex) &#123;</span><br><span class="line">	  cerr &lt;&lt; ex.<span class="built_in">what</span>(); ...</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Item-14-Use-exception-specifications-judiciously"><a href="#Item-14-Use-exception-specifications-judiciously" class="headerlink" title="Item 14: Use exception specifications judiciously."></a>Item 14: Use exception specifications judiciously.</h3><ul>
<li>The default be- havior for unexpected is to call terminate, and the default behavior for terminate is to call abort, so the default behavior for a program with a violated exception specification is to halt.</li>
</ul>
<h3 id="Item-15-Understand-the-costs-of-exception-handling"><a href="#Item-15-Understand-the-costs-of-exception-handling" class="headerlink" title="Item 15: Understand the costs of exception handling."></a>Item 15: Understand the costs of exception handling.</h3><ul>
<li>即使你没用try-throw-catch，异常处理也是有开销的，一定的空间用来记录哪些对象是fully constructed的，一定的时间来让它们保持更新，不支持异常的编译要比有异常的编译要快很多（当然，异常是C++的一个特性，肯定要支持）</li>
<li>try语句块也是有开销的，不同厂商编译器的实现不一样，大概估算一下，仅仅是使用try语句块的代码，其代码大小与运行时开销相比没有try的代码增长5~10%，所以<strong>尽量减少不必要的try</strong></li>
<li>有异常的开销更大，虽然异常不常见，但是抛异常会比普通代码运行慢三个数量级，所以在可能的情况下要尽量减少抛出异常</li>
<li>这些数据都是有benchmark支撑的</li>
</ul>
<h2 id="Efficiency"><a href="#Efficiency" class="headerlink" title="Efficiency"></a>Efficiency</h2><p>If you want to write an efficient C++ program, you must first be able to write an efficient <em>program</em>.</p>
<h3 id="Item-16-Remember-the-80-20-rule"><a href="#Item-16-Remember-the-80-20-rule" class="headerlink" title="Item 16: Remember the 80-20 rule."></a>Item 16: Remember the 80-20 rule.</h3><ul>
<li>80%的程序资源被20%的代码使用；80%的运行时间被20%的代码占据；</li>
<li>使用profiler来采样程序的性能，观察到底是哪部分代码运行时间最久，占据资源最多</li>
</ul>
<h3 id="Item-17-Consider-using-lazy-evaluation"><a href="#Item-17-Consider-using-lazy-evaluation" class="headerlink" title="Item 17: Consider using lazy evaluation."></a>Item 17: Consider using lazy evaluation.</h3><ul>
<li>lazy evaluation的例子：引用计数、lazy fetching等</li>
<li>在C++中，mutable也是为了突破const的限制而设置的，被mutable修饰的变量将永远处于可变的状态。<ul>
<li>mutable的作用有两点： （1）保持常量对象中大部分数据成员仍然是“只读”的情况下，实现对个别数据成员的修改； （2）使类的const函数可以修改对象的mutable数据成员。</li>
<li>注意事项： （1）mutable只能作用于类的非静态和非常量数据成员。 （2）在一个类中，应尽量或者不用mutable，大量使用mutable表示程序设计存在缺陷。</li>
</ul>
</li>
<li>lazy evaluation的例子：Lazy Expression Evaluation，比如矩形m3本来用作存放m1+m3的和，但后来要被用作存放m1*m3的积，lazy evaluation就不会执行加法操作</li>
<li>c++实现单例模式也有懒汉式</li>
</ul>
<h3 id="Item-18-Amortize-the-cost-of-expected-computations"><a href="#Item-18-Amortize-the-cost-of-expected-computations" class="headerlink" title="Item 18: Amortize the cost of expected computations."></a>Item 18: Amortize the cost of expected computations.</h3><ul>
<li><em>over-eager evaluation</em>：doing things <em>before</em> you’re asked to do them.</li>
<li>如果一个请求要被多次调用，可以用某种数据结构当做cache，在第一次就把结果记录下来，省的以后调用时要反复计算</li>
<li>磁盘的prefetching会一次性读一整块数据，根据经验，一次读请求到达磁盘，很有可能周围的数据接下来会被读到，这就是locality of reference现象</li>
<li>很多编程语言内置的动态数组可以自动扩容，以两倍扩容可以有效减少扩容次数，这也是over-eager evaluation的思想</li>
</ul>
<h3 id="Item-19-Understand-the-origin-of-temporary-objects"><a href="#Item-19-Understand-the-origin-of-temporary-objects" class="headerlink" title="Item 19: Understand the origin of temporary objects."></a>Item 19: Understand the origin of temporary objects.</h3><ul>
<li>temp变量在c++代码中应该是看不到的，比如传入函数参数的隐式转换与函数返回值的无名变量，有必要搞清楚它们的起源，否则构造与析构的开销不容忽视</li>
<li>函数参数的隐式转换：比如一个函数接受const string&amp;参数，但是传入的是<code>char*</code>，这时C++编译器就会构造一个临时的string对象，它以传入的<code>char*</code>作为构造参数，在函数结束时，该临时string对象也随即析构</li>
<li>这种隐式转换在pass-by-value与pass-by-const-reference时合法的，但是对于pass-by-reference是不合法的，因为我们可能需要改变原来的对象，但可惜只能改变中间的临时变量，这与我们预期不一致</li>
<li>函数返回值：除了隐式转换，还有一种temp变量不容忽视，那就是函数返回值，有两种方法可以避免，第一种是换方法，比如<code>operator+</code>换成<code>operator+=</code>，第二种是是哦那个返回值优化（Return Value Optimization, RVO）</li>
</ul>
<h3 id="Item-20-Facilitate-the-return-value-optimization"><a href="#Item-20-Facilitate-the-return-value-optimization" class="headerlink" title="Item 20: Facilitate the return value optimization."></a>Item 20: Facilitate the return value optimization.</h3><ul>
<li><p>函数返回值是不可避免的，要想办法避免中间临时变量</p>
</li>
<li><p>一个可行的做法是，返回构造函数参数，而不是对象本身</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// an efficient and correct way to implement a // function that returns an object</span></span><br><span class="line"><span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs,</span><br><span class="line"><span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Rational</span>(lhs.<span class="built_in">numerator</span>() * rhs.<span class="built_in">numerator</span>(),</span><br><span class="line">  lhs.<span class="built_in">denominator</span>() * rhs.<span class="built_in">denominator</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>但这样还是需要构造与析构，但是c++编译器可以进行返回值优化，像下面样，只需要付出构造c的开销即可，<code>operator*</code>中没有局部变量的构造与析构，也没有返回时临时变量的构造与析构，非常完美</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Rational a = <span class="number">10</span>; </span><br><span class="line"><span class="function">Rational <span class="title">b</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">Rational c = a * b;</span><br></pre></td></tr></table></figure>
</li>
<li><p>更进一步，如果你想消除函数开销，可以使用inline关键字</p>
</li>
</ul>
<h3 id="Item-21-Overload-to-avoid-implicit-type-conversions"><a href="#Item-21-Overload-to-avoid-implicit-type-conversions" class="headerlink" title="Item 21: Overload to avoid implicit type conversions."></a>Item 21: Overload to avoid implicit type conversions.</h3><ul>
<li><p>假设有一个类是UPInt，有两个构造函数，一个不需要参数，一个接受int参数，还重载了<code>operator+</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UPInt</span> &#123; </span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">UPInt</span>(); </span><br><span class="line">  	<span class="built_in">UPInt</span>(<span class="type">int</span> value); ...</span><br><span class="line">    <span class="type">const</span> UPInt <span class="keyword">operator</span>+(<span class="type">const</span> UPInt&amp; lhs, <span class="type">const</span> UPInt&amp; rhs);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>两个UPInt进行+操作很容易理解，但是如果是一个int和一个UPInt进行+呢？同样可以成功，但是执行了从int到UPInt的隐式转换，调用了有参的构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">upi3 = upi1 + <span class="number">10</span>;</span><br><span class="line">upi3 = <span class="number">10</span> + upi2;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为了避免这个开销，可以继续重载<code>operator+</code>，显式接收参数int与UPInt，以及参数UPInt与int</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> UPInt <span class="keyword">operator</span>+(<span class="type">const</span> UPInt&amp; lhs, <span class="type">int</span> rhs);<span class="comment">// add UPInt // and int</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> UPInt <span class="keyword">operator</span>+(<span class="type">int</span> lhs,</span><br><span class="line"><span class="type">const</span> UPInt&amp; rhs);<span class="comment">// add int and // UPInt</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Item-22-Consider-using-op-x3D-instead-of-stand-alone-op"><a href="#Item-22-Consider-using-op-x3D-instead-of-stand-alone-op" class="headerlink" title="Item 22: Consider using op&#x3D; instead of stand-alone op."></a>Item 22: Consider using <em>op&#x3D;</em> instead of stand-alone <em>op</em>.</h3><ul>
<li><p>对于用户定义的类，<code>operator+=</code>与<code>operator+</code>没有任何关系，除非是用<code>operator+=</code>来实现的<code>operator+</code>，这样只需要维护一个实现就行了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Rational <span class="keyword">operator</span>+(<span class="type">const</span> Rational&amp; lhs,</span><br><span class="line"><span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Rational</span>(lhs) += rhs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>从效率的角度出发，赋值版本的效率更高，因为stand-alone版本返回一个新对象，需要构造和析构</p>
</li>
<li><p>如果你同时提供两个版本，用户会陷入抉择，作为库设计者，你应该两者都提供给，对于应用开发者，你应该考虑只使用赋值版本的，出于性能考虑</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stand-alone版本，符合编程习惯，但需要三个临时变量，每个调用operator+</span></span><br><span class="line">Rational a, b, c, d, result; ...</span><br><span class="line">result=a+b+c+d;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值版本，没有临时变量生成，效率最高，但不易阅读和debug </span></span><br><span class="line">result = a; result += b; result += c; result += d;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Item-23-Consider-alternative-libraries"><a href="#Item-23-Consider-alternative-libraries" class="headerlink" title="Item 23: Consider alternative libraries."></a>Item 23: Consider alternative libraries.</h3><ul>
<li>The ideal library is small, fast, powerful, flexible, extensible, intuitive, universally available, well supported, free of use restrictions, and bug-free. It is also nonexistent.</li>
<li>库设计者一般会权衡得与失，比如尽量把库做的小而快，但可能会与平台有关</li>
<li>如果你对性能要求苛刻，可以考虑换一个追求性能的库</li>
</ul>
<h3 id="Item-24-Understand-the-costs-of-virtual-functions-multiple-inheritance-virtual-base-classes-and-RTTI"><a href="#Item-24-Understand-the-costs-of-virtual-functions-multiple-inheritance-virtual-base-classes-and-RTTI" class="headerlink" title="Item 24: Understand the costs of virtual functions, multiple inheritance, virtual base classes, and RTTI."></a>Item 24: Understand the costs of virtual functions, multiple inheritance, virtual base classes, and RTTI.</h3><h4 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h4><ul>
<li><p>虚函数被调用时，要执行的代码必须与对象的动态类型相符，大多数编译器都是用虚函数表vtabls与虚函数表指针vptrs来实现虚函数的</p>
</li>
<li><p>虚表通常是一个指向函数的指针数组，有些编译器使用的是链表而不是数组，每个有虚函数的类都有自己的虚表，虚表中的每一项都指向了虚函数的具体实现 </p>
<ul>
<li>虚表的大小与虚函数数量有关</li>
<li>每个类都有唯一的虚表</li>
</ul>
</li>
<li><p>虚表存放于哪？有两种阵营</p>
<ul>
<li>提供编译器与链接器的厂商，把虚表存放于需要的每个目标文件，链接器丢弃重复的拷贝，保证最终的可执行文件或库只有一份虚表</li>
<li>更通常的做法，启发式决定虚表存放于哪个目标文件，一般存放于这种目标文件中，这种目标文件包含类的第一个非inline非纯虚函数的定义</li>
</ul>
</li>
<li><p>有虚表了，虚表指针也是有很大开销的，每个对象都要有虚表指针，如果对象的成员变量只占据四字节，那么虚表指针的额外空间开销（假设指针是四字节）会使大小翻倍</p>
</li>
<li><p>虚函数的执行可以这样翻译（假设i是f1函数在虚表中的偏移量），仅仅比普通的函数多了个几个指令而已</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pC1-&gt;<span class="built_in">f1</span>();</span><br><span class="line"></span><br><span class="line">(*pC1-&gt;vptr[i])(pC1);</span><br></pre></td></tr></table></figure>
</li>
<li><p>虚函数就意味着放弃了内联，因为内联是在编译器完成的，而虚函数是在运行时去决定哪个函数被调用</p>
</li>
</ul>
<h4 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h4><ul>
<li>多重继承意味着每个对象有多个虚表指针，这样每个对象的空间大小会增长</li>
<li>菱形继承问题，因为派生类的虚表得知道祖先的虚函数，所以菱形继承下会有重复的虚表指针</li>
</ul>
<h4 id="RTTI（Runtime-Type-Identification"><a href="#RTTI（Runtime-Type-Identification" class="headerlink" title="RTTI（Runtime Type Identification)"></a>RTTI（Runtime Type Identification)</h4><ul>
<li>RTTI机制允许我们查看运行时对象的类型，每个类对象都有type_info对象来指示当前类对象的类型信息，我们可以用typeid操作符查询</li>
<li>每个类都只需要一份RTTI信息的拷贝，但是每个类对象都要能获取它，所以RTTI一般用虚表来实现，虚表的最上方就是类的type_info对象，接下来才是指向虚函数的指针</li>
</ul>
<h2 id="Techniques"><a href="#Techniques" class="headerlink" title="Techniques"></a>Techniques</h2><p>   本章的techniques，也可以说是idioms，或者是patterns</p>
<h3 id="Item-25-Virtualizing-constructors-and-non-member-functions"><a href="#Item-25-Virtualizing-constructors-and-non-member-functions" class="headerlink" title="Item 25: Virtualizing constructors and non-member functions."></a>Item 25: Virtualizing constructors and non-member functions.</h3><ul>
<li><p>虚拷贝构造函数，一般名为copySelft、clone等，像下面的clone函数一样，注意派生类覆写的clone函数，其返回值可以是指向派生类对象的指针，因为基类函数的返回值就是指向基类函数的指针，这是允许的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NLComponent</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// declaration of virtual copy constructor</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> NLComponent * <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextBlock</span>: <span class="keyword">public</span> NLComponent &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> TextBlock * <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> <span class="comment">// virtual copy</span></span></span><br><span class="line"><span class="function">  </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TextBlock</span>(*<span class="keyword">this</span>); &#125; <span class="comment">// constructor</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graphic</span>: <span class="keyword">public</span> NLComponent &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Graphic * <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> <span class="comment">// virtual copy</span></span></span><br><span class="line"><span class="function">  </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Graphic</span>(*<span class="keyword">this</span>); &#125; <span class="comment">// constructor</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>有了虚拷贝构造函数，就可以实现普通的拷贝构造函数了，因为NewsLetter的component既有text又有graghic，所以拷贝构造时得分别调用它们的拷贝构造函数，这就是通过虚拷贝构造实现的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">NewsLetter::<span class="built_in">NewsLetter</span>(<span class="type">const</span> NewsLetter&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// iterate over rhs’s list, using each element’s</span></span><br><span class="line">  <span class="comment">// virtual copy constructor to copy the element into</span></span><br><span class="line">  <span class="comment">// the components list for this object. For details on</span></span><br><span class="line">  <span class="comment">// how the following code works, see Item 35.</span></span><br><span class="line">  <span class="keyword">for</span> (list&lt;NLComponent*&gt;::const_iterator it =</span><br><span class="line">      rhs.components.<span class="built_in">begin</span>();</span><br><span class="line">      it != rhs.components.<span class="built_in">end</span>();</span><br><span class="line">      ++it) &#123;</span><br><span class="line">    <span class="comment">// &quot;it&quot; points to the current element of rhs.components,</span></span><br><span class="line">    <span class="comment">// so call that element’s clone function to get a copy</span></span><br><span class="line">    <span class="comment">// of the element, and add that copy to the end of</span></span><br><span class="line">    <span class="comment">// this object’s list of components</span></span><br><span class="line">    components.<span class="built_in">push_back</span>((*it)-&gt;<span class="built_in">clone</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>有时需要把非成员函数赋予虚函数的特性：根据参数的动态类型来执行逻辑，但如果简单地将其变为成员函数，不一定优雅，比如成员函数版的<code>operator&lt;&lt;</code>如下，使用者必须把对象写在cout的左边，非常别扭</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NLComponent</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// unconventional declaration of output operator</span></span><br><span class="line">  <span class="keyword">virtual</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; str) <span class="type">const</span> = <span class="number">0</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextBlock</span>: <span class="keyword">public</span> NLComponent &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// virtual output operator (also unconventional)</span></span><br><span class="line">  <span class="keyword">virtual</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; str) <span class="type">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graphic</span>: <span class="keyword">public</span> NLComponent &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// virtual output operator (still unconventional)</span></span><br><span class="line">  <span class="keyword">virtual</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; str) <span class="type">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line">TextBlock t;</span><br><span class="line">Graphic g;</span><br><span class="line">...</span><br><span class="line">t &lt;&lt; cout; <span class="comment">// print t on cout via</span></span><br><span class="line">	<span class="comment">// virtual operator&lt;&lt;; note</span></span><br><span class="line">	<span class="comment">// unconventional syntax</span></span><br><span class="line">g &lt;&lt; cout; <span class="comment">// print g on cout via</span></span><br><span class="line">  <span class="comment">// virtual operator&lt;&lt;; note</span></span><br><span class="line">	<span class="comment">// unconventional syntax</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>最好的解决办法，为继承体系声明一个名为print的虚函数，同时重载非成员函数<code>operator&lt;&lt;</code>，然后在重载函数中调用print虚函数！以此又能让用户优雅使用，又能赋予虚函数特性</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NLComponent</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> ostream&amp; <span class="title">print</span><span class="params">(ostream&amp; s)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextBlock</span>: <span class="keyword">public</span> NLComponent &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> ostream&amp; <span class="title">print</span><span class="params">(ostream&amp; s)</span> <span class="type">const</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graphic</span>: <span class="keyword">public</span> NLComponent &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> ostream&amp; <span class="title">print</span><span class="params">(ostream&amp; s)</span> <span class="type">const</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; s, <span class="type">const</span> NLComponent&amp; c)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> c.<span class="built_in">print</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Item-26-Limiting-the-number-of-objects-of-a-class"><a href="#Item-26-Limiting-the-number-of-objects-of-a-class" class="headerlink" title="Item 26: Limiting the number of objects of a class."></a>Item 26: Limiting the number of objects of a class.</h3><ul>
<li><p>把构造函数设为私有，这样对象就无法构造，也就限制了类的对象</p>
</li>
<li><p>提供一个public的获得自身对象的函数，在函数中返回static的类自身对象，这样很像单例，只有一个类的对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">xxx</span>();</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> Printer&amp; <span class="title">thePrinter</span><span class="params">()</span></span>;</span><br><span class="line">pivate:</span><br><span class="line">  <span class="built_in">Printer</span>();</span><br><span class="line">	<span class="built_in">Printer</span>(<span class="type">const</span> Printer&amp; rhs);</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Printer&amp; <span class="title">thePrinter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> Printer p; <span class="comment">// the single printer object</span></span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用户使用</span></span><br><span class="line"><span class="built_in">thePrinter</span>().<span class="built_in">xxx</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p>也可以用static函数来代替，但是用户使用起来就麻烦一点点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  	<span class="built_in">xxx</span>();</span><br><span class="line">  	<span class="function"><span class="type">static</span> Printer&amp; <span class="title">thePrinter</span><span class="params">()</span></span>;</span><br><span class="line">  	...</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Printer</span>();</span><br><span class="line">    <span class="built_in">Printer</span>(<span class="type">const</span> Printer&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Printer&amp; <span class="title">Printer::thePrinter</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">static</span> Printer p;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用户使用</span></span><br><span class="line">Printer::<span class="built_in">thePrinter</span>().<span class="built_in">xxx</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数中的static对象只在第一次调用的时候被创建，如果函数不被调用，则static对象也不会被创建</p>
</li>
<li><p>注意上述的thePrinter不能声明为inline，因为非成员函数有着internal linkage，这有可能会导致函数会重复，这也就意味着static变量可能不止一份</p>
</li>
<li><p>另外一种限制对象个数的方法非常直观，直接用类静态变量来记录对象的个数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">TooManyObjects</span>&#123;&#125;; <span class="comment">// exception class for use</span></span><br><span class="line">    <span class="comment">// when too many objects</span></span><br><span class="line">    <span class="comment">// are requested</span></span><br><span class="line">    <span class="built_in">Printer</span>();</span><br><span class="line">    ~<span class="built_in">Printer</span>();</span><br><span class="line">    ...</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">size_t</span> numObjects;</span><br><span class="line">    <span class="built_in">Printer</span>(<span class="type">const</span> Printer&amp; rhs); <span class="comment">// there is a limit of 1</span></span><br><span class="line">    <span class="comment">// printer, so never allow</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Obligatory definition of the class static</span></span><br><span class="line"><span class="type">size_t</span> Printer::numObjects = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Printer::<span class="built_in">Printer</span>()&#123;</span><br><span class="line">  <span class="keyword">if</span> (numObjects &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">  	<span class="keyword">throw</span> <span class="built_in">TooManyObjects</span>();</span><br><span class="line">	&#125;</span><br><span class="line">  proceed with normal construction here;</span><br><span class="line">  ++numObjects;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Printer::~<span class="built_in">Printer</span>()&#123;</span><br><span class="line">  perform normal destruction here;</span><br><span class="line">  --numObjects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当需要被限制个数的类有了派生类时，情况就变得微妙，假设colorPrint派生自print，那么当colorPrint对象构造时，它的print基类部分也会被构造，这就突破了对象个数限制</p>
</li>
<li><p>同理，如果print作为其他类的内嵌类，其他类如果构造了多个，那么print也会被构造多个</p>
</li>
<li><p>如果你不想限制对象的个数，但不想类被继承，可以将构造函数设为私有，然后开设公开的获取类对象的函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FSA</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// pseudo-constructors</span></span><br><span class="line"><span class="function"><span class="type">static</span> FSA * <span class="title">makeFSA</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> FSA * <span class="title">makeFSA</span><span class="params">(<span class="type">const</span> FSA&amp; rhs)</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">FSA</span>();</span><br><span class="line"><span class="built_in">FSA</span>(<span class="type">const</span> FSA&amp; rhs);</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">FSA * <span class="title">FSA::makeFSA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">FSA</span>(); &#125; <span class="comment">// 这里用智能指针更加</span></span><br><span class="line"><span class="function">FSA * <span class="title">FSA::makeFSA</span><span class="params">(<span class="type">const</span> FSA&amp; rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">FSA</span>(rhs); &#125; <span class="comment">// 这里用智能指针更加</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>很多类都有类似printer的诉求，可以直接整一个模板基类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">BeingCounted</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counted</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TooManyObjects</span>&#123;&#125;; <span class="comment">// for throwing exceptions</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">size_t</span> <span class="title">objectCount</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> numObjects; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="built_in">Counted</span>();</span><br><span class="line"><span class="built_in">Counted</span>(<span class="type">const</span> Counted&amp; rhs);</span><br><span class="line">~<span class="built_in">Counted</span>() &#123; --numObjects; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span> numObjects;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> maxObjects;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>; <span class="comment">// to avoid ctor code</span></span><br><span class="line">&#125;; <span class="comment">// duplication</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">BeingCounted</span>&gt;</span><br><span class="line">Counted&lt;BeingCounted&gt;::<span class="built_in">Counted</span>()</span><br><span class="line">&#123; <span class="built_in">init</span>(); &#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">BeingCounted</span>&gt;</span><br><span class="line">Counted&lt;BeingCounted&gt;::<span class="built_in">Counted</span>(<span class="type">const</span> Counted&lt;BeingCounted&gt;&amp;)</span><br><span class="line">&#123; <span class="built_in">init</span>(); &#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">BeingCounted</span>&gt;</span><br><span class="line"><span class="type">void</span> Counted&lt;BeingCounted&gt;::<span class="built_in">init</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (numObjects &gt;= maxObjects) <span class="keyword">throw</span> <span class="built_in">TooManyObjects</span>();</span><br><span class="line">++numObjects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Item-27-Requiring-or-prohibiting-heap-based-objects"><a href="#Item-27-Requiring-or-prohibiting-heap-based-objects" class="headerlink" title="Item 27: Requiring or prohibiting heap-based objects."></a>Item 27: Requiring or prohibiting heap-based objects.</h3><ul>
<li><p>定义一个只能在堆上创建的类</p>
<ul>
<li>将析构函数设为private，类对象就无法建立在栈上了。</li>
<li>类对象只能创建在堆上，就是<strong>不能静态创建类对象</strong>，即<strong>不能直接调用类的构造函数</strong>，即<code>A a;</code>时会报错</li>
<li>因为当对象建立在栈上面时，是由编译器分配内存空间的，调用构造函数来构造栈对象。当对象使用完后，编译器会调用析构函数来释放栈对象所占的空间。编译器管理了对象的整个生命周期，如果析构函数是私有的，则编译器无法调用析构函数，所以类对象无法在栈上创建。</li>
<li>如果将析构函数设为protected，则解决了private不能继承的问题。因为protected，编译器无法调用析构函数，但是子类可以调用基类的析构函数</li>
</ul>
</li>
<li><p>定义一个只能在栈上创建的类</p>
<ul>
<li>仅当使用new运算符，对象才会建立在堆上。因此，只要禁用new运算符就可以实现类对象只能建立在栈上。将operator new()设为私有即可，即<code>A* a = new A;</code>会报错</li>
</ul>
</li>
</ul>
<h3 id="Item-28-Smart-pointers"><a href="#Item-28-Smart-pointers" class="headerlink" title="Item 28: Smart pointers."></a>Item 28: Smart pointers.</h3><h3 id="Item-29-Reference-counting"><a href="#Item-29-Reference-counting" class="headerlink" title="Item 29: Reference counting."></a>Item 29: Reference counting.</h3><ul>
<li>引用计数是个很好的技巧，对于那些需要记账的资源，引用计数可以节约成本，引用计数还可以理解为垃圾回收的简易版</li>
</ul>
<h3 id="Item-30-Proxy-classes"><a href="#Item-30-Proxy-classes" class="headerlink" title="Item 30: Proxy classes."></a>Item 30: Proxy classes.</h3><h2 id="Miscellany"><a href="#Miscellany" class="headerlink" title="Miscellany"></a>Miscellany</h2><h3 id="Item-31-Making-functions-virtual-with-respect-to-more-than-one-object"><a href="#Item-31-Making-functions-virtual-with-respect-to-more-than-one-object" class="headerlink" title="Item 31: Making functions virtual with respect to more than one object."></a>Item 31: Making functions virtual with respect to more than one object.</h3><h3 id="Item-32-Program-in-the-future-tense"><a href="#Item-32-Program-in-the-future-tense" class="headerlink" title="Item 32: Program in the future tense."></a>Item 32: Program in the future tense.</h3><h3 id="Item-33-Make-non-leaf-classes-abstract"><a href="#Item-33-Make-non-leaf-classes-abstract" class="headerlink" title="Item 33: Make non-leaf classes abstract."></a>Item 33: Make non-leaf classes abstract.</h3><h3 id="Item-34-Understand-how-to-combine-C-and-C-in-the-same-program"><a href="#Item-34-Understand-how-to-combine-C-and-C-in-the-same-program" class="headerlink" title="Item 34: Understand how to combine C++ and C in the same program."></a>Item 34: Understand how to combine C++ and C in the same program.</h3><ul>
<li><p>两种语言都需要使用的函数，请使用extern “C”</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// declare a function called drawLine; don’t mangle</span></span><br><span class="line"><span class="comment">// its name</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawLine</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>C++预处理器定义了__cplusplus，所以像下面这样声明与c的混用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawLine</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">twiddleBits</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> bits)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">simulate</span><span class="params">(<span class="type">int</span> iterations)</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在main函数开始之前，有静态初始化的过程，main函数结束之后，有静态析构的过程</p>
</li>
</ul>
<h3 id="Item-35-Familiarize-yourself-with-the-language-standard"><a href="#Item-35-Familiarize-yourself-with-the-language-standard" class="headerlink" title="Item 35: Familiarize yourself with the language standard."></a>Item 35: Familiarize yourself with the language standard.</h3><h1 id="Effective-STL"><a href="#Effective-STL" class="headerlink" title="Effective STL"></a>Effective STL</h1><blockquote>
<p> 个人建议，看本书前最好看一遍侯捷写的STL源码剖析，知道源码方能理解如何使用</p>
</blockquote>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="1-慎重选择容器类型"><a href="#1-慎重选择容器类型" class="headerlink" title="1. 慎重选择容器类型"></a>1. 慎重选择容器类型</h3><h3 id="2-不要试图编写独立于容器类型的代码"><a href="#2-不要试图编写独立于容器类型的代码" class="headerlink" title="2. 不要试图编写独立于容器类型的代码"></a>2. 不要试图编写独立于容器类型的代码</h3><p>不同容器的用法不同，支持的方法、迭代器种类、迭代器&#x2F;指针&#x2F;引用失效场景也不尽相同，所以不能独立</p>
<h3 id="3-确保容器中的对象拷贝正确而高效"><a href="#3-确保容器中的对象拷贝正确而高效" class="headerlink" title="3. 确保容器中的对象拷贝正确而高效"></a>3. 确保容器中的对象拷贝正确而高效</h3><ul>
<li>往容器中添加元素，存入容器的是程序员所指定的对象的拷贝</li>
<li>当存在继承关系的情况下，拷贝会导致剥离（splice）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;Widget&gt; vw;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialWidget</span>: <span class="keyword">public</span> Widget&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">SpeicialWidget sw;</span><br><span class="line">vw.<span class="built_in">push_back</span>(sw); <span class="comment">// sw作为基类对象被拷贝进vw中，派生类特有的部分在拷贝时被丢弃</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使拷贝动作高效、正确、防止剥离问题的一个简单办法是使容器包含指针而不是对象，但需要注意内存泄露，可以使用智能指针</li>
</ul>
<h3 id="4-调用empty-而不是检查size-是否为0"><a href="#4-调用empty-而不是检查size-是否为0" class="headerlink" title="4. 调用empty()而不是检查size()是否为0"></a>4. 调用empty()而不是检查size()是否为0</h3><ul>
<li>容器的emtpy()函数总是在常数时间返回，而size()不一定</li>
<li>list容器支持splice，在常数时间内可以将两个list拼接（splice）在一起，所以list不会保存容器所包含多少个元素，即size()函数得遍历容器才能知道，所以需要O(n)时间</li>
<li>总之，empty()总是可以代替size&#x3D;&#x3D;0</li>
</ul>
<h3 id="5-区间成员函数优先于单成员函数"><a href="#5-区间成员函数优先于单成员函数" class="headerlink" title="5. 区间成员函数优先于单成员函数"></a>5. 区间成员函数优先于单成员函数</h3><ul>
<li><p>单成员函数，如<code>container::insert(xxx)</code>会导致多次调用，可能需要多次元素移动（如在vector的中间频繁insert），可能需要多次指针赋值（在list的中间频繁insert），可能需要多次扩容</p>
</li>
<li><p>区间成员函数，如<code>container::asign(iter_1, iter_2)</code>、<code>container::copy(iter_1, iter_2, iter)</code>等，事先就知道了要插入多少元素，性能更快</p>
</li>
<li><p> Range construction. All standard containers offer a constructor of this form: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">container::<span class="built_in">container</span>( InputIterator begin, <span class="comment">// beginning of rang</span></span><br><span class="line">                     InputIterator end); <span class="comment">//end of range </span></span><br></pre></td></tr></table></figure>
</li>
<li><p> Range insertion. All standard sequence containers offer this form of insert:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">container::insert</span><span class="params">(iterator position, <span class="comment">// where to insert the range</span></span></span></span><br><span class="line"><span class="params"><span class="function">InputIterator begin, <span class="comment">// start of range to insert</span></span></span></span><br><span class="line"><span class="params"><span class="function">InputIterator end)</span></span>; <span class="comment">// end of range to insert</span></span><br></pre></td></tr></table></figure>

<p>注意：关联容器的insert不需要指名insert position，因为position由内部数据结构与算法决定的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">container::insert</span><span class="params">(lnputIterator begin, InputIterator end)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Range erasure. Every standard container offers a range form of erase, but the return types differ for sequence and associative containers. Sequence containers provide this,</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">container::erase</span><span class="params">(iterator begin, iterator end)</span></span>; </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>while associative containers offer this: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">container::erase</span><span class="params">(iterator begin, iterator end)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Range assignment</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">container::assign</span><span class="params">(lnputIterator begin, InputIterator end)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-当心C-编译器最烦人的分析机制"><a href="#6-当心C-编译器最烦人的分析机制" class="headerlink" title="6. 当心C++编译器最烦人的分析机制"></a>6. 当心C++编译器最烦人的分析机制</h3><ul>
<li><p>有些时候可以使用有名的迭代器来传入STL函数中，这样就可以避免编译器把代码分析成程序员意料之外的函数声明</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">dataFile</span><span class="params">(<span class="string">&quot;ints.dat&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">data</span><span class="params">(istream_iterator&lt;<span class="type">int</span>&gt;(dataFile), <span class="comment">// warning! this doesn&#x27;t do</span></span></span></span><br><span class="line"><span class="params"><span class="function"> istream_iterator&lt;<span class="type">int</span>&gt;())</span></span>; <span class="comment">// what you think it does</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有名的迭代器，可以防止上述情况</span></span><br><span class="line"><span class="function">fstream <span class="title">dataFile</span><span class="params">(<span class="string">&quot; ints.dat&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">istream_iterator&lt;<span class="type">int</span>&gt; <span class="title">dataBegin</span><span class="params">(dataFile)</span></span>;</span><br><span class="line">istream_iterator&lt;<span class="type">int</span>&gt; dataEnd;</span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">data</span><span class="params">(dataBegin, dataEnd)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="7-如果容器中存放了new出来的对象，在析构时记得手动调用delete释放"><a href="#7-如果容器中存放了new出来的对象，在析构时记得手动调用delete释放" class="headerlink" title="7. 如果容器中存放了new出来的对象，在析构时记得手动调用delete释放"></a>7. 如果容器中存放了new出来的对象，在析构时记得手动调用delete释放</h3><ul>
<li>容器析构时会调用每个容器中每个元素的析构函数，但是如果这个元素是指针，指针所指向的对象则不会析构，需要程序员手动调用delete去析构，否则会有内存泄露！</li>
<li>用boost库的shared_ptr智能指针可以避免这种情况</li>
</ul>
<h3 id="8-切勿创建包含auto-ptr的容器对象"><a href="#8-切勿创建包含auto-ptr的容器对象" class="headerlink" title="8. 切勿创建包含auto_ptr的容器对象"></a>8. 切勿创建包含auto_ptr的容器对象</h3><ul>
<li><p>auto_ptr的容器（简称COAP）不可移植，C++标准都禁止使用它，但是有的STL平台没有禁止，这会导致很多难以预料的错误</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">auto_ptr&lt;Widget&gt; <span class="title">pw1</span> <span class="params">(<span class="keyword">new</span> Widget)</span></span>; <span class="comment">// pwl1points to a Widget</span></span><br><span class="line"><span class="function">auto_ptr&lt;Widget&gt; <span class="title">pw2</span><span class="params">(pw1)</span></span>; <span class="comment">// pw2 points to pw1&#x27;s Widget;</span></span><br><span class="line"> <span class="comment">// pw1 is set to NULL. (Ownership</span></span><br><span class="line"> <span class="comment">// of the Widget is transferred</span></span><br><span class="line"> <span class="comment">//from pw1 to pw2.)</span></span><br><span class="line">pw1 = pw2; <span class="comment">// pw1 now points to the Widget</span></span><br><span class="line"><span class="comment">// again; pw2 is set to NULL</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>比如std::sort会将元素复制给临时变量，COAP会导致容器中有些auto_ptr变为NULL！</p>
<blockquote>
<p> std::auto_ptr已经移除了，现在的替代品是std::unique_ptr</p>
</blockquote>
</li>
</ul>
<h3 id="9-慎重选择删除元素的方法"><a href="#9-慎重选择删除元素的方法" class="headerlink" title="9. 慎重选择删除元素的方法"></a>9. 慎重选择删除元素的方法</h3><ul>
<li><p>To eliminate all objects in a container that have a particular value: </p>
<ul>
<li><p>If the container is a vector, string, or deque, use the erase-remove idiom. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c.<span class="built_in">erase</span>( <span class="built_in">remove</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), <span class="number">1963</span>), <span class="comment">// the erase-remove idiom is</span></span><br><span class="line"> c.<span class="built_in">end</span>()); <span class="comment">//the best way to get rid of</span></span><br><span class="line"><span class="comment">// elements with a specific</span></span><br><span class="line"><span class="comment">// value when c is a vector,</span></span><br><span class="line"><span class="comment">//string, or deque</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>If the container is a list, use list::remove.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c. <span class="built_in">remove</span>(<span class="number">1963</span>); <span class="comment">//the remove member function is the</span></span><br><span class="line"><span class="comment">// best way to get rid of elements with</span></span><br><span class="line"><span class="comment">// a specific value when c is a list</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>If the container is a standard associative container, use its erase member function. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c.<span class="built_in">erase</span>(<span class="number">1963</span>); <span class="comment">// the erase member function is the</span></span><br><span class="line"><span class="comment">// best way to get rid of elements with</span></span><br><span class="line"><span class="comment">// a specific value when c is a</span></span><br><span class="line"><span class="comment">// standard associative container</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>To eliminate all objects in a container that satisfy a particular predicate: </p>
<ul>
<li><p>If the container is a vector, string, or deque, use the erase-remove_if idiom. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c.<span class="built_in">erase</span>(<span class="built_in">remove_if</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), badValue), <span class="comment">// this is the best way to</span></span><br><span class="line"> c.<span class="built_in">end</span>()); <span class="comment">// get rid of objects </span></span><br></pre></td></tr></table></figure>


</li>
<li><p>If the container is a list, use list::remove_if. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c.<span class="built_in">remove_if</span>(badValue); <span class="comment">// this is the best way to get rid of</span></span><br><span class="line"> <span class="comment">// objects where badValue returns</span></span><br><span class="line"> <span class="comment">//true when c is a list</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>If the container is a standard associative container, use remove_copy_if and swap, or write a loop to walk the container elements, being sure to postincrement your iterator when you pass it to erase.  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一：remove_copy_if &amp; swap</span></span><br><span class="line">AssocContainer&lt;<span class="type">int</span>&gt; c; <span class="comment">// c is now one of the standard associative containers</span></span><br><span class="line">…… </span><br><span class="line"> </span><br><span class="line">AssocContainer&lt;<span class="type">int</span>&gt; goodValues; <span class="comment">// temporary container to hold unremoved values</span></span><br><span class="line"><span class="built_in">remove_copy_if</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), <span class="comment">// copy unremoved values from c to goodValues</span></span><br><span class="line">   <span class="built_in">inserter</span>( goodValues, </span><br><span class="line">   goodValues.<span class="built_in">end</span>()), </span><br><span class="line">   badValue):</span><br><span class="line">c.<span class="built_in">swap</span>(goodValues): <span class="comment">// swap the contents of c and goodValues</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二：循环</span></span><br><span class="line">AssocContainer&lt;<span class="type">int</span>&gt; c;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误的示例</span></span><br><span class="line"><span class="keyword">for</span> (AssocContainer&lt;<span class="type">int</span>&gt;::iterator i = c.<span class="built_in">begin</span>(); <span class="comment">// clear, straightforward, and buggy code to erase every element</span></span><br><span class="line">i!= c.<span class="built_in">end</span>(); </span><br><span class="line">++i) &#123; </span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">badValue</span>(*i)) c.<span class="built_in">erase</span>(i); <span class="comment">// in c where badValue  returns true; don&#x27;t do this!</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的示例</span></span><br><span class="line"><span class="keyword">for</span> (AssocContainer&lt;<span class="type">int</span>&gt;::iterator i = c.<span class="built_in">begin</span>(); i != c.<span class="built_in">end</span>(); )&#123; <span class="comment">// i incremented below</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">badValue</span>(*i)) c.<span class="built_in">erase</span>(i++); <span class="comment">//把未递增的i传给erase，但真正erase前，i已递增，所以不会失效</span></span><br><span class="line">   <span class="keyword">else</span> ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>To do something inside the loop (in addition to erasing objects): </p>
<ul>
<li>If the container is a standard sequence container, write a loop to walk the container elements, being sure to update your iterator with erase’s return value each time von call it. <strong>记住：顺序容器的erase，除了会使迭代器本身失效，还会使迭代器后面的所有迭代都失效！</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 之前的erase&amp;remove方法行不通了，必须要用循环来做</span></span><br><span class="line"><span class="comment">// 记住：顺序容器的erase，除了会使迭代器本身失效，还会使迭代器后面的所有迭代都失效！</span></span><br><span class="line"><span class="comment">// 但因为顺序容器的erase函数会返回迭代器后面那个迭代器，所以可以靠返回值来继续循环</span></span><br><span class="line"><span class="keyword">for</span> (SeqContainer&lt;<span class="type">int</span>&gt;::iterator i = c.<span class="built_in">begin</span>(); i != c.<span class="built_in">end</span>();)&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">badValue</span>(*i))&#123;</span><br><span class="line">  logFile &lt;&lt; <span class="string">&quot;Erasing &quot;</span> &lt;&lt; *i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  i = c.<span class="built_in">erase</span>(i); <span class="comment">// keep i valid by assigning</span></span><br><span class="line">&#125; <span class="comment">//erase&#x27;s return value to it</span></span><br><span class="line">  <span class="keyword">else</span> ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>If the container is a standard associative container, write a loop to walk the container elements, being sure to postincrement your iterator when you pass it to erase.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后缀递增的技术已经在上面写过了</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="10-了解分配子（allocator）的限制与约定"><a href="#10-了解分配子（allocator）的限制与约定" class="headerlink" title="10. 了解分配子（allocator）的限制与约定"></a>10. 了解分配子（allocator）的限制与约定</h3><ul>
<li>Make your allocator a template, with the template parameter T representing the type of objects for which you are allocating memory.</li>
<li> Provide the typedefs pointer and reference, but always have pointer be T* and reference be T&amp;.</li>
<li>Never give your allocators per-object state. In general, allocators should have no nonstatic data members.</li>
<li>Remember that an allocator’s allocate member functions are passed the number of objects for which memory is required, not the number of bytes needed. Also remember that these functions return T* pointers Ma the pointer typedef), even though no T objects have yet been constructed.</li>
<li>Be sure to provide the nested rebind template on which standard containers depend</li>
</ul>
<h3 id="11-理解自定义allocator的合理用法"><a href="#11-理解自定义allocator的合理用法" class="headerlink" title="11. 理解自定义allocator的合理用法"></a>11. 理解自定义allocator的合理用法</h3><ul>
<li><p>同一类型的分配子必须是等价的</p>
<blockquote>
<p>如果不等价，由allocator1分配出来的list1拼接由allocator2分配出来的list2后，将不会释放list2的内存，造成内存泄露，所以必须等价</p>
</blockquote>
</li>
<li><p>如果你认为STL默认的内存管理器（即<code>allocator&lt;T&gt;</code>）太慢，或者浪费内存，或者你只需要单线程环境，<code>allocator&lt;T&gt;</code>的线程安全性牺牲了部分性能用于同步，再或者你想把容器中的对象对象放在一个特殊堆的相邻位置上以便局部化</p>
</li>
</ul>
<h3 id="12-切勿依赖STL容器的线程安全性"><a href="#12-切勿依赖STL容器的线程安全性" class="headerlink" title="12. 切勿依赖STL容器的线程安全性"></a>12. 切勿依赖STL容器的线程安全性</h3><ul>
<li><p>标准C++并没有提供保证</p>
</li>
<li><p>这时候通用做法是加锁</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">…</span><br><span class="line"><span class="built_in">getMutexFor</span>(v);</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::<span class="function">iterator <span class="title">first5</span><span class="params">(find(v.begin(), v.end(), <span class="number">5</span>))</span></span>;</span><br><span class="line"><span class="keyword">if</span> (first5 != v.<span class="built_in">end</span>()) &#123; <span class="comment">// this is now safe</span></span><br><span class="line"> *first5 = <span class="number">0</span>; <span class="comment">// so is this</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">releaseMutexFor</span>(v);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用面向对象的思想来管理锁，『获得资源时即初始化』（resorce acquisition is initialization，RAII），可以防止程序员忘记释放锁的情况发生</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Lock</span>(<span class="type">const</span> Containers container)</span><br><span class="line"> : <span class="built_in">c</span>(container)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">getMutexFor</span>(c); <span class="comment">// acquire mutex in the constructor</span></span><br><span class="line"> &#125;</span><br><span class="line"> ~<span class="built_in">Lock</span>()</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">releaseMutexFor</span>(c); <span class="comment">// release it in the destructor</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="type">const</span> Container&amp; c;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">…</span><br><span class="line">&#123; <span class="comment">// create new block;</span></span><br><span class="line"> Lock&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">lock</span>(v); <span class="comment">// acquire mutex</span></span><br><span class="line"> vector&lt;<span class="type">int</span>&gt;::<span class="function">iterator <span class="title">first5</span><span class="params">(find(v.begin(), v.end(), <span class="number">5</span>))</span></span>;</span><br><span class="line"> <span class="keyword">if</span> (first5 != v.<span class="built_in">end</span>()) &#123;</span><br><span class="line"> *first5 = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125; <span class="comment">// close block, automatically</span></span><br><span class="line"> <span class="comment">// releasing the mutex</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="vector和string"><a href="#vector和string" class="headerlink" title="vector和string"></a>vector和string</h2><h3 id="13-vector和string优先于动态分配的数组"><a href="#13-vector和string优先于动态分配的数组" class="headerlink" title="13. vector和string优先于动态分配的数组"></a>13. vector和string优先于动态分配的数组</h3><ul>
<li>使用new来动态分配内存，必须要有delete，否则会内存泄露</li>
<li>如果分配单个对象，new与delete成对使用，如果分配数组，new[]与delete[]成对使用</li>
<li>对于同一个new分配的对象，确保只delete一次，double delete的结果也是不确定的</li>
</ul>
<h3 id="14-使用reserve来减少不必要的内存重新分配"><a href="#14-使用reserve来减少不必要的内存重新分配" class="headerlink" title="14. 使用reserve来减少不必要的内存重新分配"></a>14. 使用reserve来减少不必要的内存重新分配</h3><ul>
<li><p>注意这四个函数的区别：size(), capacity(), resize(), reserve()，只有vector和string同时提供了这4个函数</p>
<ul>
<li><code>size()</code> tells you how many elements are in the container. It does not tell you how much memory the container has allocated for the elements it holds.  </li>
<li><code>capacity()</code> tells you how many elements the container can hold in the memory it has already allocated. This is how many total elements the container can hold in that memory, not how many more elements it can hold. If you’d like to find out how much unoccupied memory a vector or string has, you must subtract size() from capacity(). If size and capacity return the same value, there is no empty space in the container, and the next insertion (via insert or push_back, etc.) will trigger the reallocation steps above. </li>
<li><code>resize(size_t n)</code> forces the container to change to n the number of elements it holds. After the call to resize, size will return n. If n is smaller than the current size, elements at the end of the container will be destroyed. If n is larger than the current size, new default-constructed elements will be added to the end of the container. If n is larger than the current capacity, a reallocation will take place before the elements are added.  </li>
<li><code>reserve(size_t n)</code> forces the container to change its capacity to at least n. provided n is no less than the current size. This typically forces a reallocation, because the capacity needs to be increased. (If n is less than the current capacity, vector ignores the call and does nothing, string may reduce its capacity to the maximum of size() and n. but the string’s size definitely remains unchanged. In my experience, using reserve to trim the excess capacity from a string is gene</li>
</ul>
</li>
<li><p>如果事先知道vector&#x2F;string会增加多少，可以用reserve()函数一次性扩容，因为自动扩容大概是原来容量的两倍，可能需要多次自动扩容，损耗性能</p>
</li>
</ul>
<h3 id="15-注意string实现的多样性"><a href="#15-注意string实现的多样性" class="headerlink" title="15. 注意string实现的多样性"></a>15. 注意string实现的多样性</h3><ul>
<li><p><code>sizeof(string)</code>是多大？取决于实现平台</p>
</li>
<li><p>几乎所有string的实现都会包含以下几项</p>
<ul>
<li><strong>The size</strong> of the string, i.e., the number of characters it contains.  </li>
<li><strong>The capacity</strong> of the memory holding the string’s characters. (For a review of the difference between a string’s size and its capacity, see Item 14.)  </li>
<li><strong>The value</strong> of the string, i.e., the characters making up the string. In addition, a string may hold  A copy of its allocator. For an explanation of why this field is optional, turn to Item 10 and read about the curious rules governing allocators. string implementations that depend on reference counting also contain  </li>
<li><strong>The reference</strong> count for the value.</li>
</ul>
</li>
<li><p>不同实现的区别</p>
<ul>
<li>string values may or may not be reference counted. By default, many implementations do use reference counting, but they usually offer a way to turn it off, often via a preprocessor macro（预处理宏）.</li>
</ul>
</li>
<li><p>string objects may range in size from one to at least seven times the size of char* pointers.（一倍指针的实现是string对象本身就是个指针，这个指针指向的结构体包括size、capacity、refcnt、point（to values array），如下图）</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h00awfzjcyj20l40cm3yu.jpg" alt="image-20220306174144883"></p>
</li>
<li><p>Creation of a new string value may require zero, one, or two dynamic allocations.（取决于用了几层指针）</p>
</li>
<li><p>string objects may or may not share information on the string’s size and capacity.</p>
</li>
<li><p>strings may or may not support per-object allocators.</p>
</li>
<li><p>Different implementations have different policies regarding minimum allocations for character buffers.</p>
</li>
</ul>
<h3 id="16-了解如何把vector和string数据传给旧的API"><a href="#16-了解如何把vector和string数据传给旧的API" class="headerlink" title="16. 了解如何把vector和string数据传给旧的API"></a>16. 了解如何把vector和string数据传给旧的API</h3><ul>
<li>假设v是<code>vector&lt;int&gt;</code>容器，对于C语言API：<code>void doSomething(const int* pInts, size_t numInts)</code>，可以传入<code>doSomething(&amp;v[0], v.size())</code>，但是如果v为空，<code>&amp;v[0]</code>指向的就是空的了，不太安全，还是在前面判断非空比较好</li>
<li>假设s是<code>string</code>，对于C语言API：<code>void doSomething(const char* pString)</code>，可以传入<code>doSomething(s.c_str())</code>，即使s长度为零也没关系，c_str()返回指向空字符串的指针</li>
<li>没有特殊情况，不建议这样做，这一节只是介绍方法而已</li>
</ul>
<h3 id="17-使用swap技巧去除多余的容量（C-11已有shrink-to-fit方法"><a href="#17-使用swap技巧去除多余的容量（C-11已有shrink-to-fit方法" class="headerlink" title="17. 使用swap技巧去除多余的容量（C++11已有shrink-to-fit方法"></a>17. 使用swap技巧去除多余的容量（C++11已有shrink-to-fit方法</h3><ul>
<li>假设v是个很大的vector，经过很多次erase后，没有多少元素了，但是其容量还是很大，很消耗内存，可以调用shrink-to-fit方法，但是其实现比较有技巧</li>
<li>swap技巧：<code>vector&lt;T&gt;(v).swap(v);</code></li>
<li>解释：<code>vector&lt;T&gt;(v)</code>创建一个临时向量，它是v的拷贝，<strong>注意vector的拷贝构造函数只为所拷贝的元素分配所需内存</strong>，所以临时向量没有多余容量，其与v变量交换，v具有了被去除之后的容量，而临时向量变成了臃肿的容量，最后被析构，从而达到shrink-to-fit的目的！</li>
<li>同理，可以对string也这样操作</li>
<li>swap技巧还可以用于清除一个容器：<code>vector&lt;T&gt;().swap(v)</code>，<code>string().swap(s)</code></li>
<li>swap容器，不仅内容被交换，迭代器、指针、引用也被交换（string除外），但依然有效，只不过指向的元素在另一个容器中</li>
</ul>
<h3 id="18-避免使用vector-lt-bool-gt"><a href="#18-避免使用vector-lt-bool-gt" class="headerlink" title="18. 避免使用vector&lt;bool&gt;"></a>18. 避免使用<code>vector&lt;bool&gt;</code></h3><ul>
<li><p>C++标准规定，如果c是包含对象T的容器，且c支持operator[]，则下面代码必须能够被编译</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T *p = &amp;c[<span class="number">0</span>]; <span class="comment">// initialize a T* with the address</span></span><br><span class="line"> <span class="comment">// of whatever operator[] returns</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>但是<code>vector&lt;bool&gt;</code>不能这样编译，为了节省空间，每个bool仅占一个二进制位，很像位域bitfield</p>
</li>
<li><p>已有<code>std::bitset</code>可以代替<code>vector&lt;bool&gt;</code></p>
</li>
</ul>
<h2 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h2><h3 id="19-理解相等（equality）和等价（equivalence）的区别"><a href="#19-理解相等（equality）和等价（equivalence）的区别" class="headerlink" title="19. 理解相等（equality）和等价（equivalence）的区别"></a>19. 理解相等（equality）和等价（equivalence）的区别</h3><ul>
<li><p>STL有许多函数需要确定两个值是否相同，但它们的判断方式不同</p>
<ul>
<li>find对相同的定义是<strong>相等</strong>，以operator&#x3D;&#x3D;为基础</li>
<li>set::insert对相同的定义是<strong>等价</strong>，已operator&lt;为基础</li>
</ul>
</li>
<li><p>相等很好理解，而等价的理解需要了解关联容器的特点，等价是以”<strong>在已排序的区间中对象值的相对顺序</strong>“为基础，比如，<code>set&lt;Widget&gt;</code>的默认比较函数是<code>less&lt;Widget&gt;</code>，而在默认情况<code>less&lt;Widget&gt;</code>只是简单调用针对Widget类的operator&lt;，也就是是说：w1与w2对于operator&lt;是等价的，当且仅当：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!(w1 &lt; w2) &amp;&amp; !(w2 &lt; w1)</span><br><span class="line">  <span class="comment">// 按照一定的排序准则，两个值中的任一个都不在另一个前面，则这两个值是**等价**的</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当用户自定义比较函数时，上面的operator&lt;就被替换为自定义的比较函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">!c.<span class="built_in">key_comp</span>()(x, y) &amp;&amp; !c.<span class="built_in">key_comp</span>()(y, x) <span class="comment">// it&#x27;s not true that x precedes</span></span><br><span class="line"><span class="comment">// y in c&#x27;s sort order and it&#x27;s</span></span><br><span class="line"><span class="comment">// also not true that y precedes</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>对于stl::find，是以operator&#x3D;&#x3D;作为相等的比较准则，而对于set的find成员函数，是已operator&lt;作为等价的比较准则，对set容器调用stl::find与直接调用成员函数set::find，两者的结果可能会不一样</p>
</li>
</ul>
<h3 id="20-为包含指针的关联容器指定比较类型"><a href="#20-为包含指针的关联容器指定比较类型" class="headerlink" title="20. 为包含指针的关联容器指定比较类型"></a>20. 为包含指针的关联容器指定比较类型</h3><ul>
<li><p>这种情况要非常小心</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">set&lt;string*&gt; ssp; <span class="comment">// ssp = &quot;set of string ptrs&quot;</span></span><br><span class="line">ssp.<span class="built_in">insert</span>(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;Anteater&quot;</span>));</span><br><span class="line">ssp.<span class="built_in">insert</span>(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;Wombat&quot;</span>));</span><br><span class="line">ssp.<span class="built_in">insert</span>(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;Lemur&quot;</span>));</span><br><span class="line">ssp.<span class="built_in">insert</span>(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;Penguin&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (set&lt;string*&gt;::const_iterator i = ssp.<span class="built_in">begin</span>(); i != ssp.<span class="built_in">end</span>(); ++i)</span><br><span class="line"></span><br><span class="line"> cout &lt;&lt; *i &lt;&lt; endl;</span><br><span class="line">  <span class="comment">// you expect to see this: &quot;Anteater&quot;,&quot;Lemur”,&quot;&#x27;Penguin”,&quot;Wombat&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>set&lt;string*&gt; ssp;</code>等同于<code>set&lt;string*, less&lt;string*&gt;&gt; ssp;</code>，所以并不是以string的字典序作为比较顺序，而是以string*这个指针来作为比较顺序，也就是内存地址，这可与预期完全不一样了</p>
</li>
<li><p>解决方法是自定义解引用的比较函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DereferenceLess</span> &#123;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> PtrType&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(PtrType pT1, <span class="comment">// parameters are passed by</span></span></span></span><br><span class="line"><span class="params"><span class="function">   PtrType pT2)</span> <span class="type">const</span> <span class="comment">// value, because we expect them</span></span></span><br><span class="line"><span class="function">   </span>&#123; <span class="comment">// to be (or to act like) pointers</span></span><br><span class="line">    <span class="keyword">return</span> *pT1 &lt; *pT2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="21-总是让比较函数在相等时候返回false"><a href="#21-总是让比较函数在相等时候返回false" class="headerlink" title="21. 总是让比较函数在相等时候返回false"></a>21. 总是让比较函数在相等时候返回false</h3><ul>
<li><p>如果operator&lt;被替换为了operator&lt;&#x3D;，那么在调用<code>set&lt;int&gt;::insert</code>时，假设原来已有元素10，记为10a，新的10记为10b，则判断等价的方式为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!(<span class="number">10</span>A&lt;= <span class="number">10B</span>)&amp;&amp;!(<span class="number">10B</span>&lt;= <span class="number">10</span>A) <span class="comment">//test 10Aand 10B for equivalence</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>这会导致两个10被判定为不等价，于是第二个10也可以加入到set集合中，完全违背了不重复的原则</p>
</li>
<li><p>技术上说，对于关联容器的比较函数必须是严格弱序化的（strict weak ordering）</p>
</li>
</ul>
<h3 id="22-切勿直接修改set或multiset的键"><a href="#22-切勿直接修改set或multiset的键" class="headerlink" title="22. 切勿直接修改set或multiset的键"></a>22. 切勿直接修改set或multiset的键</h3><ul>
<li>每个元素的key是维持元素之间顺序的判断标准，贸然修改会导致不确定的结果</li>
<li>真有这样的需求，可以这样操作<ul>
<li>找到元素</li>
<li>拷贝它，并修改成你希望的值</li>
<li>把原来的元素删除，一般是erase函数</li>
<li>把拷贝的新值插入到容器中，按照原来的排序，新元素与旧元素应该是相同位置或者挨着的，可以用带有指示插入位置的insert函数，插入位置来自于第一步的找到元素</li>
</ul>
</li>
</ul>
<h3 id="23-考虑用排序的vector替代关联容器"><a href="#23-考虑用排序的vector替代关联容器" class="headerlink" title="23. 考虑用排序的vector替代关联容器"></a>23. 考虑用排序的vector替代关联容器</h3><ul>
<li><p>适用于三阶段的业务场景：</p>
<ul>
<li>设置阶段：创建并大量插入元素</li>
<li>查找阶段：很少或几乎没有插入或删除操作</li>
<li>重组阶段：增删改该数据结构，然后继续第二步，然后循环</li>
</ul>
</li>
<li><p>有序的关联容器一般是平衡二叉树及其变异，插入删除一般伴随着移动操作，比较消耗时间</p>
</li>
<li><p>如果是排序的vector，可以很方便使用binary_search, lower_bound, equal_range等函数</p>
</li>
<li><p>vector的空间消耗比关联容器更小，且是连续地址空间，可以减少缺页</p>
</li>
<li><p>典型的代码如下，符合三阶段业务场景</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;Widget&gt; vw; <span class="comment">// alternative to set&lt;Widget&gt;</span></span><br><span class="line">…… <span class="comment">//Setup phase: lots of</span></span><br><span class="line"><span class="comment">// insertions, few lookups</span></span><br><span class="line"><span class="built_in">sort</span>(vw.<span class="built_in">begin</span>(), vw.<span class="built_in">end</span>()); <span class="comment">// end of Setup phase. (When</span></span><br><span class="line"><span class="comment">// simulating a multiset, you</span></span><br><span class="line"><span class="comment">// might prefer stable_sort</span></span><br><span class="line"><span class="comment">// instead; see Item 31.)</span></span><br><span class="line">Widget w; <span class="comment">// object for value to look up</span></span><br><span class="line">…… <span class="comment">//start Lookup phase</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">binary_search</span>(vw.<span class="built_in">begin</span>(), vw.<span class="built_in">end</span>(), w))... <span class="comment">// lookup via binary_search</span></span><br><span class="line">vector&lt;Widget&gt;::iterator i =</span><br><span class="line"> <span class="built_in">lower_bound</span>(vw.<span class="built_in">begin</span>(), vw.<span class="built_in">end</span>(), w); <span class="comment">// lookup via lower_bound;</span></span><br><span class="line"><span class="keyword">if</span> (i != vw.<span class="built_in">end</span>() &amp;&amp; !(*i &lt; w))... <span class="comment">// see Item 45 for an explana-</span></span><br><span class="line"> <span class="comment">//tion of the&quot;!(*i &lt; w)&quot; test</span></span><br><span class="line">pair&lt;vector&lt;Widget&gt;::iterator,</span><br><span class="line">vector&lt;Widget&gt;::iterator&gt; range =</span><br><span class="line"><span class="built_in">equal_range</span>(vw.<span class="built_in">begin</span>(), vw.<span class="built_in">end</span>(), w); <span class="comment">// lookup via equal_range</span></span><br><span class="line"><span class="keyword">if</span> (range.first != range.second)...</span><br><span class="line">… <span class="comment">// end Lookup phase, start</span></span><br><span class="line"><span class="comment">// Reorganize phase</span></span><br><span class="line"><span class="built_in">sort</span>(vw.<span class="built_in">begin</span>(), vw.<span class="built_in">end</span>()); <span class="comment">// begin new Lookup phase... </span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="24-效率至关重要时，在map-operator-与map-insert中谨慎选择"><a href="#24-效率至关重要时，在map-operator-与map-insert中谨慎选择" class="headerlink" title="24. 效率至关重要时，在map::operator[]与map::insert中谨慎选择"></a>24. 效率至关重要时，在map::operator[]与map::insert中谨慎选择</h3><ul>
<li><p>map::operator[]是为了方便添加和更新功能在同一个函数中，在下面的示例中，是添加功能：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, Widget&gt; m;</span><br><span class="line">m[<span class="number">1</span>] = <span class="number">1.50</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>The expression m[1] is shorthand for <code>m.operator[](1)</code>, so this is a call to map::operator[]. That function must return a reference to a Widget, because m’s mapped type is Widget. In this case, m doesn’t yet have anything in it, so there is no entry in the map for the key 1. operator[] therefore default-constructs a Widget to act as the value associated with 1, then returns a reference to that Widget. Finally, the Widget becomes the target of an assignment: the assigned value is 1.50.</p>
</li>
<li><p>直接调用m.insert，可以节省三个函数调用：创建默认构造函数的临时Widget对象，析构Widget对象，还有Widget的赋值操作符</p>
</li>
<li><p>总结：</p>
<ul>
<li>如果要更新已有的map元素，优先选择operator[]</li>
<li>如果要添加一个元素，还是选择map::insert</li>
</ul>
</li>
</ul>
<h3 id="25-熟悉非标准的散列容器"><a href="#25-熟悉非标准的散列容器" class="headerlink" title="25. 熟悉非标准的散列容器"></a>25. 熟悉非标准的散列容器</h3><ul>
<li>散列容器基于hash，它们的比较方法不是基于operator&lt;，而是operator&#x3D;&#x3D;，因为元素hash后要与已有元素的hash进行<strong>相等</strong>比较，而且散列容器不需要保持有序性，所以不是以<strong>等价</strong>作为比较标准</li>
<li>书中说散列容器不是STL的一部分，但好像后来加入了</li>
</ul>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><h3 id="26-尽量用iterator代替const-iterator、-reverse-iterator和const-reverse-iterator"><a href="#26-尽量用iterator代替const-iterator、-reverse-iterator和const-reverse-iterator" class="headerlink" title="26. 尽量用iterator代替const_iterator、 reverse_iterator和const_reverse_iterator"></a>26. 尽量用iterator代替const_iterator、 reverse_iterator和const_reverse_iterator</h3><ul>
<li><p>有些容器的成员函数只接受iterator</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="type">const</span> T&amp; x)</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator position)</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator rangeBegin, iterator rangeEnd)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>reverse_iterator可以  用其base成员函数转换为iterator。const_reverse_iterator也可以类似地  base转换成为const_iterator。但可能需要一些调整</p>
</li>
<li><p>const_iterator无法转换为iterator</p>
</li>
</ul>
<h3 id="27-用distance和advance把const-iterator转化成iterator"><a href="#27-用distance和advance把const-iterator转化成iterator" class="headerlink" title="27. 用distance和advance把const_iterator转化成iterator"></a>27. 用distance和advance把const_iterator转化成iterator</h3><ul>
<li><p>用<code>const_cast&lt;&gt;</code>映射转换很可能行不通，而且不可移植</p>
</li>
<li><p>要得到与const_iterator指向同一位置的iterator，首先将iterator指向容器的起始位置，然后把它向前移到和const_iterator 离容器起始位置的偏移一样的位置即可，distance 返回两个指向同一个容器的iterator之间的距离； advance则用于将一个iterator移动指定的距离</p>
</li>
<li><p>首先考虑：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> deque&lt;<span class="type">int</span>&gt; IntDeque; <span class="comment">// 和以前一样</span></span><br><span class="line"><span class="keyword">typedef</span> IntDeque::iterator Iter;</span><br><span class="line"><span class="keyword">typedef</span> IntDeque::const_iterator ConstIter;</span><br><span class="line">IntDeque d;</span><br><span class="line">ConstIter ci;</span><br><span class="line">... <span class="comment">//  ci指向d</span></span><br><span class="line"><span class="function">Iter <span class="title">i</span><span class="params">(d.begin())</span></span>; <span class="comment">// 初始化i为d.begin()</span></span><br><span class="line"><span class="comment">// 错误的做法：</span></span><br><span class="line"><span class="built_in">advance</span>(i, <span class="built_in">distance</span>(i, ci)); <span class="comment">// 把i移到指向ci位置，但留意下面关于为什么，在它编译前要调整的原因 </span></span><br></pre></td></tr></table></figure>
</li>
<li><p>为什么错误？但是InputIterator没法推断出两个类型，具有歧义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> InputIterator&gt;</span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::<span class="function">difference_type</span></span><br><span class="line"><span class="function"><span class="title">distance</span><span class="params">(InputIterator first, InputIterator last)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改方法：显式的指名distance调用的模板参数类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">advance</span>(i, <span class="built_in">distance</span>&lt;ConstIter&gt;(i, ci));</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于随机访问的迭代器（ 比如vector、string和deque的 ）而言，这是 是常数时间的操作。对于双向跌代器是，线性时间 的操作。</p>
</li>
</ul>
<h3 id="28-了解如何通过reverse-iterator的base得到iterator"><a href="#28-了解如何通过reverse-iterator的base得到iterator" class="headerlink" title="28. 了解如何通过reverse_iterator的base得到iterator"></a>28. 了解如何通过reverse_iterator的base得到iterator</h3><ul>
<li> 实现在一个reverse_iterator ri指出的位置上删除元素 就应 删除ri.base()的前一个元素。对于删除操作   ri和ri.base()并不等价  且ri.base()不是ri对应的iterator。</li>
<li>reverse_iterator的base成员函数 回一个“对应的”iterator的 法并不准确。对于插入操作  的确如此；但是对于删除操作并非如此。当 需要把reverse_iterator转换成iterator的时候，有一点非常重要的是你必须知道你准备怎么处理返回的iterator，因为只有这样你才能决定你得到的iterator是否是你需要的。</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h02tw21nl5j20ak07474a.jpg" alt="image-20220308220954725"></p>
<h3 id="29-需要一个一个字符输入时考虑使用istreambuf-iterator"><a href="#29-需要一个一个字符输入时考虑使用istreambuf-iterator" class="headerlink" title="29. 需要一个一个字符输入时考虑使用istreambuf_iterator"></a>29. 需要一个一个字符输入时考虑使用istreambuf_iterator</h3><ul>
<li><p>你可以像istream_iterator一样使用istreambuf_iterator但<code>istream_iterator&lt;char&gt;</code>对象使用<code>operator&gt;&gt;</code>来从输入流中读取单个字符。</p>
<p><code>istreambuf_iterator&lt;char&gt;</code>对象进入流的缓冲区并直接读取下一个字符</p>
</li>
</ul>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>两个目标：</p>
<ol>
<li>介绍少见的算法</li>
<li>避免算法的常见用法问题</li>
</ol>
<h3 id="30-确保目标区间足够大"><a href="#30-确保目标区间足够大" class="headerlink" title="30. 确保目标区间足够大"></a>30. 确保目标区间足够大</h3><h3 id="31-了解你的排序选择"><a href="#31-了解你的排序选择" class="headerlink" title="31. 了解你的排序选择"></a>31. 了解你的排序选择</h3><ul>
<li><p>部分排序？使用partial_sort</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">qualityCompare</span><span class="params">(<span class="type">const</span> Widget&amp; lhs, <span class="type">const</span> Widget&amp; rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//  lhs的质 是不是比rhs的质 好</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">partial_sort</span>(widgets.<span class="built_in">begin</span>(), <span class="comment">// 把最好的20个元素</span></span><br><span class="line">  widgets.<span class="built_in">begin</span>() + <span class="number">20</span>, <span class="comment">//  按顺序 放在widgets的前端</span></span><br><span class="line">  widgets.<span class="built_in">end</span>(),</span><br><span class="line">  qualityCompare);</span><br><span class="line">... <span class="comment">// 使用widgets...</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>部分排序的结果是否可以不排序？partial_sort给了更多的信息，如果不需要这额外的信息，可以考虑使用nth_element</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nth_element</span>(widgets.<span class="built_in">begin</span>(), <span class="comment">// 把最好的20个元素</span></span><br><span class="line">  widgets.<span class="built_in">begin</span>() + <span class="number">19</span>, <span class="comment">// 放在widgets前端 </span></span><br><span class="line">  widgets.<span class="built_in">end</span>(), <span class="comment">// 但不用担心</span></span><br><span class="line">  qualityCompare); <span class="comment">// 它们的顺序</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>除了stable_sort是稳定的，sort、partial_sort、nth_element都是不稳定的</p>
</li>
<li><p>partition算法，重排区间的元素从而满足某个标准的元素都在区间的开头</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hasAcceptableQuality</span><span class="params">(<span class="type">const</span> Widget&amp; w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//  返回w质量等级是否是2或更高;</span></span><br><span class="line">&#125;</span><br><span class="line">vector&lt;Widget&gt;::iterator goodEnd = <span class="comment">// 把所有满足hasAcceptableQuality</span></span><br><span class="line">  <span class="built_in">partition</span>(widgets.<span class="built_in">begin</span>(), <span class="comment">// 的widgets移动到widgets前端 </span></span><br><span class="line">  widgets.<span class="built_in">end</span>(), <span class="comment">// 并且返回一个指向第一个</span></span><br><span class="line">  hasAcceptableQuality); <span class="comment">// 不满足的widget的跌代器</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>算法sort、stable_sort、partial_sort和nth_element  需要随机迭代器， 所以它们可能只能 用于vector、string、deque和数组</p>
</li>
<li><p>如果想对list进行partial_sort或nth_element，必须间接完成，即把元素拷贝到一个支持随机访问迭代器的容器中，然后应用需要的算法</p>
</li>
<li><p>list的sort成员函数可以代替sort和stable_sort</p>
</li>
<li><p>partition和stable_partition只需要双向迭代器，所有可以在任何标准序列迭代器上使用partition和stable_partition</p>
</li>
</ul>
<h3 id="32-如果你真的想删除东西的话就在类似remove的算法后接上erase"><a href="#32-如果你真的想删除东西的话就在类似remove的算法后接上erase" class="headerlink" title="32. 如果你真的想删除东西的话就在类似remove的算法后接上erase"></a>32. 如果你真的想删除东西的话就在类似remove的算法后接上erase</h3><ul>
<li><p>remove接收指定它操作的元素区间的一对跌代器。它不接收一个容器 所以remove不知道它作用于哪个容器。此外 remove也不可能发现容器， 因为没有办法从一个迭代器获取对应于它的容器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIterator, <span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">remove</span><span class="params">(ForwardIterator first, ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> T&amp; value)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>所以：唯一从容器中除去一个元素的方法是在那个容器上应用一个成员函数（一般是erase），因为remove无法知道它正在操作的容器</p>
</li>
<li><p>remove做了什么：</p>
<ul>
<li>remove移动指定区间中的元素直到所有“不删除的”元素在区间的开头相对位置和原来它们的一样。它返回一个指向最后一个的下一个“不删除的”元素的跌代器。 返回值是区间的“新逻辑终点”</li>
<li>在内部，  remove遍历这个区间， 把要 “删除的”值覆盖为后面要保留的值。 这个覆盖通过对持有被覆盖的值的元素赋值来完成</li>
<li>你可以想象remove完成了一种压缩 ，被删除的值表演了在压缩中被填充的洞的角色</li>
</ul>
</li>
<li><p>所以remove一般要与erase连起来使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v; <span class="comment">// 正如从前</span></span><br><span class="line">v.<span class="built_in">erase</span>(<span class="built_in">remove</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">99</span>), v.<span class="built_in">end</span>()); <span class="comment">// 真的删除所有// 等于99的元素</span></span><br><span class="line">cout &lt;&lt; v.<span class="built_in">size</span>(); <span class="comment">// 现在返回7</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="33-提防在指针的容器上使用类似remove的算法"><a href="#33-提防在指针的容器上使用类似remove的算法" class="headerlink" title="33. 提防在指针的容器上使用类似remove的算法"></a>33. 提防在指针的容器上使用类似remove的算法</h3><ul>
<li>如果你无法避免在存放指针的容器上使用remove， 排除这个问题一种方法是在应用erase-remove惯用法之前先删除指针并设置它们为空，然后除去容器中的所有空指针</li>
<li>智能指针可以在这个问题上防止内存泄露</li>
</ul>
<h3 id="34-注意哪个算法需要有序区间"><a href="#34-注意哪个算法需要有序区间" class="headerlink" title="34. 注意哪个算法需要有序区间"></a>34. 注意哪个算法需要有序区间</h3><ul>
<li><p>搜索算法binary_search、lower_bound、upper_bound和equal_range需要有序区间，因为它们使用二分查找，注意传入的迭代器得是随机访问迭代器，如果是其他如双向迭代器，则运行需要线性时间</p>
</li>
<li><p>算法set_union、set_intersection、set_difference和set_symmetric_difference的四人组提供了线性时间设置它们名字所提出的操作的性能，如果不是有序区间，则不能保证以线性时间完成</p>
</li>
<li><p>merge和inplace_merge执行了有效的单遍合并排序算法： 它们读取两个有序区间， 然后产生一个包含了两个源区间所有元素的新有序区间。它们以线性时间执行，如果它们不知道源区间已经有序就不能完成。</p>
</li>
<li><p>includes用来检测是否一个区 的所有对象也在另一个区 中。因为includes可能假设的两个区间已经有序。 所以它保证了线性时间性能 。没有那个保证，一般来说它会变慢。</p>
</li>
<li><p>unique和unique_copy：从每个相等元素的<strong>连续</strong>组中去除第一个以外所有的元素，这意味着原区间得排好序；而且unique从一个间 除去元素的方式和remove一样， 也就是说它只是区分出不除去的元素</p>
<blockquote>
<p>STL的unique和Unix的uniq之间有惊人的相似</p>
</blockquote>
</li>
</ul>
<h3 id="35-mismatch或lexicographical比-实现简单的忽略大小写字符串比较"><a href="#35-mismatch或lexicographical比-实现简单的忽略大小写字符串比较" class="headerlink" title="35. mismatch或lexicographical比 实现简单的忽略大小写字符串比较"></a>35. mismatch或lexicographical比 实现简单的忽略大小写字符串比较</h3><h3 id="36-了解copy-if的正确实现"><a href="#36-了解copy-if的正确实现" class="headerlink" title="36. 了解copy_if的正确实现"></a>36. 了解copy_if的正确实现</h3><h3 id="37-用accumulate或for-each来统计区间"><a href="#37-用accumulate或for-each来统计区间" class="headerlink" title="37. 用accumulate或for_each来统计区间"></a>37. 用accumulate或for_each来统计区间</h3><ul>
<li><p>count告诉你一个区间有多少个元素</p>
</li>
<li><p>count_if统计出满足某个判别式的元素个数</p>
</li>
<li><p>min_element, max_element获得区间最小值与最大值</p>
</li>
<li><p>accumulate适合更个个性化的统计处理，不在<code>&lt;algorithm&gt;</code>中，而是在<code>&lt;numeric&gt;</code>中</p>
<ul>
<li><p>形式一：两个迭代器和一个初始值，返回初始值加上区间值的和</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">double</span>&gt; ld;</span><br><span class="line"><span class="type">double</span> sum = <span class="built_in">accumulate</span>(ld.<span class="built_in">begin</span>(), ld.<span class="built_in">end</span>(), <span class="number">0.0</span>); <span class="comment">//注意要0.0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>形式二：两个迭代器和一个初始值，再加上一个处理函数，返回初始值与所有区间值的经过处理函数后的结果</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义处理函数函数</span></span><br><span class="line"><span class="function">string::size_type <span class="title">stringLengthSum</span><span class="params">(string::size_type sumSoFar, <span class="type">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sumSoFar + s.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">set&lt;string&gt; ss;</span><br><span class="line">string::size_type lengthSum = <span class="built_in">accumulate</span>(ss.<span class="built_in">begin</span>(), ss.<span class="built_in">end</span>(), <span class="built_in">static_cast</span>&lt;string::size_type&gt;(<span class="number">0</span>), stringLengthSum);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 标准multiplies仿函数</span></span><br><span class="line">vector&lt;<span class="type">float</span>&gt; vf;</span><br><span class="line"><span class="type">float</span>  product = <span class="built_in">accumulate</span>(vf.<span class="built_in">begin</span>(), vf.<span class="built_in">end</span>(), <span class="number">1.0f</span>, <span class="built_in">multiplies</span>&lt;<span class="type">float</span>&gt;());</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>For_each对区间每个元素执行操作，返回的是一个函数对象</p>
</li>
</ul>
<blockquote>
<p>作者更青睐于accumulate，而不是for_each</p>
</blockquote>
<h2 id="函数子、函数子类、函数及其他"><a href="#函数子、函数子类、函数及其他" class="headerlink" title="函数子、函数子类、函数及其他"></a>函数子、函数子类、函数及其他</h2><blockquote>
<p>函数子即仿函数（functor）</p>
</blockquote>
<h3 id="38-遵循按值传递的原则来设计函数子类"><a href="#38-遵循按值传递的原则来设计函数子类" class="headerlink" title="38. 遵循按值传递的原则来设计函数子类"></a>38. 遵循按值传递的原则来设计函数子类</h3><ul>
<li>由于函数对象往往按值传递和返回，所以得确保编写的函数对象在经过了传递之后还能正常工作</li>
<li>这意味着：<ul>
<li>函数对象尽可能小，否则复制开销昂贵</li>
<li>函数对象必须是单态的（不是多态的），即不能使用虚函数，否则如果形参是基类，实参是派生类，则传递过程中会产生剥离问题（slicing problem）</li>
</ul>
</li>
</ul>
<h3 id="39-确保判别式是纯函数"><a href="#39-确保判别式是纯函数" class="headerlink" title="39. 确保判别式是纯函数"></a>39. 确保判别式是纯函数</h3><ul>
<li>判别式（predicate）是一个返回值为bool类型的函数，标准关联容器的比较函数就是判别式，find_if等算法也用判别式来作为参数</li>
<li>纯函数（pure function）返回值仅依赖参数，即若x、y是两个对象，当且仅当x或y的值发生变化时，f(x,y)的值才会发生变化</li>
<li>判别式类（predicate class）是一个函数子类&#x2F;仿函数类，其operator()函数是一个判别式</li>
<li>为啥判别式得是纯函数？因为用做判别式的函数对象经常先被复制，然后存放起来以待之后使用，它不知道这段时间发生什么，如果不是纯函数，可能与预期结果不一致</li>
</ul>
<h3 id="40-若一个类是函数子，则应使它可配接"><a href="#40-若一个类是函数子，则应使它可配接" class="headerlink" title="40. 若一个类是函数子，则应使它可配接"></a>40. 若一个类是函数子，则应使它可配接</h3><h3 id="41-理解ptr-fun、mem-fun和mem-fun-ref的来由"><a href="#41-理解ptr-fun、mem-fun和mem-fun-ref的来由" class="headerlink" title="41. 理解ptr_fun、mem_fun和mem_fun_ref的来由"></a>41. 理解ptr_fun、mem_fun和mem_fun_ref的来由</h3><ul>
<li><p>For_each函数调用的是容器内对象的非成员函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> Function&gt;</span></span><br><span class="line"><span class="function">Function <span class="title">for_each</span><span class="params">(InputIterator begin, InputIterator end, Function f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (begin != end) <span class="built_in">f</span>(*begin++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(Widget&amp; w)</span></span>;</span><br><span class="line">vector&lt;Widget&gt; vw;</span><br><span class="line">for_each(vw.<span class="built_in">begin</span>(), vw.<span class="built_in">end</span>(), test); <span class="comment">// #1可以编译</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>但如果test函数是Widget的成员函数，简单传入成员函数不能编译</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for_each(vw.<span class="built_in">begin</span>(), vw.<span class="built_in">end</span>(), &amp;Widget::test); <span class="comment">// #2不能编译！</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>但如果用的是存放Widget*指针的容器，简单传入成员函数不能编译</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list&lt;Widget*&gt; lpw;</span><br><span class="line">for_each(lpw.<span class="built_in">begin</span>(), lpw.<span class="built_in">end</span>(), &amp;Widget::test); <span class="comment">// #3不能调用</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>总的来说，mem_fun适配语法#3，称为**函数对象适配器(function object adaptor)**，mem_fun带有一个到成员函数的指针 pmf 并返回一个mem_fun_t类型的对象。 是一个仿函数类 容纳成员函数指针， 并提供一个operator() ，在operator()中调用了通过参数传递进来的对象上的该成员函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> C&gt; <span class="comment">// 用于不带参数的non-const成员函数 mem_fun_t&lt;R,C&gt; // 的mem_fun声明。</span></span><br><span class="line"><span class="built_in">mem_fun</span>(<span class="built_in">R</span>(C::*pmf)()); <span class="comment">// C是类，R是被指向</span></span><br><span class="line"><span class="comment">// 的成员函数的返回类型</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>mem_fun_ref函数适配语法#2到语法#1，并产生mem_fun_ref_t类型的适配器对象</p>
</li>
<li><p>ptr_func在这里不需要使用，而mem_fun是针对成员函数（member function）的适配器，mem_fun_ref是针对对象容器的适配器，但取名不太雅致</p>
</li>
</ul>
<h3 id="42-确定less-lt-T-gt-表示operator-lt"><a href="#42-确定less-lt-T-gt-表示operator-lt" class="headerlink" title="42. 确定less&lt;T&gt;表示operator&lt;"></a>42. 确定<code>less&lt;T&gt;</code>表示<code>operator&lt;</code></h3><ul>
<li><p>假设Widget类有重量和最大速度两个属性，通常大家按照重量排序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Widget&amp; lhs, <span class="type">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">	<span class="keyword">return</span> lhs.<span class="built_in">weight</span>() &lt; rhs.<span class="built_in">weight</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果我们想建立按照最大速度排序的<code>mutiset&lt;Widget&gt;</code>，我们知道默认比较函数<code>less&lt;Widget&gt;</code>，而且我们知道默认的<code>less&lt;Widget&gt;</code>通过调用Widget的<code>operator&lt;</code>来工作，如果特化<code>less&lt;Widget&gt;</code>的默认比较函数，让它只关注Widget的最高速度</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">std</span>::less&lt;Widget&gt;:</span><br><span class="line"><span class="keyword">public</span> std::binary_function&lt;Widget,</span><br><span class="line"><span class="comment">// 这是一个std::less</span></span><br><span class="line"><span class="comment">// 的Widget的特化;</span></span><br><span class="line"><span class="comment">// 也是非常坏的主意</span></span><br><span class="line">Widget, <span class="type">bool</span>&gt; <span class="comment">// 关于这个基类更多</span></span><br><span class="line">&#123; <span class="comment">// 的信息参见条款40</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Widget&amp; lhs, <span class="type">const</span> Widget&amp; rhs)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> lhs.<span class="built_in">maxSpeed</span>() &lt; rhs.<span class="built_in">maxSpeed</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在程序员们的惯性思维中，operator+做加法，operator-做减法，operator&#x3D;&#x3D;做比较，而且less等价于使用operator&lt;，让less做operator&lt;意外的事情是对程序员预期的无故破坏，与最小惊讶原则相反</p>
</li>
<li><p>当然，对于std::less的特化还是有的，比如boost库的shared_ptr的一部分</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 这是一个用于boost::shared_ptr&lt;T&gt; struct less&lt;boost::shared_ptr&lt;T&gt; &gt;: // 的std::less的特化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="comment">// (boost是一个namespace) binary function&lt;boost::shared_ptr&lt;T&gt;,</span></span><br><span class="line">    boost::shared_ptr&lt;T&gt;,<span class="comment">// 这是惯例的</span></span><br><span class="line">    <span class="type">bool</span>&gt; &#123; <span class="comment">// 基类(参见条款40) bool operator()(const boost::shared_ptr&lt;T&gt;&amp; a,</span></span><br><span class="line">    <span class="type">const</span> boost::shared_ptr&lt;T&gt;&amp; b) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="built_in">less</span>&lt;T*&gt;()(a.<span class="built_in">get</span>(),b.<span class="built_in">get</span>()); <span class="comment">// shared_ptr::get返回</span></span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>正确的做法，新建一个仿函数类来进行比较</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MaxSpeedCompare</span>:</span><br><span class="line"><span class="keyword">public</span> binary_function&lt;Widget, Widget, <span class="type">bool</span>&gt; &#123;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Widget&amp; lhs, <span class="type">const</span> Widget&amp; rhs)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> lhs.<span class="built_in">maxSpeed</span>() &lt; rhs.<span class="built_in">maxSpeed</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">multiset&lt;Widget, MaxSpeedCompare&gt; widgets;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="使用STL编程"><a href="#使用STL编程" class="headerlink" title="使用STL编程"></a>使用STL编程</h2><h3 id="43-尽量用算法调用代替手写循环"><a href="#43-尽量用算法调用代替手写循环" class="headerlink" title="43. 尽量用算法调用代替手写循环"></a>43. 尽量用算法调用代替手写循环</h3><ul>
<li><p>STL算法内部都有循环，调用STL算法一般比手写循环更优</p>
</li>
<li><p>效率:算法通常比程序员产生的循环更高效。</p>
<ul>
<li>比如，手写循环每次遍历都要调用iter::end()函数检查是否到达末尾，而STL算法完全可以内联减少函数开销</li>
<li>再比如，库设计者知道最快的遍历方法，而库使用者不知道，举例：deque基于指针的遍历比基于迭代器的遍历更快</li>
<li>STL算法都在性能上达到了精益求精的地步，一般的程序员很难达到，即使是用erase-remove惯用法 所获得的性能也比程序员一般循环要好</li>
</ul>
</li>
<li><p>正确性:写循环时比调用算法更容易产生错误。</p>
</li>
<li><p>可维护性:算法通常使代码比相应的显式循环更干净、更直观。</p>
</li>
<li><p>当然，并不是绝对的， 出于编写的难易程度、可读性、可维护性，可能有时候手写循环会更加一目了然</p>
</li>
</ul>
<h3 id="44-容器的成员函数优先于同名算法"><a href="#44-容器的成员函数优先于同名算法" class="headerlink" title="44. 容器的成员函数优先于同名算法"></a>44. 容器的成员函数优先于同名算法</h3><ul>
<li>有些容器拥有和STL算法同名的成员函数。关联容器提供了count、find、lower_bound、upper_bound和 equal_range，而list提供了remove、remove_if、unique、sort、merge和reverse。大多数情况下，你应该用成员函 数代替算法。这样做有两个理由。首先，成员函数更快。其次，比起算法来，它们与容器结合得更好(尤其 是关联容器)。那是因为同名的算法和成员函数通常并不是是一样的。</li>
<li>比如，成员函数<code>set&lt;T&gt;::fin(xx)d</code>调用二分查找，时间复杂度O(logn)，同名STL算法<code>find(set&lt;T&gt;::iter_begin(), set&lt;T::iter_end(), xxx)</code>调用线性查找，时间复杂度O(n)</li>
<li>还有一个原因，关联容器使用『等价』来判断相同性，而STL算法使用『相等』来判断相同性，参见第19条款</li>
<li>特别是list，肯定要用它自己提供的成员函数，比如<code>list::erase</code>是实实在在地删除了元素，没有必要再调用<code>erase</code>了</li>
</ul>
<h3 id="45-注意count、find、binary-search、lower-bound、upper-bound-和equal-range的区别"><a href="#45-注意count、find、binary-search、lower-bound、upper-bound-和equal-range的区别" class="headerlink" title="45. 注意count、find、binary_search、lower_bound、upper_bound 和equal_range的区别"></a>45. 注意count、find、binary_search、lower_bound、upper_bound 和equal_range的区别</h3><ul>
<li><p>对于未排序的容器，查找都得线性，可供考虑的只有if与count，如果是想知道某个值在不在容器中，则find性能更好，因为找到就直接停止了</p>
<ul>
<li><p>count回答的问题是:“是否存在这个值，如果有，那么存在几份拷贝?”</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list&lt;Widget&gt; lw; <span class="comment">// Widget的list Widget w; // 特定的Widget值 ...</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">count</span>(lw.<span class="built_in">begin</span>(), lw.<span class="built_in">end</span>(), w)) &#123;</span><br><span class="line">... <span class="comment">// w在lw中 &#125; else &#123;</span></span><br><span class="line">... <span class="comment">// 不在 &#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>而find回答的问题 是:“是否存在，如果有，那么它在哪儿?”</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">find</span>(lw.<span class="built_in">begin</span>(), lw.<span class="built_in">end</span>(), w) != lw.<span class="built_in">end</span>()) &#123;</span><br><span class="line">... <span class="comment">// 找到了</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">... <span class="comment">// 没找到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>有序区间的搜索算法(binary_search、lower_bound、upper_bound和equal_range)是对数时间的</p>
<ul>
<li><p>binary_search回答这个问题:“它在吗?”不像标准C库中的(因此也是标准C++库中的) bsearch，binary_search只返回一个bool值</p>
</li>
<li><p>lower_bound回答这个问题:“它在吗?如果是，第一个拷贝在哪里?如果不是，它将在哪里？lower_bound返回一个迭代器，这个迭代器指向这个值的第一个拷贝(如果找到的话)或者到可以插入这个值的位置(如果没找到)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设我们有一个Timestamp类和一个Timestamp的vector，它按照老的timestamp放在前面 的方法排序</span></span><br><span class="line"><span class="comment">// 1. 现在假设我们有一个特殊的timestamp——ageLimit，而且我们从vt中删除所有比ageLimit老的timestamp。即我们需要在vt中找到一个位置:第一个不比ageLimit更老的元素</span></span><br><span class="line">vt.<span class="built_in">erase</span>(vt.<span class="built_in">begin</span>(), <span class="built_in">lower_bound</span>(vt.<span class="built_in">begin</span>(), <span class="comment">// 从vt中排除所有</span></span><br><span class="line">vt.<span class="built_in">end</span>(), <span class="comment">// 排在ageLimit的值 ageLimit)); // 前面的对象</span></span><br><span class="line">                                 </span><br><span class="line"><span class="comment">// 2. 我们要排除所有至少和ageLimit一样老的timestamp，也就是我们需要找到 第一个比ageLimit年轻的timestamp的位置</span></span><br><span class="line">                                 vt.<span class="built_in">erase</span>(vt.<span class="built_in">begin</span>(), <span class="built_in">upper_bound</span>(vt.<span class="built_in">begin</span>(), <span class="comment">// 从vt中除去所有 vt.end(), // 排在ageLimit的值前面 ageLimit)); // 或者等价的对象</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p>equal_range回答：“它在吗，如果是，那么在哪儿?”equal_range返回一对迭代器，第一个等于lower_bound返回的迭代 器，第二个等于upper_bound返回的(也就是，等价于要搜索值区间的末迭代器的下一个)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">VWIterPair p = <span class="built_in">equal_range</span>(vw.<span class="built_in">begin</span>(), vw.<span class="built_in">end</span>(), w);</span><br><span class="line"><span class="keyword">if</span> (p.first != p.second) &#123; <span class="comment">// 如果equal_range不返回</span></span><br><span class="line"><span class="comment">// 空的区间...</span></span><br><span class="line">... <span class="comment">// 说明找到了，p.first指向</span></span><br><span class="line"><span class="comment">// 第一个而p.second</span></span><br><span class="line"><span class="comment">// 指向最后一个的下一个</span></span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// 没找到，p.first与p.second都指向搜索值要插入的位置</span></span><br><span class="line"> &#125;</span><br><span class="line">  </span><br><span class="line"> <span class="comment">// equal_range很容易计数，调用distance算法即可</span></span><br><span class="line">  <span class="built_in">distance</span>(p.first, p.second)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当然，也许叫equivalent_range（因为是『等价』来判别相同性的）会更好，但叫equal_range也非常好</p>
</blockquote>
</li>
</ul>
</li>
<li><p>count与find算法都用『相等』来搜索，而binary_search、lower_bound、upper_bound和equal_range则用『等价』。</p>
</li>
<li><p>对于顺序容器，以上建议非常有用；对于关联容器（set, multiset, map, multimap），调用它们的成员函数往往比STL算法更好</p>
</li>
</ul>
<h3 id="46-考虑使用函数对象代替函数作算法的参数"><a href="#46-考虑使用函数对象代替函数作算法的参数" class="headerlink" title="46. 考虑使用函数对象代替函数作算法的参数"></a>46. 考虑使用函数对象代替函数作算法的参数</h3><ul>
<li><p>假设要降序排序一个double的vector，可以给sort算法传入函数对象，也可以传普通函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数对象</span></span><br><span class="line">vector&lt;<span class="type">double</span>&gt; v;</span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">double</span>&gt;());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span></span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">doubleGreater</span><span class="params">(<span class="type">double</span> d1, <span class="type">double</span> d2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> dl &gt; d2; </span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), doubleGreater);</span><br></pre></td></tr></table></figure>
</li>
<li><p>很多人可能会认为经过内联的普通函数要比函数对象要快，但是实际是函数对象更快，因为函数对象的operator()也是内联，编译器在模板实例化的时候内联了，所以第一个sort没有额外的函数调用。而第二个sort函数实际上传入了一个函数指针，编译器产生间接函数调用</p>
</li>
<li><p>把函数指针作为参数会抑制内联的事实解释了一个长期使用C的程序员经常发现却难以相信的现象:在速度 上，C++的sort实际上总是使C的qsort感到窘迫。当然，C++有函数、实例化的类模板和看起来很有趣的 operator()函数需要调用，而C只是进行简单的函数调用，但所有的C++“开销”都在编译期被吸收。在运行 期，sort内联调用它的比较函数(假设比较函数已经被声明为inline而且它的函数体在编译期可以得到)而 qsort通过一个指针调用它的比较函数。结果是sort运行得更快</p>
</li>
</ul>
<h3 id="47-避免产生直写型（write-only）代码"><a href="#47-避免产生直写型（write-only）代码" class="headerlink" title="47. 避免产生直写型（write-only）代码"></a>47. 避免产生直写型（write-only）代码</h3><ul>
<li>直写代码：很容易写，但很难读和理解</li>
<li>代码的读比写更经常，这是软件工程的真理。也就是说软件的维护比开发花费多得多的时间。不能读和理解 的软件不能被维护，不能维护的软件几乎没有不值得拥有</li>
</ul>
<h3 id="48-总是-include适当的头文件"><a href="#48-总是-include适当的头文件" class="headerlink" title="48. 总是#include适当的头文件"></a>48. 总是#include适当的头文件</h3><ul>
<li>几乎所有的容器都在同名的头文件里，比如，vector在<vector>中声明，list在<list>中声明等。例外的是<set>和<map>。<set>声明了set和multiset，<map>声明了map和multimap。</li>
<li>除了四个算法外，所有的算法都在<algorithm>中声明。例外的是accumulate(参见条款37)、 inner_product、adjacent_difference和partial_sum。这些算法在<numeric>中声明。</li>
<li>特殊的迭代器，包括istream_iterators和istreambuf_iterators(参见条款29)，在<iterator>中声明。</li>
<li>标准仿函数(比如less<T>)和仿函数适配器(比如not1、bind2nd)在<functional>中声明。</li>
</ul>
<h3 id="49-学习破解有关STL的编译器诊断信息"><a href="#49-学习破解有关STL的编译器诊断信息" class="headerlink" title="49. 学习破解有关STL的编译器诊断信息"></a>49. 学习破解有关STL的编译器诊断信息</h3><ul>
<li><p>string没有带int参数的构造函数，编译器报错如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">example.<span class="built_in">cpp</span>(<span class="number">20</span>): error C2664:<span class="string">&#x27;__thiscall std::basic_string&lt;char, struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt;::std::basic_string&lt;char, struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt;(const class std::allocator&lt;char&gt; &amp;)&#x27;</span>: cannot convert parameter <span class="number">1</span> from <span class="string">&#x27;const int&#x27;</span> to <span class="string">&#x27;const class std::allocator&lt;char&gt; &amp;&#x27;</span> Reason: cannot convert from <span class="string">&#x27;const int&#x27;</span> to <span class="string">&#x27;const class std::allocator&lt;char&gt;</span></span><br><span class="line"><span class="string">No constructor could take the source type, or constructor overload resolution was ambiguous</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>string不是一个类，它是一个typedef，这是因为字符串的C++观念已经被泛化为表示<strong>带有任意字符特性(“traits”)<strong>的</strong>任意字符类型的序列</strong>并储存 在以<strong>任意分配器分类的内存</strong>中。在C++里所有类似字符串的对象实际上都是basic_string模板的实例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">basic_string&lt;<span class="type">char</span>, char_traits&lt;<span class="type">char</span>&gt;, allocator&lt;<span class="type">char</span>&gt; &gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据具体平台，下面报错信息更加常见，在脑子里面替换为std::string即可</span></span><br><span class="line">std::basic_string&lt;<span class="type">char</span>, <span class="keyword">struct</span> <span class="title class_">std</span>::char_traits&lt;<span class="type">char</span>&gt;, <span class="keyword">class</span> <span class="title class_">std</span>::allocator&lt;<span class="type">char</span>&gt; &gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>几乎所有STL实现都使用某种内在的模板来实现标准关联容器(set、multiset、map和multimap)。就 像使用string的源代码通常导致诊断信息提及basic_string一样，使用标准关联容器的源代码经常会导致诊断信 息提及一些内在的树模板，比如<code>std::_Tree</code>, <code>std::_tree</code>, <code>std::_rb_tree</code></p>
</li>
<li><p>对于vector和string，迭代器有时是指针，所以如果你用迭代器犯了错误，编译器诊断信息可能会提及 涉及指针类型。例如，如果你的源代码涉及vector<double>::iterator，编译器消息有时会提及double*指 针。</p>
</li>
<li><p>提到back_insert_iterator、front_insert_iterator或insert_iterator的消息经常意味着你错误调用了 back_inserter、front_inserter或inserter，一一对应，</p>
</li>
<li><p>类似地，如果你得到的一条消息提及binder1st或binder2nd，你或许错误地使用了bind1st或bind2nd。 (bind1st返回binder1st类型的对象，而bind2nd返回binder2nd类型的对象。</p>
</li>
<li><p>输出迭代器(例如ostream_iterator、ostreambuf_iterators(参见条款29)，和从back_inserter、 front_inserter和inserter返回的迭代器)在赋值操作符内部做输出或插入工作，所以如果你错误使用了 这些迭代器类型之一，你很可能得到一条消息，抱怨在你从未听说过的一个赋值操作符里的某个东西</p>
</li>
<li><p>你得到一条源于STL算法实现内部的错误信息(即，源代码引发的错误在<algorithm>中)，也许是你 试图给那算法用的类型出错了。例如，你可能传了错误种类的迭代器</p>
</li>
<li><p>你使用常见的STL组件比如vector、string或for_each算法，而编译器说不知道你在说什么，你也许没有 #include一个需要的头文件</p>
</li>
</ul>
<h3 id="50-让你自己熟悉有关STL的网站"><a href="#50-让你自己熟悉有关STL的网站" class="headerlink" title="50. 让你自己熟悉有关STL的网站"></a>50. 让你自己熟悉有关STL的网站</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://edisonleolhl.github.io">一个廖少少</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://edisonleolhl.github.io/2022/05/10/Effective%20C++%20&amp;&amp;%20More%20Effective%20C++/">https://edisonleolhl.github.io/2022/05/10/Effective%20C++%20&amp;&amp;%20More%20Effective%20C++/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://edisonleolhl.github.io" target="_blank">一知半解</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/images/avatar.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/05/11/Python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="Python基础知识"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Python基础知识</div></div></a></div><div class="next-post pull-right"><a href="/2022/04/14/C++%E6%8E%92%E6%9F%A5%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%AD%A5%E9%AA%A4/" title="C++排查派生类内存泄漏步骤"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">C++排查派生类内存泄漏步骤</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/avatar.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">一个廖少少</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">47</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">49</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/edisonleolhl"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/edisonleolhl" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:edisonleolhl@foxmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://www.jianshu.com/u/28b41b12cde8" target="_blank" title="jianshu"><i class="fas fa-link" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Go Big or Go Home</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Effective-C"><span class="toc-number">1.</span> <span class="toc-text">Effective C++</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Accustoming-Yourself-to-C"><span class="toc-number">1.1.</span> <span class="toc-text">1. Accustoming Yourself to C++</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-1-View-C-as-a-federation-of-languages"><span class="toc-number">1.1.1.</span> <span class="toc-text">Item 1: View C++ as a federation of languages</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-2-Prefer-consts-enums-and-inlines-to-defines"><span class="toc-number">1.1.2.</span> <span class="toc-text">Item 2: Prefer consts, enums, and inlines to #defines</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-3-Use-const-whenever-possible"><span class="toc-number">1.1.3.</span> <span class="toc-text">Item 3: Use const whenever possible</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-4-Make-sure-that-objects-are-initialized-before-they%E2%80%99re-used"><span class="toc-number">1.1.4.</span> <span class="toc-text">Item 4: Make sure that objects are initialized before they’re used</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Constructors-Destructors-and-Assignment-Operators"><span class="toc-number">1.2.</span> <span class="toc-text">2. Constructors, Destructors, and Assignment Operators</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-5-Know-what-functions-C-silently-writes-and-calls"><span class="toc-number">1.2.1.</span> <span class="toc-text">Item 5: Know what functions C++ silently writes and calls</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-6-Explicitly-disallow-the-use-of-compiler-generated-functions-you-do-not-want"><span class="toc-number">1.2.2.</span> <span class="toc-text">Item 6: Explicitly disallow the use of compiler-generated functions you do not want</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-7-Declare-destructors-virtual-in-polymorphic-base-classes"><span class="toc-number">1.2.3.</span> <span class="toc-text">Item 7: Declare destructors virtual in polymorphic base classes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-8-Prevent-exceptions-from-leaving-destructors"><span class="toc-number">1.2.4.</span> <span class="toc-text">Item 8: Prevent exceptions from leaving destructors</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-9-Never-call-virtual-functions-during-construction-or-destruction"><span class="toc-number">1.2.5.</span> <span class="toc-text">Item 9: Never call virtual functions during construction or destruction</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-10-Have-assignment-operators-return-a-reference-to-this"><span class="toc-number">1.2.6.</span> <span class="toc-text">Item 10: Have assignment operators return a reference to *this</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-11-Handle-assignment-to-self-in-operator"><span class="toc-number">1.2.7.</span> <span class="toc-text">Item 11: Handle assignment to self in operator&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-12-Copy-all-parts-of-an-object"><span class="toc-number">1.2.8.</span> <span class="toc-text">Item 12: Copy all parts of an object</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Resource-Management"><span class="toc-number">1.3.</span> <span class="toc-text">Resource Management</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-13-Use-objects-to-manage-resources-%EF%BC%88RAII%EF%BC%9AResource-Acquisition-Is-Initialization%EF%BC%89"><span class="toc-number">1.3.1.</span> <span class="toc-text">Item 13: Use objects to manage resources.（RAII：Resource Acquisition Is Initialization）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-14-Think-carefully-about-copying-behavior-in-resource-managing-classes"><span class="toc-number">1.3.2.</span> <span class="toc-text">Item 14: Think carefully about copying behavior in resource-managing classes.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-15-Provide-access-to-raw-resources-in-resource-managing-classes"><span class="toc-number">1.3.3.</span> <span class="toc-text">Item 15: Provide access to raw resources in resource-managing classes.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-16-Use-the-same-form-in-corresponding-uses-of-new-and-delete"><span class="toc-number">1.3.4.</span> <span class="toc-text">Item 16: Use the same form in corresponding uses of new and delete.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-17-Store-newed-objects-in-smart-pointers-in-standalone-statements"><span class="toc-number">1.3.5.</span> <span class="toc-text">Item 17: Store newed objects in smart pointers in standalone statements.</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Designs-and-Declarations"><span class="toc-number">1.4.</span> <span class="toc-text">Designs and Declarations</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-18-Make-interfaces-easy-to-use-correctly-and-hard-to-use-incorrectly"><span class="toc-number">1.4.1.</span> <span class="toc-text">Item 18: Make interfaces easy to use correctly and hard to use incorrectly</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-19-Treat-class-design-as-type-design"><span class="toc-number">1.4.2.</span> <span class="toc-text">Item 19: Treat class design as type design</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-20-Prefer-pass-by-reference-to-const-to-pass-by-value"><span class="toc-number">1.4.3.</span> <span class="toc-text">Item 20: Prefer pass-by-reference-to-const to pass-by-value</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-21-Don%E2%80%99t-try-to-return-a-reference-when-you-must-return-an-object"><span class="toc-number">1.4.4.</span> <span class="toc-text">Item 21: Don’t try to return a reference when you must return an object</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-22-Declare-data-members-private"><span class="toc-number">1.4.5.</span> <span class="toc-text">Item 22: Declare data members private</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-23-Prefer-non-member-non-friend-functions-to-member-functions"><span class="toc-number">1.4.6.</span> <span class="toc-text">Item 23: Prefer non-member non-friend functions to member functions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-24-Declare-non-member-functions-when-type-conversions-should-apply-to-all-parameters"><span class="toc-number">1.4.7.</span> <span class="toc-text">Item 24: Declare non-member functions when type conversions should apply to all parameters</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-25-Consider-support-for-a-non-throwing-swap"><span class="toc-number">1.4.8.</span> <span class="toc-text">Item 25: Consider support for a non-throwing swap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-26-Postpone-variable-definitions-as-long-as-possible"><span class="toc-number">1.4.9.</span> <span class="toc-text">Item 26: Postpone variable definitions as long as possible.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-27-Minimize-casting"><span class="toc-number">1.4.10.</span> <span class="toc-text">Item 27: Minimize casting.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-28-Avoid-returning-%E2%80%9Chandles%E2%80%9D-to-object-internals"><span class="toc-number">1.4.11.</span> <span class="toc-text">Item 28: Avoid returning “handles” to object internals.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-29-Strive-for-exception-safe-code"><span class="toc-number">1.4.12.</span> <span class="toc-text">Item 29: Strive for exception-safe code.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-30-Understand-the-ins-and-outs-of-inlining"><span class="toc-number">1.4.13.</span> <span class="toc-text">Item 30: Understand the ins and outs of inlining.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-31-Minimize-compilation-dependencies-between-files"><span class="toc-number">1.4.14.</span> <span class="toc-text">Item 31: Minimize compilation dependencies between files</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Inheritance-and-Object-Oriented-Design"><span class="toc-number">1.5.</span> <span class="toc-text">6. Inheritance and Object-Oriented Design</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-32-Make-sure-public-inheritance-models-%E2%80%9Cis-a-%E2%80%9D"><span class="toc-number">1.5.1.</span> <span class="toc-text">Item 32: Make sure public inheritance models “is-a.”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-33-Avoid-hiding-inherited-names"><span class="toc-number">1.5.2.</span> <span class="toc-text">Item 33: Avoid hiding inherited names</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-34-Differentiate-between-inheritance-of-interface-and-inheritance-of-implementation"><span class="toc-number">1.5.3.</span> <span class="toc-text">Item 34: Differentiate between inheritance of interface and inheritance of implementation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-35-Consider-alternatives-to-virtual-functions"><span class="toc-number">1.5.4.</span> <span class="toc-text">Item 35: Consider alternatives to virtual functions</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#NVI-x2F-Tmpelate-Method"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">NVI &#x2F; Tmpelate Method</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.5.4.2.</span> <span class="toc-text">策略模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87tr1-function%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.5.4.3.</span> <span class="toc-text">通过tr1::function实现的策略模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-36-Never-redefine-an-inherited-non-virtual-function"><span class="toc-number">1.5.5.</span> <span class="toc-text">Item 36: Never redefine an inherited non-virtual function</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-37-Never-redefine-a-function%E2%80%99s-inherited-default-parameter-value"><span class="toc-number">1.5.6.</span> <span class="toc-text">Item 37: Never redefine a function’s inherited default parameter value</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-38-Model-%E2%80%9Chas-a%E2%80%9D-or-%E2%80%9Cis-implemented-in-terms-of%E2%80%9D-through-composition"><span class="toc-number">1.5.7.</span> <span class="toc-text">Item 38: Model “has-a” or “is-implemented-in-terms-of” through composition</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-39-Use-private-inheritance-judiciously%EF%BC%88%E5%AE%A1%E6%85%8E%E5%9C%B0%EF%BC%89"><span class="toc-number">1.5.8.</span> <span class="toc-text">Item 39: Use private inheritance judiciously（审慎地）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-40-Use-multiple-inheritance-judiciously"><span class="toc-number">1.5.9.</span> <span class="toc-text">Item 40: Use multiple inheritance judiciously</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Templates-and-Generic-Programming"><span class="toc-number">1.6.</span> <span class="toc-text">7. Templates and Generic Programming</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-41-Understand-implicit-interfaces-and-compile-time-polymorphism"><span class="toc-number">1.6.1.</span> <span class="toc-text">Item 41: Understand implicit interfaces and compile-time polymorphism</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-42-Understand-the-two-meanings-of-typename"><span class="toc-number">1.6.2.</span> <span class="toc-text">Item 42: Understand the two meanings of typename</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-43-Know-how-to-access-names-in-templatized-base-classes"><span class="toc-number">1.6.3.</span> <span class="toc-text">Item 43: Know how to access names in templatized base classes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-44-Factor-parameter-independent-code-out-of-templates"><span class="toc-number">1.6.4.</span> <span class="toc-text">Item 44: Factor parameter-independent code out of templates</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-45-Use-member-function-templates-to-accept-%E2%80%9Call-compatible-types-%E2%80%9D"><span class="toc-number">1.6.5.</span> <span class="toc-text">Item 45: Use member function templates to accept “all compatible types.”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-46-Define-non-member-functions-inside-templates-when-type-conversions-are-desired"><span class="toc-number">1.6.6.</span> <span class="toc-text">Item 46: Define non-member functions inside templates when type conversions are desired</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-47-Use-traits-classes-for-information-about-types"><span class="toc-number">1.6.7.</span> <span class="toc-text">Item 47: Use traits classes for information about types</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-48-Be-aware-of-template-metaprogramming"><span class="toc-number">1.6.8.</span> <span class="toc-text">Item 48: Be aware of template metaprogramming</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-Customizing-new-and-delete"><span class="toc-number">1.7.</span> <span class="toc-text">8. Customizing new and delete</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-49-Understand-the-behavior-of-the-new-handler"><span class="toc-number">1.7.1.</span> <span class="toc-text">Item 49: Understand the behavior of the new-handler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-50-Understand-when-it-makes-sense-to-replace-new-and-delete"><span class="toc-number">1.7.2.</span> <span class="toc-text">Item 50: Understand when it makes sense to replace new and delete</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-51-Adhere-to-convention-when-writing-new-and-delete"><span class="toc-number">1.7.3.</span> <span class="toc-text">Item 51: Adhere to convention when writing new and delete</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-52-Write-placement-delete-if-you-write-placement-new"><span class="toc-number">1.7.4.</span> <span class="toc-text">Item 52: Write placement delete if you write placement new</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-Miscellany"><span class="toc-number">1.8.</span> <span class="toc-text">9. Miscellany</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-53-Pay-attention-to-compiler-warnings"><span class="toc-number">1.8.1.</span> <span class="toc-text">Item 53: Pay attention to compiler warnings</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-54-Familiarize-yourself-with-the-standard-library-including-TR1"><span class="toc-number">1.8.2.</span> <span class="toc-text">Item 54: Familiarize yourself with the standard library, including TR1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-55-Familiarize-yourself-with-Boost"><span class="toc-number">1.8.3.</span> <span class="toc-text">Item 55: Familiarize yourself with Boost.</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#More-Effective-C"><span class="toc-number">2.</span> <span class="toc-text">More Effective C++</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Basics"><span class="toc-number">2.1.</span> <span class="toc-text">Basics</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-1-Distinguish-between-pointers-and-references"><span class="toc-number">2.1.1.</span> <span class="toc-text">Item 1:  Distinguish between pointers and references.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-2-Prefer-C-style-casts"><span class="toc-number">2.1.2.</span> <span class="toc-text">**Item 2:**Prefer C++-style casts.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-3-Never-treat-arrays-polymorphically"><span class="toc-number">2.1.3.</span> <span class="toc-text">**Item 3:**Never treat arrays polymorphically.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-4-Avoid-gratuitous-default-constructors"><span class="toc-number">2.1.4.</span> <span class="toc-text">Item 4: Avoid gratuitous default constructors.</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Operators"><span class="toc-number">2.2.</span> <span class="toc-text">Operators</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-5-Be-wary-of-user-defined-conversion-functions"><span class="toc-number">2.2.1.</span> <span class="toc-text">Item 5: Be wary of user-defined conversion functions.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-6-Distinguish-between-prefix-and-postfix-forms-of-increment-and-decrement-operators"><span class="toc-number">2.2.2.</span> <span class="toc-text">Item 6: Distinguish between prefix and postfix forms of increment and decrement operators.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-7-Never-overload-amp-amp-or"><span class="toc-number">2.2.3.</span> <span class="toc-text">Item 7: Never overload &amp;&amp;, ||, or ,.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-8-Understand-the-different-meanings-of-new-and-delete"><span class="toc-number">2.2.4.</span> <span class="toc-text">Item 8: Understand the different meanings of new and delete.</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Exceptions"><span class="toc-number">2.3.</span> <span class="toc-text">Exceptions</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-9-Use-destructors-to-prevent-resource-leaks"><span class="toc-number">2.3.1.</span> <span class="toc-text">Item 9: Use destructors to prevent resource leaks.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-10-Prevent-resource-leaks-in-constructors"><span class="toc-number">2.3.2.</span> <span class="toc-text">Item 10: Prevent resource leaks in constructors.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-11-Prevent-exceptions-from-leaving-destructors"><span class="toc-number">2.3.3.</span> <span class="toc-text">Item 11: Prevent exceptions from leaving destructors.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-12-Understand-how-throwing-an-exception-differs-from-passing-a-parameter-or-calling-a-virtual-function"><span class="toc-number">2.3.4.</span> <span class="toc-text">Item 12: Understand how throwing an exception differs from passing a parameter or calling a virtual function.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-13-Catch-exceptions-by-reference"><span class="toc-number">2.3.5.</span> <span class="toc-text">Item 13: Catch exceptions by reference.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-14-Use-exception-specifications-judiciously"><span class="toc-number">2.3.6.</span> <span class="toc-text">Item 14: Use exception specifications judiciously.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-15-Understand-the-costs-of-exception-handling"><span class="toc-number">2.3.7.</span> <span class="toc-text">Item 15: Understand the costs of exception handling.</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Efficiency"><span class="toc-number">2.4.</span> <span class="toc-text">Efficiency</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-16-Remember-the-80-20-rule"><span class="toc-number">2.4.1.</span> <span class="toc-text">Item 16: Remember the 80-20 rule.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-17-Consider-using-lazy-evaluation"><span class="toc-number">2.4.2.</span> <span class="toc-text">Item 17: Consider using lazy evaluation.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-18-Amortize-the-cost-of-expected-computations"><span class="toc-number">2.4.3.</span> <span class="toc-text">Item 18: Amortize the cost of expected computations.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-19-Understand-the-origin-of-temporary-objects"><span class="toc-number">2.4.4.</span> <span class="toc-text">Item 19: Understand the origin of temporary objects.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-20-Facilitate-the-return-value-optimization"><span class="toc-number">2.4.5.</span> <span class="toc-text">Item 20: Facilitate the return value optimization.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-21-Overload-to-avoid-implicit-type-conversions"><span class="toc-number">2.4.6.</span> <span class="toc-text">Item 21: Overload to avoid implicit type conversions.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-22-Consider-using-op-x3D-instead-of-stand-alone-op"><span class="toc-number">2.4.7.</span> <span class="toc-text">Item 22: Consider using op&#x3D; instead of stand-alone op.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-23-Consider-alternative-libraries"><span class="toc-number">2.4.8.</span> <span class="toc-text">Item 23: Consider alternative libraries.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-24-Understand-the-costs-of-virtual-functions-multiple-inheritance-virtual-base-classes-and-RTTI"><span class="toc-number">2.4.9.</span> <span class="toc-text">Item 24: Understand the costs of virtual functions, multiple inheritance, virtual base classes, and RTTI.</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.9.1.</span> <span class="toc-text">虚函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-number">2.4.9.2.</span> <span class="toc-text">多重继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RTTI%EF%BC%88Runtime-Type-Identification"><span class="toc-number">2.4.9.3.</span> <span class="toc-text">RTTI（Runtime Type Identification)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Techniques"><span class="toc-number">2.5.</span> <span class="toc-text">Techniques</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-25-Virtualizing-constructors-and-non-member-functions"><span class="toc-number">2.5.1.</span> <span class="toc-text">Item 25: Virtualizing constructors and non-member functions.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-26-Limiting-the-number-of-objects-of-a-class"><span class="toc-number">2.5.2.</span> <span class="toc-text">Item 26: Limiting the number of objects of a class.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-27-Requiring-or-prohibiting-heap-based-objects"><span class="toc-number">2.5.3.</span> <span class="toc-text">Item 27: Requiring or prohibiting heap-based objects.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-28-Smart-pointers"><span class="toc-number">2.5.4.</span> <span class="toc-text">Item 28: Smart pointers.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-29-Reference-counting"><span class="toc-number">2.5.5.</span> <span class="toc-text">Item 29: Reference counting.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-30-Proxy-classes"><span class="toc-number">2.5.6.</span> <span class="toc-text">Item 30: Proxy classes.</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Miscellany"><span class="toc-number">2.6.</span> <span class="toc-text">Miscellany</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-31-Making-functions-virtual-with-respect-to-more-than-one-object"><span class="toc-number">2.6.1.</span> <span class="toc-text">Item 31: Making functions virtual with respect to more than one object.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-32-Program-in-the-future-tense"><span class="toc-number">2.6.2.</span> <span class="toc-text">Item 32: Program in the future tense.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-33-Make-non-leaf-classes-abstract"><span class="toc-number">2.6.3.</span> <span class="toc-text">Item 33: Make non-leaf classes abstract.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-34-Understand-how-to-combine-C-and-C-in-the-same-program"><span class="toc-number">2.6.4.</span> <span class="toc-text">Item 34: Understand how to combine C++ and C in the same program.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-35-Familiarize-yourself-with-the-language-standard"><span class="toc-number">2.6.5.</span> <span class="toc-text">Item 35: Familiarize yourself with the language standard.</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Effective-STL"><span class="toc-number">3.</span> <span class="toc-text">Effective STL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8"><span class="toc-number">3.1.</span> <span class="toc-text">容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%85%8E%E9%87%8D%E9%80%89%E6%8B%A9%E5%AE%B9%E5%99%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.1.</span> <span class="toc-text">1. 慎重选择容器类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%8D%E8%A6%81%E8%AF%95%E5%9B%BE%E7%BC%96%E5%86%99%E7%8B%AC%E7%AB%8B%E4%BA%8E%E5%AE%B9%E5%99%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number">3.1.2.</span> <span class="toc-text">2. 不要试图编写独立于容器类型的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%A1%AE%E4%BF%9D%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D%E6%AD%A3%E7%A1%AE%E8%80%8C%E9%AB%98%E6%95%88"><span class="toc-number">3.1.3.</span> <span class="toc-text">3. 确保容器中的对象拷贝正确而高效</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%B0%83%E7%94%A8empty-%E8%80%8C%E4%B8%8D%E6%98%AF%E6%A3%80%E6%9F%A5size-%E6%98%AF%E5%90%A6%E4%B8%BA0"><span class="toc-number">3.1.4.</span> <span class="toc-text">4. 调用empty()而不是检查size()是否为0</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%8C%BA%E9%97%B4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%BC%98%E5%85%88%E4%BA%8E%E5%8D%95%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">3.1.5.</span> <span class="toc-text">5. 区间成员函数优先于单成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%BD%93%E5%BF%83C-%E7%BC%96%E8%AF%91%E5%99%A8%E6%9C%80%E7%83%A6%E4%BA%BA%E7%9A%84%E5%88%86%E6%9E%90%E6%9C%BA%E5%88%B6"><span class="toc-number">3.1.6.</span> <span class="toc-text">6. 当心C++编译器最烦人的分析机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%A6%82%E6%9E%9C%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%AD%98%E6%94%BE%E4%BA%86new%E5%87%BA%E6%9D%A5%E7%9A%84%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%9C%A8%E6%9E%90%E6%9E%84%E6%97%B6%E8%AE%B0%E5%BE%97%E6%89%8B%E5%8A%A8%E8%B0%83%E7%94%A8delete%E9%87%8A%E6%94%BE"><span class="toc-number">3.1.7.</span> <span class="toc-text">7. 如果容器中存放了new出来的对象，在析构时记得手动调用delete释放</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%88%87%E5%8B%BF%E5%88%9B%E5%BB%BA%E5%8C%85%E5%90%ABauto-ptr%E7%9A%84%E5%AE%B9%E5%99%A8%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.1.8.</span> <span class="toc-text">8. 切勿创建包含auto_ptr的容器对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E6%85%8E%E9%87%8D%E9%80%89%E6%8B%A9%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.9.</span> <span class="toc-text">9. 慎重选择删除元素的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E4%BA%86%E8%A7%A3%E5%88%86%E9%85%8D%E5%AD%90%EF%BC%88allocator%EF%BC%89%E7%9A%84%E9%99%90%E5%88%B6%E4%B8%8E%E7%BA%A6%E5%AE%9A"><span class="toc-number">3.1.10.</span> <span class="toc-text">10. 了解分配子（allocator）的限制与约定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E7%90%86%E8%A7%A3%E8%87%AA%E5%AE%9A%E4%B9%89allocator%E7%9A%84%E5%90%88%E7%90%86%E7%94%A8%E6%B3%95"><span class="toc-number">3.1.11.</span> <span class="toc-text">11. 理解自定义allocator的合理用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E5%88%87%E5%8B%BF%E4%BE%9D%E8%B5%96STL%E5%AE%B9%E5%99%A8%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">3.1.12.</span> <span class="toc-text">12. 切勿依赖STL容器的线程安全性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vector%E5%92%8Cstring"><span class="toc-number">3.2.</span> <span class="toc-text">vector和string</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-vector%E5%92%8Cstring%E4%BC%98%E5%85%88%E4%BA%8E%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E7%9A%84%E6%95%B0%E7%BB%84"><span class="toc-number">3.2.1.</span> <span class="toc-text">13. vector和string优先于动态分配的数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E4%BD%BF%E7%94%A8reserve%E6%9D%A5%E5%87%8F%E5%B0%91%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E5%86%85%E5%AD%98%E9%87%8D%E6%96%B0%E5%88%86%E9%85%8D"><span class="toc-number">3.2.2.</span> <span class="toc-text">14. 使用reserve来减少不必要的内存重新分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E6%B3%A8%E6%84%8Fstring%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%A4%9A%E6%A0%B7%E6%80%A7"><span class="toc-number">3.2.3.</span> <span class="toc-text">15. 注意string实现的多样性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E4%BA%86%E8%A7%A3%E5%A6%82%E4%BD%95%E6%8A%8Avector%E5%92%8Cstring%E6%95%B0%E6%8D%AE%E4%BC%A0%E7%BB%99%E6%97%A7%E7%9A%84API"><span class="toc-number">3.2.4.</span> <span class="toc-text">16. 了解如何把vector和string数据传给旧的API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E4%BD%BF%E7%94%A8swap%E6%8A%80%E5%B7%A7%E5%8E%BB%E9%99%A4%E5%A4%9A%E4%BD%99%E7%9A%84%E5%AE%B9%E9%87%8F%EF%BC%88C-11%E5%B7%B2%E6%9C%89shrink-to-fit%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.5.</span> <span class="toc-text">17. 使用swap技巧去除多余的容量（C++11已有shrink-to-fit方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8vector-lt-bool-gt"><span class="toc-number">3.2.6.</span> <span class="toc-text">18. 避免使用vector&lt;bool&gt;</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8"><span class="toc-number">3.3.</span> <span class="toc-text">关联容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#19-%E7%90%86%E8%A7%A3%E7%9B%B8%E7%AD%89%EF%BC%88equality%EF%BC%89%E5%92%8C%E7%AD%89%E4%BB%B7%EF%BC%88equivalence%EF%BC%89%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.3.1.</span> <span class="toc-text">19. 理解相等（equality）和等价（equivalence）的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-%E4%B8%BA%E5%8C%85%E5%90%AB%E6%8C%87%E9%92%88%E7%9A%84%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E6%8C%87%E5%AE%9A%E6%AF%94%E8%BE%83%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.3.2.</span> <span class="toc-text">20. 为包含指针的关联容器指定比较类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E6%80%BB%E6%98%AF%E8%AE%A9%E6%AF%94%E8%BE%83%E5%87%BD%E6%95%B0%E5%9C%A8%E7%9B%B8%E7%AD%89%E6%97%B6%E5%80%99%E8%BF%94%E5%9B%9Efalse"><span class="toc-number">3.3.3.</span> <span class="toc-text">21. 总是让比较函数在相等时候返回false</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E5%88%87%E5%8B%BF%E7%9B%B4%E6%8E%A5%E4%BF%AE%E6%94%B9set%E6%88%96multiset%E7%9A%84%E9%94%AE"><span class="toc-number">3.3.4.</span> <span class="toc-text">22. 切勿直接修改set或multiset的键</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E8%80%83%E8%99%91%E7%94%A8%E6%8E%92%E5%BA%8F%E7%9A%84vector%E6%9B%BF%E4%BB%A3%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8"><span class="toc-number">3.3.5.</span> <span class="toc-text">23. 考虑用排序的vector替代关联容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%E6%95%88%E7%8E%87%E8%87%B3%E5%85%B3%E9%87%8D%E8%A6%81%E6%97%B6%EF%BC%8C%E5%9C%A8map-operator-%E4%B8%8Emap-insert%E4%B8%AD%E8%B0%A8%E6%85%8E%E9%80%89%E6%8B%A9"><span class="toc-number">3.3.6.</span> <span class="toc-text">24. 效率至关重要时，在map::operator[]与map::insert中谨慎选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-%E7%86%9F%E6%82%89%E9%9D%9E%E6%A0%87%E5%87%86%E7%9A%84%E6%95%A3%E5%88%97%E5%AE%B9%E5%99%A8"><span class="toc-number">3.3.7.</span> <span class="toc-text">25. 熟悉非标准的散列容器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">3.4.</span> <span class="toc-text">迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#26-%E5%B0%BD%E9%87%8F%E7%94%A8iterator%E4%BB%A3%E6%9B%BFconst-iterator%E3%80%81-reverse-iterator%E5%92%8Cconst-reverse-iterator"><span class="toc-number">3.4.1.</span> <span class="toc-text">26. 尽量用iterator代替const_iterator、 reverse_iterator和const_reverse_iterator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-%E7%94%A8distance%E5%92%8Cadvance%E6%8A%8Aconst-iterator%E8%BD%AC%E5%8C%96%E6%88%90iterator"><span class="toc-number">3.4.2.</span> <span class="toc-text">27. 用distance和advance把const_iterator转化成iterator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-%E4%BA%86%E8%A7%A3%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87reverse-iterator%E7%9A%84base%E5%BE%97%E5%88%B0iterator"><span class="toc-number">3.4.3.</span> <span class="toc-text">28. 了解如何通过reverse_iterator的base得到iterator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-%E9%9C%80%E8%A6%81%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E6%97%B6%E8%80%83%E8%99%91%E4%BD%BF%E7%94%A8istreambuf-iterator"><span class="toc-number">3.4.4.</span> <span class="toc-text">29. 需要一个一个字符输入时考虑使用istreambuf_iterator</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-number">3.5.</span> <span class="toc-text">算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#30-%E7%A1%AE%E4%BF%9D%E7%9B%AE%E6%A0%87%E5%8C%BA%E9%97%B4%E8%B6%B3%E5%A4%9F%E5%A4%A7"><span class="toc-number">3.5.1.</span> <span class="toc-text">30. 确保目标区间足够大</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31-%E4%BA%86%E8%A7%A3%E4%BD%A0%E7%9A%84%E6%8E%92%E5%BA%8F%E9%80%89%E6%8B%A9"><span class="toc-number">3.5.2.</span> <span class="toc-text">31. 了解你的排序选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-%E5%A6%82%E6%9E%9C%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%83%B3%E5%88%A0%E9%99%A4%E4%B8%9C%E8%A5%BF%E7%9A%84%E8%AF%9D%E5%B0%B1%E5%9C%A8%E7%B1%BB%E4%BC%BCremove%E7%9A%84%E7%AE%97%E6%B3%95%E5%90%8E%E6%8E%A5%E4%B8%8Aerase"><span class="toc-number">3.5.3.</span> <span class="toc-text">32. 如果你真的想删除东西的话就在类似remove的算法后接上erase</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-%E6%8F%90%E9%98%B2%E5%9C%A8%E6%8C%87%E9%92%88%E7%9A%84%E5%AE%B9%E5%99%A8%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%B1%BB%E4%BC%BCremove%E7%9A%84%E7%AE%97%E6%B3%95"><span class="toc-number">3.5.4.</span> <span class="toc-text">33. 提防在指针的容器上使用类似remove的算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34-%E6%B3%A8%E6%84%8F%E5%93%AA%E4%B8%AA%E7%AE%97%E6%B3%95%E9%9C%80%E8%A6%81%E6%9C%89%E5%BA%8F%E5%8C%BA%E9%97%B4"><span class="toc-number">3.5.5.</span> <span class="toc-text">34. 注意哪个算法需要有序区间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35-mismatch%E6%88%96lexicographical%E6%AF%94-%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E5%BF%BD%E7%95%A5%E5%A4%A7%E5%B0%8F%E5%86%99%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83"><span class="toc-number">3.5.6.</span> <span class="toc-text">35. mismatch或lexicographical比 实现简单的忽略大小写字符串比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36-%E4%BA%86%E8%A7%A3copy-if%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.5.7.</span> <span class="toc-text">36. 了解copy_if的正确实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#37-%E7%94%A8accumulate%E6%88%96for-each%E6%9D%A5%E7%BB%9F%E8%AE%A1%E5%8C%BA%E9%97%B4"><span class="toc-number">3.5.8.</span> <span class="toc-text">37. 用accumulate或for_each来统计区间</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AD%90%E3%80%81%E5%87%BD%E6%95%B0%E5%AD%90%E7%B1%BB%E3%80%81%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%B6%E4%BB%96"><span class="toc-number">3.6.</span> <span class="toc-text">函数子、函数子类、函数及其他</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#38-%E9%81%B5%E5%BE%AA%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92%E7%9A%84%E5%8E%9F%E5%88%99%E6%9D%A5%E8%AE%BE%E8%AE%A1%E5%87%BD%E6%95%B0%E5%AD%90%E7%B1%BB"><span class="toc-number">3.6.1.</span> <span class="toc-text">38. 遵循按值传递的原则来设计函数子类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#39-%E7%A1%AE%E4%BF%9D%E5%88%A4%E5%88%AB%E5%BC%8F%E6%98%AF%E7%BA%AF%E5%87%BD%E6%95%B0"><span class="toc-number">3.6.2.</span> <span class="toc-text">39. 确保判别式是纯函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#40-%E8%8B%A5%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%98%AF%E5%87%BD%E6%95%B0%E5%AD%90%EF%BC%8C%E5%88%99%E5%BA%94%E4%BD%BF%E5%AE%83%E5%8F%AF%E9%85%8D%E6%8E%A5"><span class="toc-number">3.6.3.</span> <span class="toc-text">40. 若一个类是函数子，则应使它可配接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#41-%E7%90%86%E8%A7%A3ptr-fun%E3%80%81mem-fun%E5%92%8Cmem-fun-ref%E7%9A%84%E6%9D%A5%E7%94%B1"><span class="toc-number">3.6.4.</span> <span class="toc-text">41. 理解ptr_fun、mem_fun和mem_fun_ref的来由</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42-%E7%A1%AE%E5%AE%9Aless-lt-T-gt-%E8%A1%A8%E7%A4%BAoperator-lt"><span class="toc-number">3.6.5.</span> <span class="toc-text">42. 确定less&lt;T&gt;表示operator&lt;</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8STL%E7%BC%96%E7%A8%8B"><span class="toc-number">3.7.</span> <span class="toc-text">使用STL编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#43-%E5%B0%BD%E9%87%8F%E7%94%A8%E7%AE%97%E6%B3%95%E8%B0%83%E7%94%A8%E4%BB%A3%E6%9B%BF%E6%89%8B%E5%86%99%E5%BE%AA%E7%8E%AF"><span class="toc-number">3.7.1.</span> <span class="toc-text">43. 尽量用算法调用代替手写循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#44-%E5%AE%B9%E5%99%A8%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%BC%98%E5%85%88%E4%BA%8E%E5%90%8C%E5%90%8D%E7%AE%97%E6%B3%95"><span class="toc-number">3.7.2.</span> <span class="toc-text">44. 容器的成员函数优先于同名算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#45-%E6%B3%A8%E6%84%8Fcount%E3%80%81find%E3%80%81binary-search%E3%80%81lower-bound%E3%80%81upper-bound-%E5%92%8Cequal-range%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.7.3.</span> <span class="toc-text">45. 注意count、find、binary_search、lower_bound、upper_bound 和equal_range的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#46-%E8%80%83%E8%99%91%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E4%BB%A3%E6%9B%BF%E5%87%BD%E6%95%B0%E4%BD%9C%E7%AE%97%E6%B3%95%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-number">3.7.4.</span> <span class="toc-text">46. 考虑使用函数对象代替函数作算法的参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#47-%E9%81%BF%E5%85%8D%E4%BA%A7%E7%94%9F%E7%9B%B4%E5%86%99%E5%9E%8B%EF%BC%88write-only%EF%BC%89%E4%BB%A3%E7%A0%81"><span class="toc-number">3.7.5.</span> <span class="toc-text">47. 避免产生直写型（write-only）代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#48-%E6%80%BB%E6%98%AF-include%E9%80%82%E5%BD%93%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-number">3.7.6.</span> <span class="toc-text">48. 总是#include适当的头文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#49-%E5%AD%A6%E4%B9%A0%E7%A0%B4%E8%A7%A3%E6%9C%89%E5%85%B3STL%E7%9A%84%E7%BC%96%E8%AF%91%E5%99%A8%E8%AF%8A%E6%96%AD%E4%BF%A1%E6%81%AF"><span class="toc-number">3.7.7.</span> <span class="toc-text">49. 学习破解有关STL的编译器诊断信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#50-%E8%AE%A9%E4%BD%A0%E8%87%AA%E5%B7%B1%E7%86%9F%E6%82%89%E6%9C%89%E5%85%B3STL%E7%9A%84%E7%BD%91%E7%AB%99"><span class="toc-number">3.7.8.</span> <span class="toc-text">50. 让你自己熟悉有关STL的网站</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/12/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84Java%20ThreadLocal%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E7%BC%93%E5%AD%98%E9%87%8D%E5%A4%8DRPC%E7%BB%93%E6%9E%9C/" title="微服务架构下的Java ThreadLocal实践——缓存重复RPC结果">微服务架构下的Java ThreadLocal实践——缓存重复RPC结果</a><time datetime="2023-05-12T05:31:47.000Z" title="发表于 2023-05-12 13:31:47">2023-05-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/11/C++%E6%96%B0%E7%89%B9%E6%80%A7/" title="C++新特性">C++新特性</a><time datetime="2023-05-11T05:41:59.000Z" title="发表于 2023-05-11 13:41:59">2023-05-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/11/Java%E6%96%B0%E7%89%B9%E6%80%A7/" title="Java新特性">Java新特性</a><time datetime="2023-05-11T03:29:22.000Z" title="发表于 2023-05-11 11:29:22">2023-05-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/10/%E5%BB%BA%E7%AB%99%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/" title="建站第一篇文章">建站第一篇文章</a><time datetime="2023-05-09T16:25:27.000Z" title="发表于 2023-05-10 00:25:27">2023-05-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/12/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%94%B1gmock%E5%BC%95%E5%8F%91%E7%9A%84%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84/" title="记一次由gmock引发的代码重构">记一次由gmock引发的代码重构</a><time datetime="2023-04-12T05:27:41.000Z" title="发表于 2023-04-12 13:27:41">2023-04-12</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 一个廖少少</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>