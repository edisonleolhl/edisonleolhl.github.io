<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java8函数式编程 | 一知半解</title><meta name="author" content="一个廖少少"><meta name="copyright" content="一个廖少少"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java8 函数式编程Lambda表达式 Lambda表达式可以简化匿名内部类 普通的匿名内部类：在这个例子中，我们创建了一个新对象，它实现了ActionListener 接口。这个接口只有一个方法actionPerformed，当用户点击屏幕上的按钮时，button 就会调用这个方法。匿名内部类实现了该方法。 123456例2-1　使用匿名内部类将行为和按钮单击进行关联button.addAct">
<meta property="og:type" content="article">
<meta property="og:title" content="Java8函数式编程">
<meta property="og:url" content="https://edisonleolhl.github.io/2022/06/19/%E3%80%8AJava8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E3%80%8B%E2%80%94%E2%80%94%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="一知半解">
<meta property="og:description" content="Java8 函数式编程Lambda表达式 Lambda表达式可以简化匿名内部类 普通的匿名内部类：在这个例子中，我们创建了一个新对象，它实现了ActionListener 接口。这个接口只有一个方法actionPerformed，当用户点击屏幕上的按钮时，button 就会调用这个方法。匿名内部类实现了该方法。 123456例2-1　使用匿名内部类将行为和按钮单击进行关联button.addAct">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://edisonleolhl.github.io/images/avatar.jpeg">
<meta property="article:published_time" content="2022-06-19T04:55:29.000Z">
<meta property="article:modified_time" content="2023-05-10T12:56:28.740Z">
<meta property="article:author" content="一个廖少少">
<meta property="article:tag" content="函数式编程">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://edisonleolhl.github.io/images/avatar.jpeg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://edisonleolhl.github.io/2022/06/19/%E3%80%8AJava8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E3%80%8B%E2%80%94%E2%80%94%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java8函数式编程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-05-10 20:56:28'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/avatar.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/cover.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="一知半解"><span class="site-name">一知半解</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java8函数式编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-06-19T04:55:29.000Z" title="发表于 2022-06-19 12:55:29">2022-06-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-10T12:56:28.740Z" title="更新于 2023-05-10 20:56:28">2023-05-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java8函数式编程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Java8-函数式编程"><a href="#Java8-函数式编程" class="headerlink" title="Java8 函数式编程"></a>Java8 函数式编程</h1><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><ul>
<li><p>Lambda表达式可以简化匿名内部类</p>
<p>普通的匿名内部类：在这个例子中，我们创建了一个新对象，它实现了ActionListener 接口。这个接口只有一个方法actionPerformed，当用户点击屏幕上的按钮时，button 就会调用这个方法。匿名内部类实现了该方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例<span class="number">2</span>-<span class="number">1</span>　使用匿名内部类将行为和按钮单击进行关联</span><br><span class="line">button.addActionListener(<span class="keyword">new</span> <span class="title class_">ActionListener</span>() &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent event)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;button clicked&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>若用Lambda表达式，则可以化简，注意event不需要指定类型，后台可以根据addActionListener的函数签名推断event的类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例<span class="number">2</span>-<span class="number">2</span>　使用Lambda 表达式将行为和按钮单击进行关联</span><br><span class="line">button.addActionListener(event -&gt; System.out.println(<span class="string">&quot;button clicked&quot;</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>其他的Lambda例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ➊中所示的Lambda 表达式不包含参数，使用空括号() 表示没有参数。该Lambda 表达式实现了Runnable 接口，该接口也只有一个run 方法，没有参数，且返回类型为void</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">noArguments</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;Hello World&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// ➋中所示的Lambda 表达式包含且只包含一个参数，可省略参数的括号，这和例2-2 中的形式一样。</span></span><br><span class="line"><span class="type">ActionListener</span> <span class="variable">oneArgument</span> <span class="operator">=</span> event -&gt; System.out.println(<span class="string">&quot;button clicked&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// Lambda 表达式的主体不仅可以是一个表达式，而且也可以是一段代码块，使用大括号（&#123;&#125;）将代码块括起来，如➌所示</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">multiStatement</span> <span class="operator">=</span> () -&gt; &#123; </span><br><span class="line">  System.out.print(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">  System.out.println(<span class="string">&quot; World&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lambda 表达式也可以表示包含多个参数的方法，如➍所示，注意这该Lambda表达式是『创建』了两个数字相加的代码（或者叫函数），变量add的类型是BinaryOperator&lt;Long&gt;</span></span><br><span class="line">BinaryOperator&lt;Long&gt; add = (x, y) -&gt; x + y; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 如➎所示可以显式声明参数类型</span></span><br><span class="line">BinaryOperator&lt;Long&gt; addExplicit = (Long x, Long y) -&gt; x + y; </span><br></pre></td></tr></table></figure>
</li>
<li><p>Lambda表达式也叫闭包，未赋值的变量与周边环境隔离起来，进而被绑定到一个特定的值，所以，Lambda中被引用的不是变量，而是值，注意局部变量在<strong>既成事实</strong>上必须要是final的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例2-6　Lambda 表达式中引用既成事实上的final 变量</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> getUserName();</span><br><span class="line">button.addActionListener(event -&gt; System.out.println(<span class="string">&quot;hi &quot;</span> + name));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例2-7　未使用既成事实上的final 变量，导致无法通过编译</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> getUserName();</span><br><span class="line">name = formatUserName(name);</span><br><span class="line">button.addActionListener(event -&gt; System.out.println(<span class="string">&quot;hi &quot;</span> + name));</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数接口</p>
<p>函数接口是只有一个抽象方法的接口，用作Lambda 表达式的类型。</p>
<p>使用只有一个方法的接口来表示某特定方法并反复使用，是很早就有的习惯，lambda用同样的技巧，并称之为『函数接口』</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例2-8　ActionListener 接口：接受ActionEvent 类型的参数，返回空</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ActionListener</span> <span class="keyword">extends</span> <span class="title class_">EventListener</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent event)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>表2-1　Java中重要的函数接口</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>参数</th>
<th>返回类型</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>Predicate<T></td>
<td>T</td>
<td>boolean</td>
<td>这张唱片已经发行了吗</td>
</tr>
<tr>
<td>Consumer<T></td>
<td>T</td>
<td>void</td>
<td>输出一个值</td>
</tr>
<tr>
<td>Function&lt;T,R&gt;</td>
<td>T</td>
<td>R</td>
<td>获得Artist 对象的名字</td>
</tr>
<tr>
<td>Supplier<T></td>
<td>None</td>
<td>T</td>
<td>工厂方法</td>
</tr>
<tr>
<td>UnaryOperator<T></td>
<td>T</td>
<td>T</td>
<td>逻辑非（ !）</td>
</tr>
<tr>
<td>BinaryOperator<T></td>
<td>(T, T)</td>
<td>T</td>
<td>求两个数的乘积（ *）</td>
</tr>
</tbody></table>
</li>
<li><p>类型推断</p>
<p>菱形操作符</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例2-9　使用菱形操作符，根据变量类型做推断</span></span><br><span class="line">Map&lt;String, Integer&gt; oldWordCounts = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Integer&gt;(); <span class="comment">// 明确指定</span></span><br><span class="line">Map&lt;String, Integer&gt; diamondWordCounts = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); <span class="comment">// 编译器类型推断</span></span><br><span class="line"><span class="comment">// 例2-10　使用菱形操作符，根据方法签名做推断</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">useHashmap</span><span class="params">(Map&lt;String, String&gt; values)</span>;</span><br><span class="line">useHashmap(<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;()); <span class="comment">// 类型推断，注意在Java7无法通过编译</span></span><br></pre></td></tr></table></figure>

<p>Predicate函数接口，看下源码与用法就知道是咋回事了，Lambda表达式实现了Predicate函数接口，重写了其抽象方法test，重写后的方法体就是<code>return x &gt; 5；</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Predicate</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br><span class="line">Predicate&lt;Integer&gt; atLeast5 = x -&gt; x &gt; <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>推断系统虽然很智能，但需要一定的信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例2-13　略显复杂的类型推断</span></span><br><span class="line">BinaryOperator&lt;Long&gt; addLongs = (x, y) -&gt; x + y;</span><br><span class="line"><span class="comment">// 没有泛型，代码则通不过编译</span></span><br><span class="line"><span class="type">BinaryOperator</span> <span class="variable">add</span> <span class="operator">=</span> (x, y) -&gt; x + y;</span><br><span class="line"><span class="comment">// 报错：Operator &#x27;&amp; #x002B;&#x27; cannot be applied to java.lang.Object, java.lang.Object.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>习题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以如下方式重载check 方法后，还能正确推断出check(x -&gt; x &gt; 5) 的类型吗？</span></span><br><span class="line"><span class="comment">// No - the lambda expression could be inferred as IntPred or Predicate&lt;Integer&gt; so the overload is ambiguous.</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IntPred</span> &#123;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Integer value)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">check</span><span class="params">(Predicate&lt;Integer&gt; predicate)</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">check</span><span class="params">(IntPred predicate)</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="流（Stream）"><a href="#流（Stream）" class="headerlink" title="流（Stream）"></a>流（Stream）</h2><ul>
<li><p>从外部迭代到内部迭代</p>
<p>最开始，我们习惯用for循环遍历，或者拿到集合的迭代器，执行hasNext()与next()方法进行遍历操作，但是这都是在集合的外部进行遍历的，而流可以让迭代在集合的内部进行，Stream 是用函数式编程方式在集合类上进行复杂操作的工具。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例3-1　使用for 循环计算来自伦敦的艺术家人数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (Artist artist : allArtists) &#123;</span><br><span class="line">  <span class="keyword">if</span> (artist.isFrom(<span class="string">&quot;London&quot;</span>)) &#123;</span><br><span class="line">    count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 例3-2　使用迭代器计算来自伦敦的艺术家人数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">Iterator&lt;Artist&gt; iterator = allArtists.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">  <span class="type">Artist</span> <span class="variable">artist</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">  <span class="keyword">if</span> (artist.isFrom(<span class="string">&quot;London&quot;</span>)) &#123;</span><br><span class="line">    count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 例3-3　使用内部迭代计算来自伦敦的艺术家人数</span></span><br><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> allArtists.stream()</span><br><span class="line">    .filter(artist -&gt; artist.isFrom(<span class="string">&quot;London&quot;</span>))</span><br><span class="line">    .count();</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现机制：看上去流操作将集合遍历拆分成了『过滤+计数』，但实际上仍只需要一次循环</p>
<p>像filter这样只描述stream，但是不产生新集合的方法叫做<strong>惰性求值方法</strong>，像count 这样最终会从Stream 产生值的方法叫作<strong>及早求值方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例3-5　由于使用了惰性求值，没有输出艺术家的名字</span></span><br><span class="line">allArtists.stream()</span><br><span class="line">  .filter(artist -&gt; &#123;</span><br><span class="line">    System.out.println(artist.getName());</span><br><span class="line">    <span class="keyword">return</span> artist.isFrom(<span class="string">&quot;London&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 例3-6　输出艺术家的名字</span></span><br><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> allArtists.stream()</span><br><span class="line">  .filter(artist -&gt; &#123;</span><br><span class="line">      System.out.println(artist.getName());</span><br><span class="line">      <span class="keyword">return</span> artist.isFrom(<span class="string">&quot;London&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .count();</span><br></pre></td></tr></table></figure>

<p>使用这些操作的理想方式就是形成一个惰性求值的链，最后用一个及早求值的操作返回想要的结果，有点像建造者模式，最后调用build方法时，对象才会真正创建</p>
</li>
<li><p>常用的流操作</p>
<p>collect(toList()) 方法由Stream 里的值生成一个列表，是一个及早求值操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; collected = Stream.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>) </span><br><span class="line">  .collect(Collectors.toList()); </span><br><span class="line">assertEquals(Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>), collected); </span><br></pre></td></tr></table></figure>

<p>map 方法，从一个流的值转换成一个新的流，传给map 的Lambda 表达式只接受一个String 类型的参数，返回一个新的String。参数和返回值不必属于同一种类型，但是Lambda 表达式必须是Function 接口的一个实例（<code>Function&lt;T,R&gt;</code>），是惰性求值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例3-9　使用map 操作将字符串转换为大写形式</span></span><br><span class="line">List&lt;String&gt; collected = Stream.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line">  .map(string -&gt; string.toUpperCase()) 􀁮</span><br><span class="line">  .collect(toList());</span><br><span class="line">assertEquals(asList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;HELLO&quot;</span>), collected);</span><br></pre></td></tr></table></figure>

<p>filter，保留stream中的一些元素，而过滤掉其他的，是惰性求值，传给filter的Lambda表达式的函数接口正是Predicat</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例3-11　函数式风格</span></span><br><span class="line">List&lt;String&gt; beginningWithNumbers = Stream.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;1abc&quot;</span>, <span class="string">&quot;abc1&quot;</span>)</span><br><span class="line">  .filter(value -&gt; isDigit(value.charAt(<span class="number">0</span>)))</span><br><span class="line">  .collect(toList());</span><br></pre></td></tr></table></figure>

<p>flatMap：有时，用户希望让map操作有点变化，生成一个新的Stream 对象取而代之。用户通常不希望结果是一连串的流，此时flatMap 最能派上用场。Lambda函数接口与map的一样，都是Function，只是方法的返回值限定为Stream类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例3-12　包含多个列表的Stream</span></span><br><span class="line">List&lt;Integer&gt; together = Stream.of(asList(<span class="number">1</span>, <span class="number">2</span>), asList(<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">    .flatMap(numbers -&gt; numbers.stream())</span><br><span class="line">    .collect(toList());</span><br><span class="line">assertEquals(asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>), together);</span><br></pre></td></tr></table></figure>

<p>max和min</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例3-13　使用Stream 查找最短曲目</span></span><br><span class="line">List&lt;Track&gt; tracks = asList(<span class="keyword">new</span> <span class="title class_">Track</span>(<span class="string">&quot;Bakai&quot;</span>, <span class="number">524</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Track</span>(<span class="string">&quot;Violets for Your Furs&quot;</span>, <span class="number">378</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Track</span>(<span class="string">&quot;Time Was&quot;</span>, <span class="number">451</span>));</span><br><span class="line"><span class="type">Track</span> <span class="variable">shortestTrack</span> <span class="operator">=</span> tracks.stream()</span><br><span class="line">    .min(Comparator.comparing(track -&gt; track.getLength()))</span><br><span class="line">    .get();</span><br><span class="line">assertEquals(tracks.get(<span class="number">1</span>), shortestTrack);</span><br></pre></td></tr></table></figure>

<p>reduce 操作可以实现从一组值中生成一个值。在上述例子中用到的count、min 和max 方法，因为常用而被纳入标准库中。事实上，这些方法都是reduce 操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">T <span class="title function_">reduce</span><span class="params">(T identity, BinaryOperator&lt;T&gt; accumulator)</span>;</span><br><span class="line"><span class="comment">// 例3-16　使用reduce 求和，这段求和代码不适合在生产环境中，仅作示例</span></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    .reduce(<span class="number">0</span>, (acc, element) -&gt; acc + element);</span><br><span class="line">assertEquals(<span class="number">6</span>, count);</span><br><span class="line"><span class="comment">// 例3-17　展开reduce 操作</span></span><br><span class="line">BinaryOperator&lt;Integer&gt; accumulator = (acc, element) -&gt; acc + element;</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> accumulator.apply(</span><br><span class="line">    accumulator.apply(</span><br><span class="line">        accumulator.apply(<span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">        <span class="number">2</span>),</span><br><span class="line">    <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>习题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编写一个函数，接受艺术家列表作为参数，返回一个字符串列表，其中包含艺术家的姓名和国籍（可重复）；</span></span><br><span class="line"><span class="comment">// 我的丑陋写法。。</span></span><br><span class="line">List&lt;String&gt; <span class="title function_">extract</span><span class="params">(List&lt;Artist&gt; artists)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> Stream.of(</span><br><span class="line">    artists.stream().map(artist -&gt; artist.getName()).collect(toList()),</span><br><span class="line">    artists.stream().map(artist -&gt; artist.getNationality()).collect(toList())</span><br><span class="line">  ).flatMap(list -&gt; list.stream()).collect(Collectors.toList());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 标准答案，使用flatMap</span></span><br><span class="line">List&lt;String&gt; <span class="title function_">getNamesAndOrigins</span><span class="params">(List&lt;Artist&gt; artists)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> artists.stream()</span><br><span class="line">    .flatMap(artist -&gt; Stream.of(artist.getName(), artist.getNationality()))</span><br><span class="line">    .collect(toList());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改代码，将外部迭代变为内部迭代</span></span><br><span class="line"><span class="type">int</span> <span class="variable">totalMembers</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (Artist artist : artists) &#123;</span><br><span class="line">  Stream&lt;Artist&gt; members = artist.getMembers();</span><br><span class="line">  totalMembers += members.count();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 标准答案</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">countBandMembersInternal</span><span class="params">(List&lt;Artist&gt; artists)</span> &#123;</span><br><span class="line">      <span class="comment">// NB: readers haven&#x27;t learnt about primitives yet, so can&#x27;t use the sum() method</span></span><br><span class="line">      <span class="keyword">return</span> artists.stream()</span><br><span class="line">                     .map(artist -&gt; artist.getMembers().count())</span><br><span class="line">                     .reduce(<span class="number">0L</span>, Long::sum)</span><br><span class="line">                     .intValue();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算一个字符串中小写字母的个数（提示：参阅String 对象的chars 方法）。s</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">countLower</span><span class="params">(String str)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">int</span>) str.chars().filter(x -&gt; x &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; x &lt;= <span class="string">&#x27;z&#x27;</span>).count();</span><br><span class="line"><span class="comment">//        return (int) string.chars()</span></span><br><span class="line"><span class="comment">//                           .filter(Character::isLowerCase)</span></span><br><span class="line"><span class="comment">//                           .count();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在一个字符串列表中，找出包含最多小写字母的字符串。对于空列表，返回Optional&lt;String&gt; 对象。</span></span><br><span class="line"><span class="comment">// 我的写法，因为comparing方法要传入Function函数接口，所以得先创建一个</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Function&lt;String, Integer&gt; <span class="title function_">countLowerFunc</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> str -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> Math.toIntExact(str.chars().filter(x -&gt; x &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; x &lt;= <span class="string">&#x27;z&#x27;</span>).count());</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Optional&lt;String&gt; <span class="title function_">findMostLowerCaseString</span><span class="params">(ArrayList&lt;String&gt; strList)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> strList.stream().</span><br><span class="line">      max(Comparator.comparing(countLowerFunc()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 标准答案，comparingInt接收一个toIntFunction，所以可以复用上面的countLower函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Optional&lt;String&gt; <span class="title function_">mostLowercaseString</span><span class="params">(List&lt;String&gt; strings)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> strings.stream()</span><br><span class="line">    .max(Comparator.comparingInt(StreamTest::countLower));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="类库"><a href="#类库" class="headerlink" title="类库"></a>类库</h2><ul>
<li><p>在代码中使用Lambda表达式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例4-1　使用isDebugEnabled 方法降低日志性能开销</span></span><br><span class="line"><span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Logger</span>();</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Look at this: &quot;</span> + expensiveOperation());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 例4-2　使用Lambda 表达式简化日志代码</span></span><br><span class="line"><span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Logger</span>();</span><br><span class="line">logger.debug(() -&gt; <span class="string">&quot;Look at this: &quot;</span> + expensiveOperation());</span><br><span class="line"><span class="comment">// 例4-3　启用Lambda 表达式实现的日志记录器</span></span><br><span class="line"><span class="comment">// 调用get() 方法，相当于调用传入的Lambda 表达式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">debug</span><span class="params">(Supplier&lt;String&gt; message)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (isDebugEnabled()) &#123;</span><br><span class="line">    debug(message.get());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><ul>
<li><p>由于装箱类型是对象，因此在内存中存在额外开销。比如，整型在内存中占用<br>4 字节，整型对象却要占用16 字节。</p>
</li>
<li><p>将基本类型转换为装箱类型，称为装箱，反之则称为拆箱，两者都需要额外的计算开销。对于需要大量数值运算的算法来说，装箱和拆箱的计算开销，以及装箱类型占用的额外内存，会明显减缓程序的运行速度。</p>
</li>
<li><p>为了减少开销，Stream对基本类型和装箱类型做了区分</p>
<ul>
<li>从T转为long：<code>toLongFunction&lt;T, long&gt;</code></li>
<li>接收long参数，返回T：<code>T LongFunction(long)</code></li>
<li>基本类型对应的Stream：<code>LongStream</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例4-4　使用summaryStatistics 方法统计曲目长度</span></span><br><span class="line"><span class="comment">// mapToInt返回IntStream对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printTrackLengthStatistics</span><span class="params">(Album album)</span> &#123;</span><br><span class="line"><span class="type">IntSummaryStatistics</span> <span class="variable">trackLengthStats</span></span><br><span class="line">    <span class="operator">=</span> album.getTracks()</span><br><span class="line">        .mapToInt(track -&gt; track.getLength())</span><br><span class="line">        .summaryStatistics();</span><br><span class="line">System.out.printf(<span class="string">&quot;Max: %d, Min: %d, Ave: %f, Sum: %d&quot;</span>,</span><br><span class="line">    trackLengthStats.getMax(),</span><br><span class="line">    trackLengthStats.getMin(),</span><br><span class="line">    trackLengthStats.getAverage(),</span><br><span class="line">    trackLengthStats.getSum());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="重载解析"><a href="#重载解析" class="headerlink" title="重载解析"></a>重载解析</h3><ul>
<li><p>一般，Java会选择更具体的类型进行重载解析，比如String继承自Object</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例4-5　方法调用</span></span><br><span class="line">overloadedMethod(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="comment">// 例4-6　两个重载方法可供选择，但最终会输出String</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">overloadedMethod</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">  System.out.print(<span class="string">&quot;Object&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">overloadedMethod</span><span class="params">(String s)</span> &#123;</span><br><span class="line">  System.out.print(<span class="string">&quot;String&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Lambda表达式作为参数时，原则也差不多</p>
<ul>
<li>如果只有一个可能的目标类􀅖 型，由相应函数接口里的参数类型推导得出；</li>
<li>如果有多个可能的目标类型，由最具体的类型推导得出；</li>
<li>如果有多个可能的目标类型且最具体的类型不明确，则需人为指定类型。</li>
</ul>
</li>
</ul>
<h3 id="FunctionalInterface"><a href="#FunctionalInterface" class="headerlink" title="@FunctionalInterface"></a>@FunctionalInterface</h3><ul>
<li><p>每个用作函数接口的接口都应该添加这个注释</p>
</li>
<li><p>该注释会强制javac 检查一个接口是否符合函数接口的标准。如果该注释添加给一个枚举<br>类型、类或另一个注释，或者接口包含不止一个抽象方法，javac 就会报错。重构代码时，<br>使用它能很容易发现问题。</p>
</li>
</ul>
<h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><ul>
<li><p>因为Java8对所有Collection接口增加了stream方法，在之前Java1~7编写的MyCustomList实现了Collection接口，也必须要增加了stream方法才行，这打破了兼容性</p>
</li>
<li><p>默认方法正是为了解决这个情况而产生的，：Collection 接口告诉它所有的子类：<br>“如果你没有实现stream 方法，就使用我的吧。”接口中这样的方法叫作<strong>默认方法</strong>，在任何接口中，无论函数接口还是非函数接口，都可以使用该方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例4-10　默认方法示例：forEach 实现方式</span></span><br><span class="line"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (T t : <span class="built_in">this</span>) &#123;</span><br><span class="line">    action.accept(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接口没有成员变量，所以默认方法只能通过调用子类的方法来修改子类本身</p>
</li>
</ul>
<h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><ul>
<li><p>接口允许多重继承，如果一个类继承的两个接口中有同名的默认方法，编译器就不知道继承哪个，于是报错</p>
</li>
<li><p>重载同名的默认方法即可解决该问题，下面的代码使用了增强的super方法，用来指明接口Carriage中定义的默认方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例4-21　实现rock 方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MusicalCarriage</span></span><br><span class="line"><span class="keyword">implements</span> <span class="title class_">Carriage</span>, Jukebox &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">rock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Carriage.<span class="built_in">super</span>.rock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h3><ul>
<li><p>Optional 是为核心类库新设计的一个数据类型，用来替换null 值，最大的用处是：<strong>避免NPE！！！</strong></p>
</li>
<li><p>使用方法</p>
<ul>
<li>使用Optional 对象的方式之一是在调用get() 方法前，先使用isPresent 检查Optional对象是否有值。</li>
<li>使用orElse 方法则更简洁，当Optional 对象为空时，该方法提供了一个备选值。</li>
<li>如果计算备选值在计算上太过繁琐，即可使用orElseGet 方法。该方法接受一个<br>Supplier 对象，只有在Optional 对象真正为空时才会调用</li>
</ul>
</li>
<li><p>示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建某个值的Optional 对象</span></span><br><span class="line">Optional&lt;String&gt; a = Optional.of(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">assertEquals(<span class="string">&quot;a&quot;</span>, a.get());</span><br><span class="line"><span class="comment">// 创建空Optional对象</span></span><br><span class="line"><span class="type">Optional</span> <span class="variable">emptyOptional</span> <span class="operator">=</span> Optional.empty();</span><br><span class="line"><span class="comment">// 从null值创建Optional对象</span></span><br><span class="line"><span class="type">Optional</span> <span class="variable">alsoEmpty</span> <span class="operator">=</span> Optional.ofNullable(<span class="literal">null</span>);</span><br><span class="line"><span class="comment">// 例4-24　使用orElse 和orElseGet 方法</span></span><br><span class="line">assertEquals(<span class="string">&quot;b&quot;</span>, emptyOptional.orElse(<span class="string">&quot;b&quot;</span>));</span><br><span class="line">assertEquals(<span class="string">&quot;c&quot;</span>, emptyOptional.orElseGet(() -&gt; <span class="string">&quot;c&quot;</span>));</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="高级集合类和收集器"><a href="#高级集合类和收集器" class="headerlink" title="高级集合类和收集器"></a>高级集合类和收集器</h2><h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><ul>
<li><code>artist -&gt; artist.getName()</code>可以用<code>Artist::getName</code>代替，这就是方法引用，构造函数可以用<code>Artist::new</code></li>
</ul>
<h3 id="元素顺序"><a href="#元素顺序" class="headerlink" title="元素顺序"></a>元素顺序</h3><ul>
<li><p>Stream不会主动去排序，只会按元素的出现顺序按序处理，大多数操作都是在有序流上效率更高，比如filter、map和reduce</p>
</li>
<li><p>使用并行流时，forEach方法不能保证元素是按顺序处理的，请用forEachOrdered方法</p>
</li>
</ul>
<h3 id="收集器"><a href="#收集器" class="headerlink" title="收集器"></a>收集器</h3><ul>
<li><p>这就是收集器，一种通用的、从流生成复杂值的结构。只要将它传给collect 方法，所有的流就都可以使用它了。</p>
</li>
<li><p>常见的，如toList、toSet、toMap</p>
</li>
<li><p>有时想用TreeSet，但不想由框架在背后自动为我指定一种Set，可以使用<code>stream.collect(toCollection(TreeSet::new));</code></p>
</li>
<li><p>转换成值：还可以利用收集器让流生成一个值。maxBy 和minBy 允许用户按某种特定的顺序生成一个值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例5-6　找出成员最多的乐队</span></span><br><span class="line"><span class="keyword">public</span> Optional&lt;Artist&gt; <span class="title function_">biggestGroup</span><span class="params">(Stream&lt;Artist&gt; artists)</span> &#123;</span><br><span class="line">  Function&lt;Artist,Long&gt; getCount = artist -&gt; artist.getMembers().count();</span><br><span class="line">  <span class="keyword">return</span> artists.collect(maxBy(comparing(getCount)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 例5-7　找出一组专辑上曲目的平均数</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">averageNumberOfTracks</span><span class="params">(List&lt;Album&gt; albums)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> albums.stream()</span><br><span class="line">      .collect(averagingInt(album -&gt; album.getTrackList().size()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据分块，以划分代替两次过滤，它使用Predicate 对象判断一个元素应该属于哪个部分，并根据布尔值返回一个Map 到列表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例5-8　将艺术家组成的流分成乐队和独唱歌手两部分</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;Boolean, List&lt;Artist&gt;&gt; <span class="title function_">bandsAndSolo</span><span class="params">(Stream&lt;Artist&gt; artists)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> artists.collect(partitioningBy(artist -&gt; artist.isSolo()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据分组，更加自然的划分操作，使用任意值对数据分组，很像SQL的group by</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例5-10　使用主唱对专辑分组</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;Artist, List&lt;Album&gt;&gt; <span class="title function_">albumsByArtist</span><span class="params">(Stream&lt;Album&gt; albums)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> albums.collect(groupingBy(album -&gt; album.getMainMusician()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串：有些时候使用Stream是为了得到一个最后的字符串，可以使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例5-12　使用流和收集器格式化艺术家姓名，参数分别是(分隔符，前缀，后缀)</span></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span></span><br><span class="line">    artists.stream()</span><br><span class="line">        .map(Artist::getName)</span><br><span class="line">        .collect(Collectors.joining(<span class="string">&quot;, &quot;</span>, <span class="string">&quot;[&quot;</span>, <span class="string">&quot;]&quot;</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据分组并计数：效果等同于SQL的groupby + count</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例5-14　使用收集器计算每个艺术家的专辑数</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;Artist, Long&gt; <span class="title function_">numberOfAlbums</span><span class="params">(Stream&lt;Album&gt; albums)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> albums.collect(groupingBy(album -&gt; album.getMainMusician(), counting());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>mapping允许在收集器的容器上执行类似map的操作，但是需要指明什么样的集合类存储结果，比如toList</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例5-16　使用收集器求每个艺术家的专辑名</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;Artist, List&lt;String&gt;&gt; <span class="title function_">nameOfAlbums</span><span class="params">(Stream&lt;Album&gt; albums)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> albums.collect(groupingBy(Album::getMainMusician, mapping(Album::getName, toList())));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重构和定制收集器：如果想打印Artist列表的艺术家名字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例5-20　使用reduce 和StringCombiner 类格式化艺术家姓名</span></span><br><span class="line"><span class="type">String</span> <span class="variable">combined</span> <span class="operator">=</span></span><br><span class="line">    artists.stream()</span><br><span class="line">    .map(Artist::getName)</span><br><span class="line">    .reduce(<span class="keyword">new</span> <span class="title class_">StringCombiner</span>(<span class="string">&quot;, &quot;</span>, <span class="string">&quot;[&quot;</span>, <span class="string">&quot;]&quot;</span>),</span><br><span class="line">      StringCombiner::add,</span><br><span class="line">      StringCombiner::merge)</span><br><span class="line">    .ToString();</span><br><span class="line"><span class="comment">// 例5-21　add 方法返回连接新元素后的结果</span></span><br><span class="line"><span class="keyword">public</span> StringCombiner <span class="title function_">add</span><span class="params">(String element)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (areAtStart()) &#123;</span><br><span class="line">      builder.append(prefix);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      builder.append(delim);</span><br><span class="line">    &#125;</span><br><span class="line">    builder.append(element);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 例5-22　merge 方法连接两个StringCombiner 对象</span></span><br><span class="line"><span class="keyword">public</span> StringCombiner <span class="title function_">merge</span><span class="params">(StringCombiner other)</span> &#123;</span><br><span class="line">  builder.append(other.builder);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将上述的reduce操作重构成一个收集器，会很好复用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例5-24　使用定制的收集器StringCollector 收集字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span></span><br><span class="line">    artists.stream()</span><br><span class="line">        .map(Artist::getName)</span><br><span class="line">        .collect(<span class="keyword">new</span> <span class="title class_">StringCollector</span>(<span class="string">&quot;, &quot;</span>, <span class="string">&quot;[&quot;</span>, <span class="string">&quot;]&quot;</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>出于教学目的，编写这样的收集器，St ringCollector支持泛型，待收集元素、累加器类型、最终结果类型，已字符串为例，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringCollector</span> <span class="keyword">implements</span> <span class="title class_">Collector</span>&lt;String, StringCombiner, String&gt; &#123;</span><br><span class="line">  <span class="comment">// 工厂方法，用来创建容器</span></span><br><span class="line">  <span class="keyword">public</span> Supplier&lt;StringCombiner&gt; <span class="title function_">supplier</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> () -&gt; <span class="keyword">new</span> <span class="title class_">StringCombiner</span>(delim, prefix, suffix);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// accumulator 是一个函数，它将当前元素叠加到收集器</span></span><br><span class="line">  <span class="keyword">public</span> BiConsumer&lt;StringCombiner, String&gt; <span class="title function_">accumulator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> StringCombiner::add;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// combiner 合并两个容器</span></span><br><span class="line">  <span class="keyword">public</span> BinaryOperator&lt;StringCombiner&gt; <span class="title function_">combiner</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> StringCombiner::merge;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// finisher 方法返回收集操作的最终结果</span></span><br><span class="line">  <span class="keyword">public</span> Function&lt;StringCombiner, String&gt; <span class="title function_">finisher</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> StringCombiner::toString;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="一些细节"><a href="#一些细节" class="headerlink" title="一些细节"></a>一些细节</h3><ul>
<li><p>Lambda表达式，对Map的改变，比如缓存不存在时读db</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例5-32　使用computeIfAbsent 缓存</span></span><br><span class="line"><span class="keyword">public</span> Artist <span class="title function_">getArtist</span><span class="params">(String name)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> artistCache.computeIfAbsent(name, <span class="built_in">this</span>::readArtistFromDB);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例5-34　使用内部迭代遍历Map 里的值</span></span><br><span class="line">Map&lt;Artist, Integer&gt; countOfAlbums = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">albumsByArtist.forEach((artist, albums) -&gt; &#123;</span><br><span class="line">  countOfAlbums.put(artist, albums.size());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>习题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Map 的computeIfAbsent 方法高效计算斐波那契数列。这里的“高效”是指避免将那些较小的序列重复计算多次。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fibonacci</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Integer,Long&gt; cache;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Fibonacci</span><span class="params">()</span> &#123;</span><br><span class="line">        cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        cache.put(<span class="number">0</span>, <span class="number">0L</span>);</span><br><span class="line">        cache.put(<span class="number">1</span>, <span class="number">1L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cache.computeIfAbsent(x, n -&gt; fibonacci(n-<span class="number">1</span>) + fibonacci(n-<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="数据并行化"><a href="#数据并行化" class="headerlink" title="数据并行化"></a>数据并行化</h2><ul>
<li><p>如果已经有一个Stream 对象， 调用它的parallel 方法就能让其拥有并行操作的能力。如果想从一个集合类创建一个流，调用parallelStream 就能立即获得一个拥有并行能力的流。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例6-1　串行化计算专辑曲目长度</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">serialArraySum</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> albums.stream()</span><br><span class="line">    .flatMap(Album::getTracks)</span><br><span class="line">    .mapToInt(Track::getLength)</span><br><span class="line">    .sum();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 例6-2　并行化计算专辑曲目长度</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">parallelArraySum</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> albums.parallelStream()</span><br><span class="line">    .flatMap(Album::getTracks)</span><br><span class="line">    .mapToInt(Track::getLength)</span><br><span class="line">    .sum();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>限制:</p>
<ul>
<li>串行调用reduce 方法，初始值可以为任意值，为了让其在并行化时能工作正常，初值必须为组合函数的恒等值。比如加法中0为恒等值，乘法中1为恒等值</li>
<li>reduce 操作的另一个限制是组合操作必须符合结合律</li>
<li>避免持有锁</li>
</ul>
</li>
<li><p>性能：</p>
<ul>
<li>数据大小：输入数据的大小会影响并行化处理对性能的提升。将问题分解之后并行化处理，再将结果合并会带来额外的开销。因此只有数据足够大、每个数据处理管道花费的时间足够多时，并行化处理才有意义</li>
<li>源数据结构：最好是易于拆分的，如数组</li>
<li>装箱：处理基本类型比处理装箱类型要快。</li>
<li>多核CPU：显然，只有一个CPU，并行完全没用</li>
<li>处理每个元素所花的时间：一般来说，处理每个元素花的时间越多，并行化收益越大</li>
</ul>
</li>
<li><p>并行流框架，基于分解与合并，所以分解数据源的效率很重要</p>
<ul>
<li>ArrayList、数组或IntStream.range，这些数据结构支持随机读取，也就是说它们能轻而易举地被任意分解。</li>
<li>HashSet、TreeSet，这些数据结构不易公平地被分解，但是大多数时候分解是可能的。</li>
<li>可能要花O(N) 的时间复杂度来分解问题。其中包括LinkedList，对半分解太难了。还有Streams.iterate 和BufferedReader.lines，它们长度未知，因此很难预测该在哪里分解。</li>
</ul>
</li>
<li><p>如果能避开有状态，选用无状态操作，就能获得更好的并行性能。无状态操作包括map、filter 和flatMap，有状态操作包括sorted、distinct 和limit。</p>
</li>
<li><p>举例，并行化计算滑动平均数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span>[] simpleMovingAverage(<span class="type">double</span>[] values, <span class="type">int</span> n) &#123;</span><br><span class="line">  <span class="type">double</span>[] sums = Arrays.copyOf(values, values.length); <span class="comment">// 并行操作会改变数组，所以先拷贝一份</span></span><br><span class="line">  Arrays.parallelPrefix(sums, Double::sum); <span class="comment">// 并行流操作，sums保存了求和结果</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> IntStream.range(start, sums.length) 􀁰</span><br><span class="line">      .mapToDouble(i -&gt; &#123;</span><br><span class="line">          <span class="type">double</span> <span class="variable">prefix</span> <span class="operator">=</span> (i == start ? <span class="number">0</span> : sums[i - n]);</span><br><span class="line">          <span class="keyword">return</span> (sums[i] - prefix) / n; <span class="comment">// 总和减去窗口起始值，再除以n得到平均</span></span><br><span class="line">      &#125;)</span><br><span class="line">      .toArray(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="测试、调试和重构"><a href="#测试、调试和重构" class="headerlink" title="测试、调试和重构"></a>测试、调试和重构</h2><ul>
<li><p>Lambda化可以有效的实践DRY原则，充分复用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例7-5　Order 类的命令式实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">countRunningTime</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Album album : albums) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Track track : album.getTrackList()) &#123;</span><br><span class="line">            count += track.getLength();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">countMusicians</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Album album : albums) &#123;</span><br><span class="line">        count += album.getMusicianList().size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">countTracks</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Album album : albums) &#123;</span><br><span class="line">        count += album.getTrackList().size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例7-7　使用领域方法重构Order 类</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">countFeature</span><span class="params">(ToLongFunction&lt;Album&gt; function)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> albums.stream()</span><br><span class="line">      .mapToLong(function)</span><br><span class="line">      .sum();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">countTracks</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> countFeature(album -&gt; album.getTracks().count());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">countRunningTime</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> countFeature(album -&gt; album.getTracks()</span><br><span class="line">      .mapToLong(track -&gt; track.getLength())</span><br><span class="line">      .sum());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">countMusicians</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> countFeature(album -&gt; album.getMusicians().count());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Lambda表达式的单元测试，因为Lambda表达式没有名字，不能直接调用，而从源代码复制Lambda表达式到测试代码中，又太松散，可以使用<strong>方法引用</strong>，然后单独测试方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">例<span class="number">7</span>-<span class="number">10</span>　将列表中元素的第一个字母转换成大写</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">elementFirstToUpperCaseLambdas</span><span class="params">(List&lt;String&gt; words)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> words.stream()</span><br><span class="line">    .map(value -&gt; &#123; 􀁮</span><br><span class="line">      <span class="type">char</span> <span class="variable">firstChar</span> <span class="operator">=</span> Character.toUpperCase(value.charAt(<span class="number">0</span>));</span><br><span class="line">      <span class="keyword">return</span> firstChar + value.substring(<span class="number">1</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .collect(Collectors.&lt;String&gt;toList());</span><br><span class="line">&#125;</span><br><span class="line">例<span class="number">7</span>-<span class="number">12</span>　将首字母转换为大写，应用到所有列表元素</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">elementFirstToUppercase</span><span class="params">(List&lt;String&gt; words)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> words.stream()</span><br><span class="line">    .map(Testing::firstToUppercase)</span><br><span class="line">    .collect(Collectors.&lt;String&gt;toList());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">firstToUppercase</span><span class="params">(String value)</span> &#123; 􀁮</span><br><span class="line">  <span class="type">char</span> <span class="variable">firstChar</span> <span class="operator">=</span> Character.toUpperCase(value.charAt(<span class="number">0</span>));</span><br><span class="line">  <span class="keyword">return</span> firstChar + value.substring(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>惰性求值和调试，流操作会让调试变得复杂</p>
</li>
<li><p>解决方案：peak，可以查看流中的每个值，同时能继续操作流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例<span class="number">7</span>-<span class="number">18</span>　使用peek 方法记录中间值</span><br><span class="line">Set&lt;String&gt; nationalities</span><br><span class="line">  = album.getMusicians()</span><br><span class="line">    .filter(artist -&gt; artist.getName().startsWith(<span class="string">&quot;The&quot;</span>))</span><br><span class="line">    .map(artist -&gt; artist.getNationality())</span><br><span class="line">    .peek(nation -&gt; System.out.println(<span class="string">&quot;Found nationality: &quot;</span> + nation))</span><br><span class="line">    .collect(Collectors.&lt;String&gt;toSet());</span><br></pre></td></tr></table></figure>
</li>
<li><p>在peek方法中加入断点，就可以逐个调试流中的元素了</p>
</li>
</ul>
<h2 id="设计和架构的原则"><a href="#设计和架构的原则" class="headerlink" title="设计和架构的原则"></a>设计和架构的原则</h2><ul>
<li><p>观测不可变性和实现不可变性。观测不可变性是指在其他对象看来，该类是不可变的；实现不可变性是指对象本身不可变。实现不可变性意味着观测不可变性，反之则不一定成立。</p>
</li>
<li><p>java.lang.String 宣称是不可变的，但事实上只是观测不可变，因为它在第一次调用 hashCode 方法时缓存了生成的散列值。在其他类看来，这是完全安全的，它们看不出散列值是每次在构造函数中计算出来的，还是从缓存中返回的</p>
</li>
<li><p>我们说不可变对象实现了开闭原则，是因为它们的内部状态无法改变，可以安全地为其增<br>加新的方法。新增加的方法无法改变对象的内部状态，因此对修改是闭合的；但它们又增<br>加了新的行为，因此对扩展是开放的</p>
</li>
</ul>
<blockquote>
<p>原文写于 2022-06-19</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://edisonleolhl.github.io">一个廖少少</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://edisonleolhl.github.io/2022/06/19/%E3%80%8AJava8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E3%80%8B%E2%80%94%E2%80%94%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">https://edisonleolhl.github.io/2022/06/19/%E3%80%8AJava8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E3%80%8B%E2%80%94%E2%80%94%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://edisonleolhl.github.io" target="_blank">一知半解</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/">函数式编程</a><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="/images/avatar.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/02/19/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84Java%20Parallel%20Stream%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E4%BC%98%E5%8C%96RT%E4%B8%8E%E4%B8%B2%E8%81%94traceid/" title="微服务架构下的Java Parallel Stream实践——优化RT与串联traceid"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">微服务架构下的Java Parallel Stream实践——优化RT与串联traceid</div></div></a></div><div class="next-post pull-right"><a href="/2022/05/10/Effective%20C++%20&amp;&amp;%20More%20Effective%20C++/" title="Effective C++ &amp;&amp; More Effective C++"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Effective C++ &amp;&amp; More Effective C++</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/02/19/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84Java%20Parallel%20Stream%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E4%BC%98%E5%8C%96RT%E4%B8%8E%E4%B8%B2%E8%81%94traceid/" title="微服务架构下的Java Parallel Stream实践——优化RT与串联traceid"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-19</div><div class="title">微服务架构下的Java Parallel Stream实践——优化RT与串联traceid</div></div></a></div><div><a href="/2021/11/17/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E3%80%8B%E2%80%94%E2%80%94%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" title="《深入理解Java虚拟机：JVM高级特性与最佳实践》——读书笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-17</div><div class="title">《深入理解Java虚拟机：JVM高级特性与最佳实践》——读书笔记</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/avatar.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">一个廖少少</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/edisonleolhl"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/edisonleolhl" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:edisonleolhl@foxmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">这个家伙很懒，什么都没写~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java8-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">Java8 函数式编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.1.</span> <span class="toc-text">Lambda表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%EF%BC%88Stream%EF%BC%89"><span class="toc-number">1.2.</span> <span class="toc-text">流（Stream）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%BA%93"><span class="toc-number">1.3.</span> <span class="toc-text">类库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">基本类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E8%A7%A3%E6%9E%90"><span class="toc-number">1.3.2.</span> <span class="toc-text">重载解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FunctionalInterface"><span class="toc-number">1.3.3.</span> <span class="toc-text">@FunctionalInterface</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.4.</span> <span class="toc-text">默认方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-number">1.3.5.</span> <span class="toc-text">多重继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Optional"><span class="toc-number">1.3.6.</span> <span class="toc-text">Optional</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E9%9B%86%E5%90%88%E7%B1%BB%E5%92%8C%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">1.4.</span> <span class="toc-text">高级集合类和收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="toc-number">1.4.1.</span> <span class="toc-text">方法引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.4.2.</span> <span class="toc-text">元素顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">1.4.3.</span> <span class="toc-text">收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82"><span class="toc-number">1.4.4.</span> <span class="toc-text">一些细节</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%B9%B6%E8%A1%8C%E5%8C%96"><span class="toc-number">1.5.</span> <span class="toc-text">数据并行化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E3%80%81%E8%B0%83%E8%AF%95%E5%92%8C%E9%87%8D%E6%9E%84"><span class="toc-number">1.6.</span> <span class="toc-text">测试、调试和重构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E5%92%8C%E6%9E%B6%E6%9E%84%E7%9A%84%E5%8E%9F%E5%88%99"><span class="toc-number">1.7.</span> <span class="toc-text">设计和架构的原则</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/10/%E5%BB%BA%E7%AB%99%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/" title="建站第一篇文章">建站第一篇文章</a><time datetime="2023-05-09T16:25:27.000Z" title="发表于 2023-05-10 00:25:27">2023-05-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/02/19/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84Java%20Parallel%20Stream%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E4%BC%98%E5%8C%96RT%E4%B8%8E%E4%B8%B2%E8%81%94traceid/" title="微服务架构下的Java Parallel Stream实践——优化RT与串联traceid">微服务架构下的Java Parallel Stream实践——优化RT与串联traceid</a><time datetime="2023-02-19T05:03:49.000Z" title="发表于 2023-02-19 13:03:49">2023-02-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/06/19/%E3%80%8AJava8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E3%80%8B%E2%80%94%E2%80%94%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" title="Java8函数式编程">Java8函数式编程</a><time datetime="2022-06-19T04:55:29.000Z" title="发表于 2022-06-19 12:55:29">2022-06-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/05/10/Effective%20C++%20&amp;&amp;%20More%20Effective%20C++/" title="Effective C++ &amp;&amp; More Effective C++">Effective C++ &amp;&amp; More Effective C++</a><time datetime="2022-05-10T04:51:41.000Z" title="发表于 2022-05-10 12:51:41">2022-05-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/03/29/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84C++%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/" title="多线程场景下的C++字符串转换最佳实践">多线程场景下的C++字符串转换最佳实践</a><time datetime="2022-03-29T08:00:00.000Z" title="发表于 2022-03-29 16:00:00">2022-03-29</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 一个廖少少</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>