<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>微服务架构下的Java Parallel Stream实践——优化RT与串联traceid | 一知半解</title><meta name="author" content="一个廖少少"><meta name="copyright" content="一个廖少少"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="背景 在业务开发中，需要将一些图片mediaId批量调用多媒体服务的接口（FileService#copyMedia），从而实现图片替换的功能 具体链路如下，客户端RT可认为从一个请求从发出到响应的经过时间：  12345用户客户端 --&gt; MyService --&gt; FileService#copyMedia                 ↓             LaterSe">
<meta property="og:type" content="article">
<meta property="og:title" content="微服务架构下的Java Parallel Stream实践——优化RT与串联traceid">
<meta property="og:url" content="https://edisonleolhl.github.io/2023/02/19/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84Java%20Parallel%20Stream%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E4%BC%98%E5%8C%96RT%E4%B8%8E%E4%B8%B2%E8%81%94traceid/index.html">
<meta property="og:site_name" content="一知半解">
<meta property="og:description" content="背景 在业务开发中，需要将一些图片mediaId批量调用多媒体服务的接口（FileService#copyMedia），从而实现图片替换的功能 具体链路如下，客户端RT可认为从一个请求从发出到响应的经过时间：  12345用户客户端 --&gt; MyService --&gt; FileService#copyMedia                 ↓             LaterSe">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://edisonleolhl.github.io/images/avatar.jpeg">
<meta property="article:published_time" content="2023-02-19T05:03:49.000Z">
<meta property="article:modified_time" content="2023-05-12T16:11:58.061Z">
<meta property="article:author" content="一个廖少少">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Parallel Stream">
<meta property="article:tag" content="微服务">
<meta property="article:tag" content="线程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://edisonleolhl.github.io/images/avatar.jpeg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://edisonleolhl.github.io/2023/02/19/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84Java%20Parallel%20Stream%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E4%BC%98%E5%8C%96RT%E4%B8%8E%E4%B8%B2%E8%81%94traceid/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '微服务架构下的Java Parallel Stream实践——优化RT与串联traceid',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-05-13 00:11:58'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/avatar.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">54</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">63</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/cover.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="一知半解"><span class="site-name">一知半解</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">微服务架构下的Java Parallel Stream实践——优化RT与串联traceid</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-19T05:03:49.000Z" title="发表于 2023-02-19 13:03:49">2023-02-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-12T16:11:58.061Z" title="更新于 2023-05-13 00:11:58">2023-05-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="微服务架构下的Java Parallel Stream实践——优化RT与串联traceid"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ol>
<li>在业务开发中，需要将一些图片mediaId批量调用多媒体服务的接口（FileService#copyMedia），从而实现图片替换的功能</li>
<li>具体链路如下，客户端RT可认为从一个请求从发出到响应的经过时间：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">用户客户端 --&gt; MyService --&gt; FileService#copyMedia</span><br><span class="line">                 ↓</span><br><span class="line">             LaterService</span><br><span class="line">                 ↓</span><br><span class="line">用户客户端 &lt;--   ....</span><br></pre></td></tr></table></figure>

<h2 id="第一版代码"><a href="#第一版代码" class="headerlink" title="第一版代码"></a>第一版代码</h2><ol>
<li>因为项目工期较紧，第一版代码重点主要在功能完整性和准确性上，当时的做法是批量解析图片id，再批量调接口，再批量替换原位</li>
<li>在跨团队的开发联调与端到端测试后，第一版代码发布上线了，功能符合预期，也没啥bug，就是我们的报警群经常报rpc timeout的报警，客户端接口的RT也涨了不少（特别是99分位RT）</li>
<li>经过定位发现，copyMediaId接口会去访问oss生成新的mediaId，当资源跨地域时，RT显著增大，而且有些特定行业的用户（如电商）可能请求中有30、40张图片，这对copyMediaId接口造成极大的压力，RT增大是在所难免的，从而直接影响了客户端接口的RT，虽无用户直接反馈，但我们推测这个RT还是会或多或少地影响用户体验，所以要考虑如何优化RT</li>
</ol>
<blockquote>
<p>阿里云对象存储OSS介绍：<a target="_blank" rel="noopener" href="https://help.aliyun.com/document_detail/31827.html">https://help.aliyun.com/document_detail/31827.html</a></p>
</blockquote>
<h2 id="第二版代码"><a href="#第二版代码" class="headerlink" title="第二版代码"></a>第二版代码</h2><ol>
<li>我们的目标是优化客户端接口RT，而这次需求唯一引入的外部依赖就是copyMediaId接口，所以首先考虑的是copyMediaId接口的优化，但毕竟跨团队，优化意愿不强烈，于是就想着在我们内部闭环掉</li>
<li>调研后发现，发现Java8的Parallel Stream可以很好地帮我们解决问题，Parallel Stream利用了Java自身的ForkJoin线程池，借助函数式编程思想做了非常强大的封装，使得开发者编写多线程并发代码就像编写单线程代码那样简单（至少给我的感觉是这样）<blockquote>
<p>ForkJoin：默认线程池是是CPU数量-1<br>The parallel streams use the default ForkJoinPool.commonPool which by default has one less threads as you have processors, as returned by Runtime.getRuntime().availableProcessors() (This means that parallel streams leave one processor for the calling thread).<br><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/45460577/default-forkjoinpool-executor-taking-long-time">https://stackoverflow.com/questions/45460577/default-forkjoinpool-executor-taking-long-time</a></p>
</blockquote>
</li>
<li>注意并发流不保证执行顺序，所以如果要保序的话得自己再弄一下（因为我得按顺序替换到原消息体的mediaId的位置，所以得保序），很快，就写出了第二版代码（省去无关代码）：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> MediaCopyResponse <span class="title function_">mediaCopy</span><span class="params">(..., List&lt;String&gt; validMediaIds)</span> <span class="keyword">throws</span> ServiceException &#123;</span><br><span class="line">     ext = .....</span><br><span class="line">     <span class="comment">// 并发调用</span></span><br><span class="line">     <span class="type">MediaCopyResponse</span> <span class="variable">resp</span> <span class="operator">=</span> concurrentCopyMedia(..., ext, validMediaIds);</span><br><span class="line">     <span class="comment">// 并发调用可能会乱序，最后要按原顺序排序，排序也可以在parallel stream中直接做掉</span></span><br><span class="line">     resp.setModels(getSortedMediaIds(resp.getModels(), validMediaIds));</span><br><span class="line">     <span class="keyword">return</span> resp;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@description</span> 分批调用copyMedia接口缓解超时问题</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> MediaCopyResponse <span class="title function_">concurrentCopyMedia</span><span class="params">(..., Map&lt;String, String&gt; ext, List&lt;String&gt; validMediaIds)</span> &#123;</span><br><span class="line">     <span class="type">MediaCopyResponse</span> <span class="variable">resp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MediaCopyResponse</span>();</span><br><span class="line">     <span class="type">int</span> <span class="variable">mediaIdBatchSize</span> <span class="operator">=</span> ....</span><br><span class="line">     List&lt;MediaIdModel&gt; mediaIdModels = Lists.partition(validMediaIds, mediaIdBatchSize)</span><br><span class="line">             .stream()</span><br><span class="line">             .parallel()</span><br><span class="line">             .map(subList -&gt; &#123;</span><br><span class="line">                 <span class="keyword">try</span> &#123;</span><br><span class="line">                     <span class="type">MediaCopyRequest</span> <span class="variable">req</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MediaCopyRequest</span>();</span><br><span class="line">                     req.setMediaIds(subList);</span><br><span class="line">                     req.set...</span><br><span class="line"></span><br><span class="line">                     <span class="keyword">final</span> ServiceResult&lt;MediaCopyResponse&gt; sr = fileService.copyMedia(req, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">                 </span><br><span class="line">                     <span class="comment">// 注意对应关系：sublist -&gt; List&lt;MediaIdModel&gt;，最后并发流会把所有的List&lt;MediaIdModel&gt;拼起来</span></span><br><span class="line">                     <span class="keyword">return</span> sr.getResult().getModels();</span><br><span class="line">                 &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                     <span class="comment">// 务必清理 ThreadLocal 的上下文，避免异步线程复用时出现上下文互串的问题</span></span><br><span class="line">                     EagleEye.clearRpcContext();</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;)</span><br><span class="line">             .flatMap(List::stream)</span><br><span class="line">             .collect(Collectors.toList());</span><br><span class="line">     resp.setModels(mediaIdModels);</span><br><span class="line">     <span class="keyword">return</span> resp;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>调了会参，决定了每批分批的数量，arthas帮了很大的忙</li>
</ol>
<p><img src="/images/arthas.JPG" alt="arthas"></p>
<blockquote>
<p>arthas: <a target="_blank" rel="noopener" href="https://github.com/alibaba/arthas">https://github.com/alibaba/arthas</a></p>
</blockquote>
<ol start="5">
<li>嗯，代码看上去很完美了，也没有bug，经过测试也不会有mediaId乱序的问题，上线！</li>
<li>上线一切岁月静好，但在后来的一次排查问题时，发现traceid断了，这会对我们的后期运维会带来极大的麻烦</li>
</ol>
<blockquote>
<p>阿里巴巴Eagleeye，一款分布式追踪工具，与Google的Dapper很像，能够把微服务架构中的各个服务串联起来，参考：<a target="_blank" rel="noopener" href="https://www.alibabacloud.com/blog/alibaba-eagleeye-ensuring-business-continuity-through-link-monitoring_594157">https://www.alibabacloud.com/blog/alibaba-eagleeye-ensuring-business-continuity-through-link-monitoring_594157</a><br>美团技术团队的这篇文章很完整地描述了traceid丢失的现象与本质：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/T7P2-tiroXWI9xd8FhsuFA">https://mp.weixin.qq.com/s/T7P2-tiroXWI9xd8FhsuFA</a></p>
</blockquote>
<h2 id="第三版代码"><a href="#第三版代码" class="headerlink" title="第三版代码"></a>第三版代码</h2><ol>
<li>traceid信息其实放在ThreadLocal里面，写Java的同学或多或少都了解过，经过搜索，发现Eagleeye已有对策</li>
<li>『异步线程时需要手动传递上下文，当业务逻辑转移到异步线程时，需要先备份 EagleEye 的调用上下文到异步任务中，保证链路的正确性。』</li>
<li>加几行代码，收工！</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> MediaCopyResponse <span class="title function_">concurrentCopyMedia</span><span class="params">(..., Map&lt;String, String&gt; ext, List&lt;String&gt; validMediaIds)</span> &#123;</span><br><span class="line">    <span class="type">MediaCopyResponse</span> <span class="variable">resp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MediaCopyResponse</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">mediaIdBatchSize</span> <span class="operator">=</span> xxx</span><br><span class="line">    <span class="type">Object</span> <span class="variable">ctx</span> <span class="operator">=</span> EagleEye.getRpcContext();</span><br><span class="line">    List&lt;MediaIdModel&gt; mediaIdModels = Lists.partition(validMediaIds, mediaIdBatchSize)</span><br><span class="line">            .stream()</span><br><span class="line">            .parallel()</span><br><span class="line">            .map(subList -&gt; &#123;</span><br><span class="line">                EagleEye.setRpcContext(ctx);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">MediaCopyRequest</span> <span class="variable">req</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MediaCopyRequest</span>();</span><br><span class="line">                    req.setMediaIds(subList);</span><br><span class="line">                    req.setxxx</span><br><span class="line">                    <span class="keyword">final</span> ServiceResult&lt;MediaCopyResponse&gt; sr = fileService.copyMedia(req, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">                  </span><br><span class="line">                    <span class="keyword">return</span> sr.getResult().getModels();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 务必清理 ThreadLocal 的上下文，避免异步线程复用时出现上下文互串的问题</span></span><br><span class="line">                    EagleEye.clearRpcContext();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .flatMap(List::stream)</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    <span class="comment">// forkjoin线程池可能复用主线程，在主线程中执行EagleEye.clearRpcContext()，所以这里需要恢复</span></span><br><span class="line">    EagleEye.setRpcContext(ctx);</span><br><span class="line">    resp.setModels(mediaIdModels);</span><br><span class="line">    <span class="keyword">return</span> resp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>串联traceid：</p>
<p><img src="/images/trace.JPG" alt="trace"></p>
<blockquote>
<p>原文发表于 2023-02-19</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://edisonleolhl.github.io">一个廖少少</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://edisonleolhl.github.io/2023/02/19/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84Java%20Parallel%20Stream%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E4%BC%98%E5%8C%96RT%E4%B8%8E%E4%B8%B2%E8%81%94traceid/">https://edisonleolhl.github.io/2023/02/19/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84Java%20Parallel%20Stream%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E4%BC%98%E5%8C%96RT%E4%B8%8E%E4%B8%B2%E8%81%94traceid/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://edisonleolhl.github.io" target="_blank">一知半解</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/Parallel-Stream/">Parallel Stream</a><a class="post-meta__tags" href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</a><a class="post-meta__tags" href="/tags/%E7%BA%BF%E7%A8%8B/">线程</a></div><div class="post_share"><div class="social-share" data-image="/images/avatar.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/04/12/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%94%B1gmock%E5%BC%95%E5%8F%91%E7%9A%84%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84/" title="记一次由gmock引发的代码重构"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">记一次由gmock引发的代码重构</div></div></a></div><div class="next-post pull-right"><a href="/2022/07/26/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/" title="缓存一致性"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">缓存一致性</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/05/12/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84Java%20ThreadLocal%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E7%BC%93%E5%AD%98%E9%87%8D%E5%A4%8DRPC%E7%BB%93%E6%9E%9C/" title="微服务架构下的Java ThreadLocal实践——缓存重复RPC结果"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-12</div><div class="title">微服务架构下的Java ThreadLocal实践——缓存重复RPC结果</div></div></a></div><div><a href="/2022/02/27/%E6%8E%A2%E7%A7%98Java%E4%B8%AD%E7%9A%84ThreadLocal/" title="探秘Java中的ThreadLocal"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-27</div><div class="title">探秘Java中的ThreadLocal</div></div></a></div><div><a href="/2023/05/11/Java%E6%96%B0%E7%89%B9%E6%80%A7/" title="Java新特性"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-11</div><div class="title">Java新特性</div></div></a></div><div><a href="/2016/09/20/%E6%8E%A2%E7%A7%98Java%E4%B8%AD==%E4%B8%8Eequals()%E7%9A%84%E5%8C%BA%E5%88%AB/" title="探秘Java中&#x3D;&#x3D;与equals()的区别"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2016-09-20</div><div class="title">探秘Java中&#x3D;&#x3D;与equals()的区别</div></div></a></div><div><a href="/2022/06/19/%E3%80%8AJava8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E3%80%8B%E2%80%94%E2%80%94%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" title="Java8函数式编程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-19</div><div class="title">Java8函数式编程</div></div></a></div><div><a href="/2021/11/17/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E3%80%8B%E2%80%94%E2%80%94%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" title="《深入理解Java虚拟机：JVM高级特性与最佳实践》——读书笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-17</div><div class="title">《深入理解Java虚拟机：JVM高级特性与最佳实践》——读书笔记</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/avatar.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">一个廖少少</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">54</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">63</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/edisonleolhl"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/edisonleolhl" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:edisonleolhl@foxmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://www.jianshu.com/u/28b41b12cde8" target="_blank" title="jianshu"><i class="fas fa-link" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Go Big or Go Home</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%8C%E6%99%AF"><span class="toc-number">1.</span> <span class="toc-text">背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%89%88%E4%BB%A3%E7%A0%81"><span class="toc-number">2.</span> <span class="toc-text">第一版代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%89%88%E4%BB%A3%E7%A0%81"><span class="toc-number">3.</span> <span class="toc-text">第二版代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%89%88%E4%BB%A3%E7%A0%81"><span class="toc-number">4.</span> <span class="toc-text">第三版代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%9C"><span class="toc-number">5.</span> <span class="toc-text">结果</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/15/Rocketmq%E5%8E%9F%E7%90%86/" title="Rocketmq原理">Rocketmq原理</a><time datetime="2023-05-15T07:00:18.000Z" title="发表于 2023-05-15 15:00:18">2023-05-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/12/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84Java%20ThreadLocal%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E7%BC%93%E5%AD%98%E9%87%8D%E5%A4%8DRPC%E7%BB%93%E6%9E%9C/" title="微服务架构下的Java ThreadLocal实践——缓存重复RPC结果">微服务架构下的Java ThreadLocal实践——缓存重复RPC结果</a><time datetime="2023-05-12T05:31:47.000Z" title="发表于 2023-05-12 13:31:47">2023-05-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/11/C++%E6%96%B0%E7%89%B9%E6%80%A7/" title="C++新特性">C++新特性</a><time datetime="2023-05-11T05:41:59.000Z" title="发表于 2023-05-11 13:41:59">2023-05-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/11/Java%E6%96%B0%E7%89%B9%E6%80%A7/" title="Java新特性">Java新特性</a><time datetime="2023-05-11T03:29:22.000Z" title="发表于 2023-05-11 11:29:22">2023-05-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/10/%E5%BB%BA%E7%AB%99%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/" title="建站第一篇文章">建站第一篇文章</a><time datetime="2023-05-09T16:25:27.000Z" title="发表于 2023-05-10 00:25:27">2023-05-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 一个廖少少</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>